/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const dcnet = $root.dcnet = (() => {

    /**
     * Namespace dcnet.
     * @exports dcnet
     * @namespace
     */
    const dcnet = {};

    dcnet.pb = (function() {

        /**
         * Namespace pb.
         * @memberof dcnet
         * @namespace
         */
        const pb = {};

        pb.StoreThreadRequest = (function() {

            /**
             * Properties of a StoreThreadRequest.
             * @memberof dcnet.pb
             * @interface IStoreThreadRequest
             * @property {Uint8Array|null} [threadId] StoreThreadRequest threadId
             * @property {Uint8Array|null} [userPubkey] StoreThreadRequest userPubkey
             * @property {Uint8Array|null} [serviceKeyEncrypt] StoreThreadRequest serviceKeyEncrypt
             */

            /**
             * Constructs a new StoreThreadRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a StoreThreadRequest.
             * @implements IStoreThreadRequest
             * @constructor
             * @param {dcnet.pb.IStoreThreadRequest=} [properties] Properties to set
             */
            function StoreThreadRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoreThreadRequest threadId.
             * @member {Uint8Array} threadId
             * @memberof dcnet.pb.StoreThreadRequest
             * @instance
             */
            StoreThreadRequest.prototype.threadId = $util.newBuffer([]);

            /**
             * StoreThreadRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.StoreThreadRequest
             * @instance
             */
            StoreThreadRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * StoreThreadRequest serviceKeyEncrypt.
             * @member {Uint8Array} serviceKeyEncrypt
             * @memberof dcnet.pb.StoreThreadRequest
             * @instance
             */
            StoreThreadRequest.prototype.serviceKeyEncrypt = $util.newBuffer([]);

            /**
             * Creates a new StoreThreadRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.StoreThreadRequest
             * @static
             * @param {dcnet.pb.IStoreThreadRequest=} [properties] Properties to set
             * @returns {dcnet.pb.StoreThreadRequest} StoreThreadRequest instance
             */
            StoreThreadRequest.create = function create(properties) {
                return new StoreThreadRequest(properties);
            };

            /**
             * Encodes the specified StoreThreadRequest message. Does not implicitly {@link dcnet.pb.StoreThreadRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.StoreThreadRequest
             * @static
             * @param {dcnet.pb.IStoreThreadRequest} message StoreThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreThreadRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadId != null && Object.hasOwnProperty.call(message, "threadId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.threadId);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.userPubkey);
                if (message.serviceKeyEncrypt != null && Object.hasOwnProperty.call(message, "serviceKeyEncrypt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.serviceKeyEncrypt);
                return writer;
            };

            /**
             * Encodes the specified StoreThreadRequest message, length delimited. Does not implicitly {@link dcnet.pb.StoreThreadRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.StoreThreadRequest
             * @static
             * @param {dcnet.pb.IStoreThreadRequest} message StoreThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreThreadRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoreThreadRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.StoreThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.StoreThreadRequest} StoreThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreThreadRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.StoreThreadRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadId = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.serviceKeyEncrypt = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoreThreadRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.StoreThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.StoreThreadRequest} StoreThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreThreadRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoreThreadRequest message.
             * @function verify
             * @memberof dcnet.pb.StoreThreadRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoreThreadRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    if (!(message.threadId && typeof message.threadId.length === "number" || $util.isString(message.threadId)))
                        return "threadId: buffer expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.serviceKeyEncrypt != null && message.hasOwnProperty("serviceKeyEncrypt"))
                    if (!(message.serviceKeyEncrypt && typeof message.serviceKeyEncrypt.length === "number" || $util.isString(message.serviceKeyEncrypt)))
                        return "serviceKeyEncrypt: buffer expected";
                return null;
            };

            /**
             * Creates a StoreThreadRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.StoreThreadRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.StoreThreadRequest} StoreThreadRequest
             */
            StoreThreadRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.StoreThreadRequest)
                    return object;
                let message = new $root.dcnet.pb.StoreThreadRequest();
                if (object.threadId != null)
                    if (typeof object.threadId === "string")
                        $util.base64.decode(object.threadId, message.threadId = $util.newBuffer($util.base64.length(object.threadId)), 0);
                    else if (object.threadId.length >= 0)
                        message.threadId = object.threadId;
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.serviceKeyEncrypt != null)
                    if (typeof object.serviceKeyEncrypt === "string")
                        $util.base64.decode(object.serviceKeyEncrypt, message.serviceKeyEncrypt = $util.newBuffer($util.base64.length(object.serviceKeyEncrypt)), 0);
                    else if (object.serviceKeyEncrypt.length >= 0)
                        message.serviceKeyEncrypt = object.serviceKeyEncrypt;
                return message;
            };

            /**
             * Creates a plain object from a StoreThreadRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.StoreThreadRequest
             * @static
             * @param {dcnet.pb.StoreThreadRequest} message StoreThreadRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreThreadRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.threadId = "";
                    else {
                        object.threadId = [];
                        if (options.bytes !== Array)
                            object.threadId = $util.newBuffer(object.threadId);
                    }
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.serviceKeyEncrypt = "";
                    else {
                        object.serviceKeyEncrypt = [];
                        if (options.bytes !== Array)
                            object.serviceKeyEncrypt = $util.newBuffer(object.serviceKeyEncrypt);
                    }
                }
                if (message.threadId != null && message.hasOwnProperty("threadId"))
                    object.threadId = options.bytes === String ? $util.base64.encode(message.threadId, 0, message.threadId.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadId) : message.threadId;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.serviceKeyEncrypt != null && message.hasOwnProperty("serviceKeyEncrypt"))
                    object.serviceKeyEncrypt = options.bytes === String ? $util.base64.encode(message.serviceKeyEncrypt, 0, message.serviceKeyEncrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.serviceKeyEncrypt) : message.serviceKeyEncrypt;
                return object;
            };

            /**
             * Converts this StoreThreadRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.StoreThreadRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoreThreadRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StoreThreadRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.StoreThreadRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StoreThreadRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.StoreThreadRequest";
            };

            return StoreThreadRequest;
        })();

        pb.StoreThreadReply = (function() {

            /**
             * Properties of a StoreThreadReply.
             * @memberof dcnet.pb
             * @interface IStoreThreadReply
             * @property {number|null} [status] StoreThreadReply status
             */

            /**
             * Constructs a new StoreThreadReply.
             * @memberof dcnet.pb
             * @classdesc Represents a StoreThreadReply.
             * @implements IStoreThreadReply
             * @constructor
             * @param {dcnet.pb.IStoreThreadReply=} [properties] Properties to set
             */
            function StoreThreadReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoreThreadReply status.
             * @member {number} status
             * @memberof dcnet.pb.StoreThreadReply
             * @instance
             */
            StoreThreadReply.prototype.status = 0;

            /**
             * Creates a new StoreThreadReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.StoreThreadReply
             * @static
             * @param {dcnet.pb.IStoreThreadReply=} [properties] Properties to set
             * @returns {dcnet.pb.StoreThreadReply} StoreThreadReply instance
             */
            StoreThreadReply.create = function create(properties) {
                return new StoreThreadReply(properties);
            };

            /**
             * Encodes the specified StoreThreadReply message. Does not implicitly {@link dcnet.pb.StoreThreadReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.StoreThreadReply
             * @static
             * @param {dcnet.pb.IStoreThreadReply} message StoreThreadReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreThreadReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                return writer;
            };

            /**
             * Encodes the specified StoreThreadReply message, length delimited. Does not implicitly {@link dcnet.pb.StoreThreadReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.StoreThreadReply
             * @static
             * @param {dcnet.pb.IStoreThreadReply} message StoreThreadReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreThreadReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoreThreadReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.StoreThreadReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.StoreThreadReply} StoreThreadReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreThreadReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.StoreThreadReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.status = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoreThreadReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.StoreThreadReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.StoreThreadReply} StoreThreadReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreThreadReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoreThreadReply message.
             * @function verify
             * @memberof dcnet.pb.StoreThreadReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoreThreadReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                return null;
            };

            /**
             * Creates a StoreThreadReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.StoreThreadReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.StoreThreadReply} StoreThreadReply
             */
            StoreThreadReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.StoreThreadReply)
                    return object;
                let message = new $root.dcnet.pb.StoreThreadReply();
                if (object.status != null)
                    message.status = object.status | 0;
                return message;
            };

            /**
             * Creates a plain object from a StoreThreadReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.StoreThreadReply
             * @static
             * @param {dcnet.pb.StoreThreadReply} message StoreThreadReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreThreadReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.status = 0;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                return object;
            };

            /**
             * Converts this StoreThreadReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.StoreThreadReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoreThreadReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StoreThreadReply
             * @function getTypeUrl
             * @memberof dcnet.pb.StoreThreadReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StoreThreadReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.StoreThreadReply";
            };

            return StoreThreadReply;
        })();

        pb.StroeFileToPeerRequest = (function() {

            /**
             * Properties of a StroeFileToPeerRequest.
             * @memberof dcnet.pb
             * @interface IStroeFileToPeerRequest
             * @property {Uint8Array|null} [cid] StroeFileToPeerRequest cid
             * @property {number|Long|null} [size] StroeFileToPeerRequest size
             * @property {Uint8Array|null} [userPubkey] StroeFileToPeerRequest userPubkey
             */

            /**
             * Constructs a new StroeFileToPeerRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a StroeFileToPeerRequest.
             * @implements IStroeFileToPeerRequest
             * @constructor
             * @param {dcnet.pb.IStroeFileToPeerRequest=} [properties] Properties to set
             */
            function StroeFileToPeerRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StroeFileToPeerRequest cid.
             * @member {Uint8Array} cid
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @instance
             */
            StroeFileToPeerRequest.prototype.cid = $util.newBuffer([]);

            /**
             * StroeFileToPeerRequest size.
             * @member {number|Long} size
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @instance
             */
            StroeFileToPeerRequest.prototype.size = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * StroeFileToPeerRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @instance
             */
            StroeFileToPeerRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * Creates a new StroeFileToPeerRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @static
             * @param {dcnet.pb.IStroeFileToPeerRequest=} [properties] Properties to set
             * @returns {dcnet.pb.StroeFileToPeerRequest} StroeFileToPeerRequest instance
             */
            StroeFileToPeerRequest.create = function create(properties) {
                return new StroeFileToPeerRequest(properties);
            };

            /**
             * Encodes the specified StroeFileToPeerRequest message. Does not implicitly {@link dcnet.pb.StroeFileToPeerRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @static
             * @param {dcnet.pb.IStroeFileToPeerRequest} message StroeFileToPeerRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StroeFileToPeerRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cid != null && Object.hasOwnProperty.call(message, "cid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.cid);
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.size);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.userPubkey);
                return writer;
            };

            /**
             * Encodes the specified StroeFileToPeerRequest message, length delimited. Does not implicitly {@link dcnet.pb.StroeFileToPeerRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @static
             * @param {dcnet.pb.IStroeFileToPeerRequest} message StroeFileToPeerRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StroeFileToPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StroeFileToPeerRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.StroeFileToPeerRequest} StroeFileToPeerRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StroeFileToPeerRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.StroeFileToPeerRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cid = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.size = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StroeFileToPeerRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.StroeFileToPeerRequest} StroeFileToPeerRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StroeFileToPeerRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StroeFileToPeerRequest message.
             * @function verify
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StroeFileToPeerRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cid != null && message.hasOwnProperty("cid"))
                    if (!(message.cid && typeof message.cid.length === "number" || $util.isString(message.cid)))
                        return "cid: buffer expected";
                if (message.size != null && message.hasOwnProperty("size"))
                    if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                        return "size: integer|Long expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                return null;
            };

            /**
             * Creates a StroeFileToPeerRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.StroeFileToPeerRequest} StroeFileToPeerRequest
             */
            StroeFileToPeerRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.StroeFileToPeerRequest)
                    return object;
                let message = new $root.dcnet.pb.StroeFileToPeerRequest();
                if (object.cid != null)
                    if (typeof object.cid === "string")
                        $util.base64.decode(object.cid, message.cid = $util.newBuffer($util.base64.length(object.cid)), 0);
                    else if (object.cid.length >= 0)
                        message.cid = object.cid;
                if (object.size != null)
                    if ($util.Long)
                        (message.size = $util.Long.fromValue(object.size)).unsigned = true;
                    else if (typeof object.size === "string")
                        message.size = parseInt(object.size, 10);
                    else if (typeof object.size === "number")
                        message.size = object.size;
                    else if (typeof object.size === "object")
                        message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber(true);
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                return message;
            };

            /**
             * Creates a plain object from a StroeFileToPeerRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @static
             * @param {dcnet.pb.StroeFileToPeerRequest} message StroeFileToPeerRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StroeFileToPeerRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.cid = "";
                    else {
                        object.cid = [];
                        if (options.bytes !== Array)
                            object.cid = $util.newBuffer(object.cid);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.size = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                }
                if (message.cid != null && message.hasOwnProperty("cid"))
                    object.cid = options.bytes === String ? $util.base64.encode(message.cid, 0, message.cid.length) : options.bytes === Array ? Array.prototype.slice.call(message.cid) : message.cid;
                if (message.size != null && message.hasOwnProperty("size"))
                    if (typeof message.size === "number")
                        object.size = options.longs === String ? String(message.size) : message.size;
                    else
                        object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber(true) : message.size;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                return object;
            };

            /**
             * Converts this StroeFileToPeerRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StroeFileToPeerRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StroeFileToPeerRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.StroeFileToPeerRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StroeFileToPeerRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.StroeFileToPeerRequest";
            };

            return StroeFileToPeerRequest;
        })();

        pb.StroeFileToPeerReply = (function() {

            /**
             * Properties of a StroeFileToPeerReply.
             * @memberof dcnet.pb
             * @interface IStroeFileToPeerReply
             * @property {number|null} [status] StroeFileToPeerReply status
             * @property {number|Long|null} [receivesize] StroeFileToPeerReply receivesize
             */

            /**
             * Constructs a new StroeFileToPeerReply.
             * @memberof dcnet.pb
             * @classdesc Represents a StroeFileToPeerReply.
             * @implements IStroeFileToPeerReply
             * @constructor
             * @param {dcnet.pb.IStroeFileToPeerReply=} [properties] Properties to set
             */
            function StroeFileToPeerReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StroeFileToPeerReply status.
             * @member {number} status
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @instance
             */
            StroeFileToPeerReply.prototype.status = 0;

            /**
             * StroeFileToPeerReply receivesize.
             * @member {number|Long} receivesize
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @instance
             */
            StroeFileToPeerReply.prototype.receivesize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new StroeFileToPeerReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @static
             * @param {dcnet.pb.IStroeFileToPeerReply=} [properties] Properties to set
             * @returns {dcnet.pb.StroeFileToPeerReply} StroeFileToPeerReply instance
             */
            StroeFileToPeerReply.create = function create(properties) {
                return new StroeFileToPeerReply(properties);
            };

            /**
             * Encodes the specified StroeFileToPeerReply message. Does not implicitly {@link dcnet.pb.StroeFileToPeerReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @static
             * @param {dcnet.pb.IStroeFileToPeerReply} message StroeFileToPeerReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StroeFileToPeerReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.receivesize != null && Object.hasOwnProperty.call(message, "receivesize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.receivesize);
                return writer;
            };

            /**
             * Encodes the specified StroeFileToPeerReply message, length delimited. Does not implicitly {@link dcnet.pb.StroeFileToPeerReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @static
             * @param {dcnet.pb.IStroeFileToPeerReply} message StroeFileToPeerReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StroeFileToPeerReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StroeFileToPeerReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.StroeFileToPeerReply} StroeFileToPeerReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StroeFileToPeerReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.StroeFileToPeerReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.status = reader.int32();
                            break;
                        }
                    case 2: {
                            message.receivesize = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StroeFileToPeerReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.StroeFileToPeerReply} StroeFileToPeerReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StroeFileToPeerReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StroeFileToPeerReply message.
             * @function verify
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StroeFileToPeerReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                if (message.receivesize != null && message.hasOwnProperty("receivesize"))
                    if (!$util.isInteger(message.receivesize) && !(message.receivesize && $util.isInteger(message.receivesize.low) && $util.isInteger(message.receivesize.high)))
                        return "receivesize: integer|Long expected";
                return null;
            };

            /**
             * Creates a StroeFileToPeerReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.StroeFileToPeerReply} StroeFileToPeerReply
             */
            StroeFileToPeerReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.StroeFileToPeerReply)
                    return object;
                let message = new $root.dcnet.pb.StroeFileToPeerReply();
                if (object.status != null)
                    message.status = object.status | 0;
                if (object.receivesize != null)
                    if ($util.Long)
                        (message.receivesize = $util.Long.fromValue(object.receivesize)).unsigned = false;
                    else if (typeof object.receivesize === "string")
                        message.receivesize = parseInt(object.receivesize, 10);
                    else if (typeof object.receivesize === "number")
                        message.receivesize = object.receivesize;
                    else if (typeof object.receivesize === "object")
                        message.receivesize = new $util.LongBits(object.receivesize.low >>> 0, object.receivesize.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a StroeFileToPeerReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @static
             * @param {dcnet.pb.StroeFileToPeerReply} message StroeFileToPeerReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StroeFileToPeerReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.status = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.receivesize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.receivesize = options.longs === String ? "0" : 0;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                if (message.receivesize != null && message.hasOwnProperty("receivesize"))
                    if (typeof message.receivesize === "number")
                        object.receivesize = options.longs === String ? String(message.receivesize) : message.receivesize;
                    else
                        object.receivesize = options.longs === String ? $util.Long.prototype.toString.call(message.receivesize) : options.longs === Number ? new $util.LongBits(message.receivesize.low >>> 0, message.receivesize.high >>> 0).toNumber() : message.receivesize;
                return object;
            };

            /**
             * Converts this StroeFileToPeerReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StroeFileToPeerReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StroeFileToPeerReply
             * @function getTypeUrl
             * @memberof dcnet.pb.StroeFileToPeerReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StroeFileToPeerReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.StroeFileToPeerReply";
            };

            return StroeFileToPeerReply;
        })();

        pb.OnlineStatusCheckRequest = (function() {

            /**
             * Properties of an OnlineStatusCheckRequest.
             * @memberof dcnet.pb
             * @interface IOnlineStatusCheckRequest
             * @property {Uint8Array|null} [challenge] OnlineStatusCheckRequest challenge
             */

            /**
             * Constructs a new OnlineStatusCheckRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an OnlineStatusCheckRequest.
             * @implements IOnlineStatusCheckRequest
             * @constructor
             * @param {dcnet.pb.IOnlineStatusCheckRequest=} [properties] Properties to set
             */
            function OnlineStatusCheckRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OnlineStatusCheckRequest challenge.
             * @member {Uint8Array} challenge
             * @memberof dcnet.pb.OnlineStatusCheckRequest
             * @instance
             */
            OnlineStatusCheckRequest.prototype.challenge = $util.newBuffer([]);

            /**
             * Creates a new OnlineStatusCheckRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.OnlineStatusCheckRequest
             * @static
             * @param {dcnet.pb.IOnlineStatusCheckRequest=} [properties] Properties to set
             * @returns {dcnet.pb.OnlineStatusCheckRequest} OnlineStatusCheckRequest instance
             */
            OnlineStatusCheckRequest.create = function create(properties) {
                return new OnlineStatusCheckRequest(properties);
            };

            /**
             * Encodes the specified OnlineStatusCheckRequest message. Does not implicitly {@link dcnet.pb.OnlineStatusCheckRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.OnlineStatusCheckRequest
             * @static
             * @param {dcnet.pb.IOnlineStatusCheckRequest} message OnlineStatusCheckRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OnlineStatusCheckRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.challenge != null && Object.hasOwnProperty.call(message, "challenge"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.challenge);
                return writer;
            };

            /**
             * Encodes the specified OnlineStatusCheckRequest message, length delimited. Does not implicitly {@link dcnet.pb.OnlineStatusCheckRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.OnlineStatusCheckRequest
             * @static
             * @param {dcnet.pb.IOnlineStatusCheckRequest} message OnlineStatusCheckRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OnlineStatusCheckRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OnlineStatusCheckRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.OnlineStatusCheckRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.OnlineStatusCheckRequest} OnlineStatusCheckRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OnlineStatusCheckRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.OnlineStatusCheckRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.challenge = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OnlineStatusCheckRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.OnlineStatusCheckRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.OnlineStatusCheckRequest} OnlineStatusCheckRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OnlineStatusCheckRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OnlineStatusCheckRequest message.
             * @function verify
             * @memberof dcnet.pb.OnlineStatusCheckRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OnlineStatusCheckRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.challenge != null && message.hasOwnProperty("challenge"))
                    if (!(message.challenge && typeof message.challenge.length === "number" || $util.isString(message.challenge)))
                        return "challenge: buffer expected";
                return null;
            };

            /**
             * Creates an OnlineStatusCheckRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.OnlineStatusCheckRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.OnlineStatusCheckRequest} OnlineStatusCheckRequest
             */
            OnlineStatusCheckRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.OnlineStatusCheckRequest)
                    return object;
                let message = new $root.dcnet.pb.OnlineStatusCheckRequest();
                if (object.challenge != null)
                    if (typeof object.challenge === "string")
                        $util.base64.decode(object.challenge, message.challenge = $util.newBuffer($util.base64.length(object.challenge)), 0);
                    else if (object.challenge.length >= 0)
                        message.challenge = object.challenge;
                return message;
            };

            /**
             * Creates a plain object from an OnlineStatusCheckRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.OnlineStatusCheckRequest
             * @static
             * @param {dcnet.pb.OnlineStatusCheckRequest} message OnlineStatusCheckRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OnlineStatusCheckRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.challenge = "";
                    else {
                        object.challenge = [];
                        if (options.bytes !== Array)
                            object.challenge = $util.newBuffer(object.challenge);
                    }
                if (message.challenge != null && message.hasOwnProperty("challenge"))
                    object.challenge = options.bytes === String ? $util.base64.encode(message.challenge, 0, message.challenge.length) : options.bytes === Array ? Array.prototype.slice.call(message.challenge) : message.challenge;
                return object;
            };

            /**
             * Converts this OnlineStatusCheckRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.OnlineStatusCheckRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OnlineStatusCheckRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OnlineStatusCheckRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.OnlineStatusCheckRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OnlineStatusCheckRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.OnlineStatusCheckRequest";
            };

            return OnlineStatusCheckRequest;
        })();

        pb.OnlineStatusCheckReply = (function() {

            /**
             * Properties of an OnlineStatusCheckReply.
             * @memberof dcnet.pb
             * @interface IOnlineStatusCheckReply
             * @property {Uint8Array|null} [teereport] OnlineStatusCheckReply teereport
             */

            /**
             * Constructs a new OnlineStatusCheckReply.
             * @memberof dcnet.pb
             * @classdesc Represents an OnlineStatusCheckReply.
             * @implements IOnlineStatusCheckReply
             * @constructor
             * @param {dcnet.pb.IOnlineStatusCheckReply=} [properties] Properties to set
             */
            function OnlineStatusCheckReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OnlineStatusCheckReply teereport.
             * @member {Uint8Array} teereport
             * @memberof dcnet.pb.OnlineStatusCheckReply
             * @instance
             */
            OnlineStatusCheckReply.prototype.teereport = $util.newBuffer([]);

            /**
             * Creates a new OnlineStatusCheckReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.OnlineStatusCheckReply
             * @static
             * @param {dcnet.pb.IOnlineStatusCheckReply=} [properties] Properties to set
             * @returns {dcnet.pb.OnlineStatusCheckReply} OnlineStatusCheckReply instance
             */
            OnlineStatusCheckReply.create = function create(properties) {
                return new OnlineStatusCheckReply(properties);
            };

            /**
             * Encodes the specified OnlineStatusCheckReply message. Does not implicitly {@link dcnet.pb.OnlineStatusCheckReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.OnlineStatusCheckReply
             * @static
             * @param {dcnet.pb.IOnlineStatusCheckReply} message OnlineStatusCheckReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OnlineStatusCheckReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.teereport != null && Object.hasOwnProperty.call(message, "teereport"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.teereport);
                return writer;
            };

            /**
             * Encodes the specified OnlineStatusCheckReply message, length delimited. Does not implicitly {@link dcnet.pb.OnlineStatusCheckReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.OnlineStatusCheckReply
             * @static
             * @param {dcnet.pb.IOnlineStatusCheckReply} message OnlineStatusCheckReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OnlineStatusCheckReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OnlineStatusCheckReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.OnlineStatusCheckReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.OnlineStatusCheckReply} OnlineStatusCheckReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OnlineStatusCheckReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.OnlineStatusCheckReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.teereport = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OnlineStatusCheckReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.OnlineStatusCheckReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.OnlineStatusCheckReply} OnlineStatusCheckReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OnlineStatusCheckReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OnlineStatusCheckReply message.
             * @function verify
             * @memberof dcnet.pb.OnlineStatusCheckReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OnlineStatusCheckReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    if (!(message.teereport && typeof message.teereport.length === "number" || $util.isString(message.teereport)))
                        return "teereport: buffer expected";
                return null;
            };

            /**
             * Creates an OnlineStatusCheckReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.OnlineStatusCheckReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.OnlineStatusCheckReply} OnlineStatusCheckReply
             */
            OnlineStatusCheckReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.OnlineStatusCheckReply)
                    return object;
                let message = new $root.dcnet.pb.OnlineStatusCheckReply();
                if (object.teereport != null)
                    if (typeof object.teereport === "string")
                        $util.base64.decode(object.teereport, message.teereport = $util.newBuffer($util.base64.length(object.teereport)), 0);
                    else if (object.teereport.length >= 0)
                        message.teereport = object.teereport;
                return message;
            };

            /**
             * Creates a plain object from an OnlineStatusCheckReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.OnlineStatusCheckReply
             * @static
             * @param {dcnet.pb.OnlineStatusCheckReply} message OnlineStatusCheckReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OnlineStatusCheckReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.teereport = "";
                    else {
                        object.teereport = [];
                        if (options.bytes !== Array)
                            object.teereport = $util.newBuffer(object.teereport);
                    }
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    object.teereport = options.bytes === String ? $util.base64.encode(message.teereport, 0, message.teereport.length) : options.bytes === Array ? Array.prototype.slice.call(message.teereport) : message.teereport;
                return object;
            };

            /**
             * Converts this OnlineStatusCheckReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.OnlineStatusCheckReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OnlineStatusCheckReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OnlineStatusCheckReply
             * @function getTypeUrl
             * @memberof dcnet.pb.OnlineStatusCheckReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OnlineStatusCheckReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.OnlineStatusCheckReply";
            };

            return OnlineStatusCheckReply;
        })();

        pb.CheckPeerStatusRequest = (function() {

            /**
             * Properties of a CheckPeerStatusRequest.
             * @memberof dcnet.pb
             * @interface ICheckPeerStatusRequest
             * @property {dcnet.pb.CheckPeerStatusRequest.ISreq|null} [sreq] CheckPeerStatusRequest sreq
             * @property {Uint8Array|null} [teereport] CheckPeerStatusRequest teereport
             */

            /**
             * Constructs a new CheckPeerStatusRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a CheckPeerStatusRequest.
             * @implements ICheckPeerStatusRequest
             * @constructor
             * @param {dcnet.pb.ICheckPeerStatusRequest=} [properties] Properties to set
             */
            function CheckPeerStatusRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CheckPeerStatusRequest sreq.
             * @member {dcnet.pb.CheckPeerStatusRequest.ISreq|null|undefined} sreq
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @instance
             */
            CheckPeerStatusRequest.prototype.sreq = null;

            /**
             * CheckPeerStatusRequest teereport.
             * @member {Uint8Array|null|undefined} teereport
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @instance
             */
            CheckPeerStatusRequest.prototype.teereport = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * CheckPeerStatusRequest payload.
             * @member {"sreq"|"teereport"|undefined} payload
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @instance
             */
            Object.defineProperty(CheckPeerStatusRequest.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["sreq", "teereport"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new CheckPeerStatusRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @static
             * @param {dcnet.pb.ICheckPeerStatusRequest=} [properties] Properties to set
             * @returns {dcnet.pb.CheckPeerStatusRequest} CheckPeerStatusRequest instance
             */
            CheckPeerStatusRequest.create = function create(properties) {
                return new CheckPeerStatusRequest(properties);
            };

            /**
             * Encodes the specified CheckPeerStatusRequest message. Does not implicitly {@link dcnet.pb.CheckPeerStatusRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @static
             * @param {dcnet.pb.ICheckPeerStatusRequest} message CheckPeerStatusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckPeerStatusRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sreq != null && Object.hasOwnProperty.call(message, "sreq"))
                    $root.dcnet.pb.CheckPeerStatusRequest.Sreq.encode(message.sreq, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.teereport != null && Object.hasOwnProperty.call(message, "teereport"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.teereport);
                return writer;
            };

            /**
             * Encodes the specified CheckPeerStatusRequest message, length delimited. Does not implicitly {@link dcnet.pb.CheckPeerStatusRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @static
             * @param {dcnet.pb.ICheckPeerStatusRequest} message CheckPeerStatusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckPeerStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CheckPeerStatusRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.CheckPeerStatusRequest} CheckPeerStatusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckPeerStatusRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.CheckPeerStatusRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sreq = $root.dcnet.pb.CheckPeerStatusRequest.Sreq.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.teereport = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CheckPeerStatusRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.CheckPeerStatusRequest} CheckPeerStatusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckPeerStatusRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CheckPeerStatusRequest message.
             * @function verify
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CheckPeerStatusRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.sreq != null && message.hasOwnProperty("sreq")) {
                    properties.payload = 1;
                    {
                        let error = $root.dcnet.pb.CheckPeerStatusRequest.Sreq.verify(message.sreq);
                        if (error)
                            return "sreq." + error;
                    }
                }
                if (message.teereport != null && message.hasOwnProperty("teereport")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    if (!(message.teereport && typeof message.teereport.length === "number" || $util.isString(message.teereport)))
                        return "teereport: buffer expected";
                }
                return null;
            };

            /**
             * Creates a CheckPeerStatusRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.CheckPeerStatusRequest} CheckPeerStatusRequest
             */
            CheckPeerStatusRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.CheckPeerStatusRequest)
                    return object;
                let message = new $root.dcnet.pb.CheckPeerStatusRequest();
                if (object.sreq != null) {
                    if (typeof object.sreq !== "object")
                        throw TypeError(".dcnet.pb.CheckPeerStatusRequest.sreq: object expected");
                    message.sreq = $root.dcnet.pb.CheckPeerStatusRequest.Sreq.fromObject(object.sreq);
                }
                if (object.teereport != null)
                    if (typeof object.teereport === "string")
                        $util.base64.decode(object.teereport, message.teereport = $util.newBuffer($util.base64.length(object.teereport)), 0);
                    else if (object.teereport.length >= 0)
                        message.teereport = object.teereport;
                return message;
            };

            /**
             * Creates a plain object from a CheckPeerStatusRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @static
             * @param {dcnet.pb.CheckPeerStatusRequest} message CheckPeerStatusRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CheckPeerStatusRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.sreq != null && message.hasOwnProperty("sreq")) {
                    object.sreq = $root.dcnet.pb.CheckPeerStatusRequest.Sreq.toObject(message.sreq, options);
                    if (options.oneofs)
                        object.payload = "sreq";
                }
                if (message.teereport != null && message.hasOwnProperty("teereport")) {
                    object.teereport = options.bytes === String ? $util.base64.encode(message.teereport, 0, message.teereport.length) : options.bytes === Array ? Array.prototype.slice.call(message.teereport) : message.teereport;
                    if (options.oneofs)
                        object.payload = "teereport";
                }
                return object;
            };

            /**
             * Converts this CheckPeerStatusRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CheckPeerStatusRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CheckPeerStatusRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.CheckPeerStatusRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CheckPeerStatusRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.CheckPeerStatusRequest";
            };

            CheckPeerStatusRequest.Sreq = (function() {

                /**
                 * Properties of a Sreq.
                 * @memberof dcnet.pb.CheckPeerStatusRequest
                 * @interface ISreq
                 * @property {Uint8Array|null} [pubkey] Sreq pubkey
                 * @property {Uint8Array|null} [peerid] Sreq peerid
                 */

                /**
                 * Constructs a new Sreq.
                 * @memberof dcnet.pb.CheckPeerStatusRequest
                 * @classdesc Represents a Sreq.
                 * @implements ISreq
                 * @constructor
                 * @param {dcnet.pb.CheckPeerStatusRequest.ISreq=} [properties] Properties to set
                 */
                function Sreq(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Sreq pubkey.
                 * @member {Uint8Array} pubkey
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @instance
                 */
                Sreq.prototype.pubkey = $util.newBuffer([]);

                /**
                 * Sreq peerid.
                 * @member {Uint8Array} peerid
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @instance
                 */
                Sreq.prototype.peerid = $util.newBuffer([]);

                /**
                 * Creates a new Sreq instance using the specified properties.
                 * @function create
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @static
                 * @param {dcnet.pb.CheckPeerStatusRequest.ISreq=} [properties] Properties to set
                 * @returns {dcnet.pb.CheckPeerStatusRequest.Sreq} Sreq instance
                 */
                Sreq.create = function create(properties) {
                    return new Sreq(properties);
                };

                /**
                 * Encodes the specified Sreq message. Does not implicitly {@link dcnet.pb.CheckPeerStatusRequest.Sreq.verify|verify} messages.
                 * @function encode
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @static
                 * @param {dcnet.pb.CheckPeerStatusRequest.ISreq} message Sreq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Sreq.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pubkey != null && Object.hasOwnProperty.call(message, "pubkey"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pubkey);
                    if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.peerid);
                    return writer;
                };

                /**
                 * Encodes the specified Sreq message, length delimited. Does not implicitly {@link dcnet.pb.CheckPeerStatusRequest.Sreq.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @static
                 * @param {dcnet.pb.CheckPeerStatusRequest.ISreq} message Sreq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Sreq.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Sreq message from the specified reader or buffer.
                 * @function decode
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dcnet.pb.CheckPeerStatusRequest.Sreq} Sreq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Sreq.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.CheckPeerStatusRequest.Sreq();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.pubkey = reader.bytes();
                                break;
                            }
                        case 2: {
                                message.peerid = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Sreq message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dcnet.pb.CheckPeerStatusRequest.Sreq} Sreq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Sreq.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Sreq message.
                 * @function verify
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Sreq.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                        if (!(message.pubkey && typeof message.pubkey.length === "number" || $util.isString(message.pubkey)))
                            return "pubkey: buffer expected";
                    if (message.peerid != null && message.hasOwnProperty("peerid"))
                        if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                            return "peerid: buffer expected";
                    return null;
                };

                /**
                 * Creates a Sreq message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dcnet.pb.CheckPeerStatusRequest.Sreq} Sreq
                 */
                Sreq.fromObject = function fromObject(object) {
                    if (object instanceof $root.dcnet.pb.CheckPeerStatusRequest.Sreq)
                        return object;
                    let message = new $root.dcnet.pb.CheckPeerStatusRequest.Sreq();
                    if (object.pubkey != null)
                        if (typeof object.pubkey === "string")
                            $util.base64.decode(object.pubkey, message.pubkey = $util.newBuffer($util.base64.length(object.pubkey)), 0);
                        else if (object.pubkey.length >= 0)
                            message.pubkey = object.pubkey;
                    if (object.peerid != null)
                        if (typeof object.peerid === "string")
                            $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                        else if (object.peerid.length >= 0)
                            message.peerid = object.peerid;
                    return message;
                };

                /**
                 * Creates a plain object from a Sreq message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @static
                 * @param {dcnet.pb.CheckPeerStatusRequest.Sreq} message Sreq
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Sreq.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.pubkey = "";
                        else {
                            object.pubkey = [];
                            if (options.bytes !== Array)
                                object.pubkey = $util.newBuffer(object.pubkey);
                        }
                        if (options.bytes === String)
                            object.peerid = "";
                        else {
                            object.peerid = [];
                            if (options.bytes !== Array)
                                object.peerid = $util.newBuffer(object.peerid);
                        }
                    }
                    if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                        object.pubkey = options.bytes === String ? $util.base64.encode(message.pubkey, 0, message.pubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubkey) : message.pubkey;
                    if (message.peerid != null && message.hasOwnProperty("peerid"))
                        object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                    return object;
                };

                /**
                 * Converts this Sreq to JSON.
                 * @function toJSON
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Sreq.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Sreq
                 * @function getTypeUrl
                 * @memberof dcnet.pb.CheckPeerStatusRequest.Sreq
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Sreq.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/dcnet.pb.CheckPeerStatusRequest.Sreq";
                };

                return Sreq;
            })();

            return CheckPeerStatusRequest;
        })();

        pb.CheckPeerStatusReply = (function() {

            /**
             * Properties of a CheckPeerStatusReply.
             * @memberof dcnet.pb
             * @interface ICheckPeerStatusReply
             * @property {Uint8Array|null} [challenge] CheckPeerStatusReply challenge
             * @property {dcnet.pb.CheckPeerStatusReply.IBody|null} [body] CheckPeerStatusReply body
             */

            /**
             * Constructs a new CheckPeerStatusReply.
             * @memberof dcnet.pb
             * @classdesc Represents a CheckPeerStatusReply.
             * @implements ICheckPeerStatusReply
             * @constructor
             * @param {dcnet.pb.ICheckPeerStatusReply=} [properties] Properties to set
             */
            function CheckPeerStatusReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CheckPeerStatusReply challenge.
             * @member {Uint8Array|null|undefined} challenge
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @instance
             */
            CheckPeerStatusReply.prototype.challenge = null;

            /**
             * CheckPeerStatusReply body.
             * @member {dcnet.pb.CheckPeerStatusReply.IBody|null|undefined} body
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @instance
             */
            CheckPeerStatusReply.prototype.body = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * CheckPeerStatusReply payload.
             * @member {"challenge"|"body"|undefined} payload
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @instance
             */
            Object.defineProperty(CheckPeerStatusReply.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["challenge", "body"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new CheckPeerStatusReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @static
             * @param {dcnet.pb.ICheckPeerStatusReply=} [properties] Properties to set
             * @returns {dcnet.pb.CheckPeerStatusReply} CheckPeerStatusReply instance
             */
            CheckPeerStatusReply.create = function create(properties) {
                return new CheckPeerStatusReply(properties);
            };

            /**
             * Encodes the specified CheckPeerStatusReply message. Does not implicitly {@link dcnet.pb.CheckPeerStatusReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @static
             * @param {dcnet.pb.ICheckPeerStatusReply} message CheckPeerStatusReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckPeerStatusReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.challenge != null && Object.hasOwnProperty.call(message, "challenge"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.challenge);
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    $root.dcnet.pb.CheckPeerStatusReply.Body.encode(message.body, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CheckPeerStatusReply message, length delimited. Does not implicitly {@link dcnet.pb.CheckPeerStatusReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @static
             * @param {dcnet.pb.ICheckPeerStatusReply} message CheckPeerStatusReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckPeerStatusReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CheckPeerStatusReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.CheckPeerStatusReply} CheckPeerStatusReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckPeerStatusReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.CheckPeerStatusReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.challenge = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.body = $root.dcnet.pb.CheckPeerStatusReply.Body.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CheckPeerStatusReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.CheckPeerStatusReply} CheckPeerStatusReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckPeerStatusReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CheckPeerStatusReply message.
             * @function verify
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CheckPeerStatusReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.challenge != null && message.hasOwnProperty("challenge")) {
                    properties.payload = 1;
                    if (!(message.challenge && typeof message.challenge.length === "number" || $util.isString(message.challenge)))
                        return "challenge: buffer expected";
                }
                if (message.body != null && message.hasOwnProperty("body")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        let error = $root.dcnet.pb.CheckPeerStatusReply.Body.verify(message.body);
                        if (error)
                            return "body." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a CheckPeerStatusReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.CheckPeerStatusReply} CheckPeerStatusReply
             */
            CheckPeerStatusReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.CheckPeerStatusReply)
                    return object;
                let message = new $root.dcnet.pb.CheckPeerStatusReply();
                if (object.challenge != null)
                    if (typeof object.challenge === "string")
                        $util.base64.decode(object.challenge, message.challenge = $util.newBuffer($util.base64.length(object.challenge)), 0);
                    else if (object.challenge.length >= 0)
                        message.challenge = object.challenge;
                if (object.body != null) {
                    if (typeof object.body !== "object")
                        throw TypeError(".dcnet.pb.CheckPeerStatusReply.body: object expected");
                    message.body = $root.dcnet.pb.CheckPeerStatusReply.Body.fromObject(object.body);
                }
                return message;
            };

            /**
             * Creates a plain object from a CheckPeerStatusReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @static
             * @param {dcnet.pb.CheckPeerStatusReply} message CheckPeerStatusReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CheckPeerStatusReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.challenge != null && message.hasOwnProperty("challenge")) {
                    object.challenge = options.bytes === String ? $util.base64.encode(message.challenge, 0, message.challenge.length) : options.bytes === Array ? Array.prototype.slice.call(message.challenge) : message.challenge;
                    if (options.oneofs)
                        object.payload = "challenge";
                }
                if (message.body != null && message.hasOwnProperty("body")) {
                    object.body = $root.dcnet.pb.CheckPeerStatusReply.Body.toObject(message.body, options);
                    if (options.oneofs)
                        object.payload = "body";
                }
                return object;
            };

            /**
             * Converts this CheckPeerStatusReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CheckPeerStatusReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CheckPeerStatusReply
             * @function getTypeUrl
             * @memberof dcnet.pb.CheckPeerStatusReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CheckPeerStatusReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.CheckPeerStatusReply";
            };

            CheckPeerStatusReply.Body = (function() {

                /**
                 * Properties of a Body.
                 * @memberof dcnet.pb.CheckPeerStatusReply
                 * @interface IBody
                 * @property {Uint8Array|null} [peerid] Body peerid
                 * @property {number|null} [status] Body status
                 * @property {Uint8Array|null} [teereport] Body teereport
                 */

                /**
                 * Constructs a new Body.
                 * @memberof dcnet.pb.CheckPeerStatusReply
                 * @classdesc Represents a Body.
                 * @implements IBody
                 * @constructor
                 * @param {dcnet.pb.CheckPeerStatusReply.IBody=} [properties] Properties to set
                 */
                function Body(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Body peerid.
                 * @member {Uint8Array} peerid
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @instance
                 */
                Body.prototype.peerid = $util.newBuffer([]);

                /**
                 * Body status.
                 * @member {number} status
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @instance
                 */
                Body.prototype.status = 0;

                /**
                 * Body teereport.
                 * @member {Uint8Array} teereport
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @instance
                 */
                Body.prototype.teereport = $util.newBuffer([]);

                /**
                 * Creates a new Body instance using the specified properties.
                 * @function create
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @static
                 * @param {dcnet.pb.CheckPeerStatusReply.IBody=} [properties] Properties to set
                 * @returns {dcnet.pb.CheckPeerStatusReply.Body} Body instance
                 */
                Body.create = function create(properties) {
                    return new Body(properties);
                };

                /**
                 * Encodes the specified Body message. Does not implicitly {@link dcnet.pb.CheckPeerStatusReply.Body.verify|verify} messages.
                 * @function encode
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @static
                 * @param {dcnet.pb.CheckPeerStatusReply.IBody} message Body message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Body.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.peerid);
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                    if (message.teereport != null && Object.hasOwnProperty.call(message, "teereport"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.teereport);
                    return writer;
                };

                /**
                 * Encodes the specified Body message, length delimited. Does not implicitly {@link dcnet.pb.CheckPeerStatusReply.Body.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @static
                 * @param {dcnet.pb.CheckPeerStatusReply.IBody} message Body message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Body.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Body message from the specified reader or buffer.
                 * @function decode
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dcnet.pb.CheckPeerStatusReply.Body} Body
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Body.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.CheckPeerStatusReply.Body();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.peerid = reader.bytes();
                                break;
                            }
                        case 2: {
                                message.status = reader.int32();
                                break;
                            }
                        case 3: {
                                message.teereport = reader.bytes();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Body message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dcnet.pb.CheckPeerStatusReply.Body} Body
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Body.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Body message.
                 * @function verify
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Body.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.peerid != null && message.hasOwnProperty("peerid"))
                        if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                            return "peerid: buffer expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        if (!$util.isInteger(message.status))
                            return "status: integer expected";
                    if (message.teereport != null && message.hasOwnProperty("teereport"))
                        if (!(message.teereport && typeof message.teereport.length === "number" || $util.isString(message.teereport)))
                            return "teereport: buffer expected";
                    return null;
                };

                /**
                 * Creates a Body message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dcnet.pb.CheckPeerStatusReply.Body} Body
                 */
                Body.fromObject = function fromObject(object) {
                    if (object instanceof $root.dcnet.pb.CheckPeerStatusReply.Body)
                        return object;
                    let message = new $root.dcnet.pb.CheckPeerStatusReply.Body();
                    if (object.peerid != null)
                        if (typeof object.peerid === "string")
                            $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                        else if (object.peerid.length >= 0)
                            message.peerid = object.peerid;
                    if (object.status != null)
                        message.status = object.status | 0;
                    if (object.teereport != null)
                        if (typeof object.teereport === "string")
                            $util.base64.decode(object.teereport, message.teereport = $util.newBuffer($util.base64.length(object.teereport)), 0);
                        else if (object.teereport.length >= 0)
                            message.teereport = object.teereport;
                    return message;
                };

                /**
                 * Creates a plain object from a Body message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @static
                 * @param {dcnet.pb.CheckPeerStatusReply.Body} message Body
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Body.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.peerid = "";
                        else {
                            object.peerid = [];
                            if (options.bytes !== Array)
                                object.peerid = $util.newBuffer(object.peerid);
                        }
                        object.status = 0;
                        if (options.bytes === String)
                            object.teereport = "";
                        else {
                            object.teereport = [];
                            if (options.bytes !== Array)
                                object.teereport = $util.newBuffer(object.teereport);
                        }
                    }
                    if (message.peerid != null && message.hasOwnProperty("peerid"))
                        object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = message.status;
                    if (message.teereport != null && message.hasOwnProperty("teereport"))
                        object.teereport = options.bytes === String ? $util.base64.encode(message.teereport, 0, message.teereport.length) : options.bytes === Array ? Array.prototype.slice.call(message.teereport) : message.teereport;
                    return object;
                };

                /**
                 * Converts this Body to JSON.
                 * @function toJSON
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Body.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Body
                 * @function getTypeUrl
                 * @memberof dcnet.pb.CheckPeerStatusReply.Body
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Body.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/dcnet.pb.CheckPeerStatusReply.Body";
                };

                return Body;
            })();

            return CheckPeerStatusReply;
        })();

        pb.LocalFileCheckRequest = (function() {

            /**
             * Properties of a LocalFileCheckRequest.
             * @memberof dcnet.pb
             * @interface ILocalFileCheckRequest
             * @property {Array.<string>|null} [keys] LocalFileCheckRequest keys
             */

            /**
             * Constructs a new LocalFileCheckRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a LocalFileCheckRequest.
             * @implements ILocalFileCheckRequest
             * @constructor
             * @param {dcnet.pb.ILocalFileCheckRequest=} [properties] Properties to set
             */
            function LocalFileCheckRequest(properties) {
                this.keys = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocalFileCheckRequest keys.
             * @member {Array.<string>} keys
             * @memberof dcnet.pb.LocalFileCheckRequest
             * @instance
             */
            LocalFileCheckRequest.prototype.keys = $util.emptyArray;

            /**
             * Creates a new LocalFileCheckRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.LocalFileCheckRequest
             * @static
             * @param {dcnet.pb.ILocalFileCheckRequest=} [properties] Properties to set
             * @returns {dcnet.pb.LocalFileCheckRequest} LocalFileCheckRequest instance
             */
            LocalFileCheckRequest.create = function create(properties) {
                return new LocalFileCheckRequest(properties);
            };

            /**
             * Encodes the specified LocalFileCheckRequest message. Does not implicitly {@link dcnet.pb.LocalFileCheckRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.LocalFileCheckRequest
             * @static
             * @param {dcnet.pb.ILocalFileCheckRequest} message LocalFileCheckRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalFileCheckRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keys != null && message.keys.length)
                    for (let i = 0; i < message.keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.keys[i]);
                return writer;
            };

            /**
             * Encodes the specified LocalFileCheckRequest message, length delimited. Does not implicitly {@link dcnet.pb.LocalFileCheckRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.LocalFileCheckRequest
             * @static
             * @param {dcnet.pb.ILocalFileCheckRequest} message LocalFileCheckRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalFileCheckRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocalFileCheckRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.LocalFileCheckRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.LocalFileCheckRequest} LocalFileCheckRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalFileCheckRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.LocalFileCheckRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.keys && message.keys.length))
                                message.keys = [];
                            message.keys.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocalFileCheckRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.LocalFileCheckRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.LocalFileCheckRequest} LocalFileCheckRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalFileCheckRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocalFileCheckRequest message.
             * @function verify
             * @memberof dcnet.pb.LocalFileCheckRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocalFileCheckRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keys != null && message.hasOwnProperty("keys")) {
                    if (!Array.isArray(message.keys))
                        return "keys: array expected";
                    for (let i = 0; i < message.keys.length; ++i)
                        if (!$util.isString(message.keys[i]))
                            return "keys: string[] expected";
                }
                return null;
            };

            /**
             * Creates a LocalFileCheckRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.LocalFileCheckRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.LocalFileCheckRequest} LocalFileCheckRequest
             */
            LocalFileCheckRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.LocalFileCheckRequest)
                    return object;
                let message = new $root.dcnet.pb.LocalFileCheckRequest();
                if (object.keys) {
                    if (!Array.isArray(object.keys))
                        throw TypeError(".dcnet.pb.LocalFileCheckRequest.keys: array expected");
                    message.keys = [];
                    for (let i = 0; i < object.keys.length; ++i)
                        message.keys[i] = String(object.keys[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a LocalFileCheckRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.LocalFileCheckRequest
             * @static
             * @param {dcnet.pb.LocalFileCheckRequest} message LocalFileCheckRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocalFileCheckRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.keys = [];
                if (message.keys && message.keys.length) {
                    object.keys = [];
                    for (let j = 0; j < message.keys.length; ++j)
                        object.keys[j] = message.keys[j];
                }
                return object;
            };

            /**
             * Converts this LocalFileCheckRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.LocalFileCheckRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocalFileCheckRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LocalFileCheckRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.LocalFileCheckRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LocalFileCheckRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.LocalFileCheckRequest";
            };

            return LocalFileCheckRequest;
        })();

        pb.LocalFileCheckReply = (function() {

            /**
             * Properties of a LocalFileCheckReply.
             * @memberof dcnet.pb
             * @interface ILocalFileCheckReply
             * @property {number|null} [flag] LocalFileCheckReply flag
             * @property {string|null} [failkey] LocalFileCheckReply failkey
             * @property {Uint8Array|null} [teereport] LocalFileCheckReply teereport
             */

            /**
             * Constructs a new LocalFileCheckReply.
             * @memberof dcnet.pb
             * @classdesc Represents a LocalFileCheckReply.
             * @implements ILocalFileCheckReply
             * @constructor
             * @param {dcnet.pb.ILocalFileCheckReply=} [properties] Properties to set
             */
            function LocalFileCheckReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocalFileCheckReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.LocalFileCheckReply
             * @instance
             */
            LocalFileCheckReply.prototype.flag = 0;

            /**
             * LocalFileCheckReply failkey.
             * @member {string} failkey
             * @memberof dcnet.pb.LocalFileCheckReply
             * @instance
             */
            LocalFileCheckReply.prototype.failkey = "";

            /**
             * LocalFileCheckReply teereport.
             * @member {Uint8Array} teereport
             * @memberof dcnet.pb.LocalFileCheckReply
             * @instance
             */
            LocalFileCheckReply.prototype.teereport = $util.newBuffer([]);

            /**
             * Creates a new LocalFileCheckReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.LocalFileCheckReply
             * @static
             * @param {dcnet.pb.ILocalFileCheckReply=} [properties] Properties to set
             * @returns {dcnet.pb.LocalFileCheckReply} LocalFileCheckReply instance
             */
            LocalFileCheckReply.create = function create(properties) {
                return new LocalFileCheckReply(properties);
            };

            /**
             * Encodes the specified LocalFileCheckReply message. Does not implicitly {@link dcnet.pb.LocalFileCheckReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.LocalFileCheckReply
             * @static
             * @param {dcnet.pb.ILocalFileCheckReply} message LocalFileCheckReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalFileCheckReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.flag);
                if (message.failkey != null && Object.hasOwnProperty.call(message, "failkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.failkey);
                if (message.teereport != null && Object.hasOwnProperty.call(message, "teereport"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.teereport);
                return writer;
            };

            /**
             * Encodes the specified LocalFileCheckReply message, length delimited. Does not implicitly {@link dcnet.pb.LocalFileCheckReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.LocalFileCheckReply
             * @static
             * @param {dcnet.pb.ILocalFileCheckReply} message LocalFileCheckReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalFileCheckReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocalFileCheckReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.LocalFileCheckReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.LocalFileCheckReply} LocalFileCheckReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalFileCheckReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.LocalFileCheckReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.int32();
                            break;
                        }
                    case 2: {
                            message.failkey = reader.string();
                            break;
                        }
                    case 3: {
                            message.teereport = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocalFileCheckReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.LocalFileCheckReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.LocalFileCheckReply} LocalFileCheckReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalFileCheckReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocalFileCheckReply message.
             * @function verify
             * @memberof dcnet.pb.LocalFileCheckReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocalFileCheckReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.failkey != null && message.hasOwnProperty("failkey"))
                    if (!$util.isString(message.failkey))
                        return "failkey: string expected";
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    if (!(message.teereport && typeof message.teereport.length === "number" || $util.isString(message.teereport)))
                        return "teereport: buffer expected";
                return null;
            };

            /**
             * Creates a LocalFileCheckReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.LocalFileCheckReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.LocalFileCheckReply} LocalFileCheckReply
             */
            LocalFileCheckReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.LocalFileCheckReply)
                    return object;
                let message = new $root.dcnet.pb.LocalFileCheckReply();
                if (object.flag != null)
                    message.flag = object.flag | 0;
                if (object.failkey != null)
                    message.failkey = String(object.failkey);
                if (object.teereport != null)
                    if (typeof object.teereport === "string")
                        $util.base64.decode(object.teereport, message.teereport = $util.newBuffer($util.base64.length(object.teereport)), 0);
                    else if (object.teereport.length >= 0)
                        message.teereport = object.teereport;
                return message;
            };

            /**
             * Creates a plain object from a LocalFileCheckReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.LocalFileCheckReply
             * @static
             * @param {dcnet.pb.LocalFileCheckReply} message LocalFileCheckReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocalFileCheckReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    object.failkey = "";
                    if (options.bytes === String)
                        object.teereport = "";
                    else {
                        object.teereport = [];
                        if (options.bytes !== Array)
                            object.teereport = $util.newBuffer(object.teereport);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.failkey != null && message.hasOwnProperty("failkey"))
                    object.failkey = message.failkey;
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    object.teereport = options.bytes === String ? $util.base64.encode(message.teereport, 0, message.teereport.length) : options.bytes === Array ? Array.prototype.slice.call(message.teereport) : message.teereport;
                return object;
            };

            /**
             * Converts this LocalFileCheckReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.LocalFileCheckReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocalFileCheckReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LocalFileCheckReply
             * @function getTypeUrl
             * @memberof dcnet.pb.LocalFileCheckReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LocalFileCheckReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.LocalFileCheckReply";
            };

            return LocalFileCheckReply;
        })();

        pb.LocalAccountInfoCheckRequest = (function() {

            /**
             * Properties of a LocalAccountInfoCheckRequest.
             * @memberof dcnet.pb
             * @interface ILocalAccountInfoCheckRequest
             * @property {Array.<Uint8Array>|null} [accounthashs] LocalAccountInfoCheckRequest accounthashs
             */

            /**
             * Constructs a new LocalAccountInfoCheckRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a LocalAccountInfoCheckRequest.
             * @implements ILocalAccountInfoCheckRequest
             * @constructor
             * @param {dcnet.pb.ILocalAccountInfoCheckRequest=} [properties] Properties to set
             */
            function LocalAccountInfoCheckRequest(properties) {
                this.accounthashs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocalAccountInfoCheckRequest accounthashs.
             * @member {Array.<Uint8Array>} accounthashs
             * @memberof dcnet.pb.LocalAccountInfoCheckRequest
             * @instance
             */
            LocalAccountInfoCheckRequest.prototype.accounthashs = $util.emptyArray;

            /**
             * Creates a new LocalAccountInfoCheckRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.LocalAccountInfoCheckRequest
             * @static
             * @param {dcnet.pb.ILocalAccountInfoCheckRequest=} [properties] Properties to set
             * @returns {dcnet.pb.LocalAccountInfoCheckRequest} LocalAccountInfoCheckRequest instance
             */
            LocalAccountInfoCheckRequest.create = function create(properties) {
                return new LocalAccountInfoCheckRequest(properties);
            };

            /**
             * Encodes the specified LocalAccountInfoCheckRequest message. Does not implicitly {@link dcnet.pb.LocalAccountInfoCheckRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.LocalAccountInfoCheckRequest
             * @static
             * @param {dcnet.pb.ILocalAccountInfoCheckRequest} message LocalAccountInfoCheckRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalAccountInfoCheckRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accounthashs != null && message.accounthashs.length)
                    for (let i = 0; i < message.accounthashs.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accounthashs[i]);
                return writer;
            };

            /**
             * Encodes the specified LocalAccountInfoCheckRequest message, length delimited. Does not implicitly {@link dcnet.pb.LocalAccountInfoCheckRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.LocalAccountInfoCheckRequest
             * @static
             * @param {dcnet.pb.ILocalAccountInfoCheckRequest} message LocalAccountInfoCheckRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalAccountInfoCheckRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocalAccountInfoCheckRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.LocalAccountInfoCheckRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.LocalAccountInfoCheckRequest} LocalAccountInfoCheckRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalAccountInfoCheckRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.LocalAccountInfoCheckRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.accounthashs && message.accounthashs.length))
                                message.accounthashs = [];
                            message.accounthashs.push(reader.bytes());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocalAccountInfoCheckRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.LocalAccountInfoCheckRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.LocalAccountInfoCheckRequest} LocalAccountInfoCheckRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalAccountInfoCheckRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocalAccountInfoCheckRequest message.
             * @function verify
             * @memberof dcnet.pb.LocalAccountInfoCheckRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocalAccountInfoCheckRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accounthashs != null && message.hasOwnProperty("accounthashs")) {
                    if (!Array.isArray(message.accounthashs))
                        return "accounthashs: array expected";
                    for (let i = 0; i < message.accounthashs.length; ++i)
                        if (!(message.accounthashs[i] && typeof message.accounthashs[i].length === "number" || $util.isString(message.accounthashs[i])))
                            return "accounthashs: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates a LocalAccountInfoCheckRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.LocalAccountInfoCheckRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.LocalAccountInfoCheckRequest} LocalAccountInfoCheckRequest
             */
            LocalAccountInfoCheckRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.LocalAccountInfoCheckRequest)
                    return object;
                let message = new $root.dcnet.pb.LocalAccountInfoCheckRequest();
                if (object.accounthashs) {
                    if (!Array.isArray(object.accounthashs))
                        throw TypeError(".dcnet.pb.LocalAccountInfoCheckRequest.accounthashs: array expected");
                    message.accounthashs = [];
                    for (let i = 0; i < object.accounthashs.length; ++i)
                        if (typeof object.accounthashs[i] === "string")
                            $util.base64.decode(object.accounthashs[i], message.accounthashs[i] = $util.newBuffer($util.base64.length(object.accounthashs[i])), 0);
                        else if (object.accounthashs[i].length >= 0)
                            message.accounthashs[i] = object.accounthashs[i];
                }
                return message;
            };

            /**
             * Creates a plain object from a LocalAccountInfoCheckRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.LocalAccountInfoCheckRequest
             * @static
             * @param {dcnet.pb.LocalAccountInfoCheckRequest} message LocalAccountInfoCheckRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocalAccountInfoCheckRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.accounthashs = [];
                if (message.accounthashs && message.accounthashs.length) {
                    object.accounthashs = [];
                    for (let j = 0; j < message.accounthashs.length; ++j)
                        object.accounthashs[j] = options.bytes === String ? $util.base64.encode(message.accounthashs[j], 0, message.accounthashs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.accounthashs[j]) : message.accounthashs[j];
                }
                return object;
            };

            /**
             * Converts this LocalAccountInfoCheckRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.LocalAccountInfoCheckRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocalAccountInfoCheckRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LocalAccountInfoCheckRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.LocalAccountInfoCheckRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LocalAccountInfoCheckRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.LocalAccountInfoCheckRequest";
            };

            return LocalAccountInfoCheckRequest;
        })();

        pb.LocalAccountInfoCheckReply = (function() {

            /**
             * Properties of a LocalAccountInfoCheckReply.
             * @memberof dcnet.pb
             * @interface ILocalAccountInfoCheckReply
             * @property {number|null} [flag] LocalAccountInfoCheckReply flag
             * @property {Uint8Array|null} [failkey] LocalAccountInfoCheckReply failkey
             * @property {Uint8Array|null} [teereport] LocalAccountInfoCheckReply teereport
             */

            /**
             * Constructs a new LocalAccountInfoCheckReply.
             * @memberof dcnet.pb
             * @classdesc Represents a LocalAccountInfoCheckReply.
             * @implements ILocalAccountInfoCheckReply
             * @constructor
             * @param {dcnet.pb.ILocalAccountInfoCheckReply=} [properties] Properties to set
             */
            function LocalAccountInfoCheckReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocalAccountInfoCheckReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @instance
             */
            LocalAccountInfoCheckReply.prototype.flag = 0;

            /**
             * LocalAccountInfoCheckReply failkey.
             * @member {Uint8Array} failkey
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @instance
             */
            LocalAccountInfoCheckReply.prototype.failkey = $util.newBuffer([]);

            /**
             * LocalAccountInfoCheckReply teereport.
             * @member {Uint8Array} teereport
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @instance
             */
            LocalAccountInfoCheckReply.prototype.teereport = $util.newBuffer([]);

            /**
             * Creates a new LocalAccountInfoCheckReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @static
             * @param {dcnet.pb.ILocalAccountInfoCheckReply=} [properties] Properties to set
             * @returns {dcnet.pb.LocalAccountInfoCheckReply} LocalAccountInfoCheckReply instance
             */
            LocalAccountInfoCheckReply.create = function create(properties) {
                return new LocalAccountInfoCheckReply(properties);
            };

            /**
             * Encodes the specified LocalAccountInfoCheckReply message. Does not implicitly {@link dcnet.pb.LocalAccountInfoCheckReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @static
             * @param {dcnet.pb.ILocalAccountInfoCheckReply} message LocalAccountInfoCheckReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalAccountInfoCheckReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.flag);
                if (message.failkey != null && Object.hasOwnProperty.call(message, "failkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.failkey);
                if (message.teereport != null && Object.hasOwnProperty.call(message, "teereport"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.teereport);
                return writer;
            };

            /**
             * Encodes the specified LocalAccountInfoCheckReply message, length delimited. Does not implicitly {@link dcnet.pb.LocalAccountInfoCheckReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @static
             * @param {dcnet.pb.ILocalAccountInfoCheckReply} message LocalAccountInfoCheckReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalAccountInfoCheckReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocalAccountInfoCheckReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.LocalAccountInfoCheckReply} LocalAccountInfoCheckReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalAccountInfoCheckReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.LocalAccountInfoCheckReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.int32();
                            break;
                        }
                    case 2: {
                            message.failkey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.teereport = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocalAccountInfoCheckReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.LocalAccountInfoCheckReply} LocalAccountInfoCheckReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalAccountInfoCheckReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocalAccountInfoCheckReply message.
             * @function verify
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocalAccountInfoCheckReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.failkey != null && message.hasOwnProperty("failkey"))
                    if (!(message.failkey && typeof message.failkey.length === "number" || $util.isString(message.failkey)))
                        return "failkey: buffer expected";
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    if (!(message.teereport && typeof message.teereport.length === "number" || $util.isString(message.teereport)))
                        return "teereport: buffer expected";
                return null;
            };

            /**
             * Creates a LocalAccountInfoCheckReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.LocalAccountInfoCheckReply} LocalAccountInfoCheckReply
             */
            LocalAccountInfoCheckReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.LocalAccountInfoCheckReply)
                    return object;
                let message = new $root.dcnet.pb.LocalAccountInfoCheckReply();
                if (object.flag != null)
                    message.flag = object.flag | 0;
                if (object.failkey != null)
                    if (typeof object.failkey === "string")
                        $util.base64.decode(object.failkey, message.failkey = $util.newBuffer($util.base64.length(object.failkey)), 0);
                    else if (object.failkey.length >= 0)
                        message.failkey = object.failkey;
                if (object.teereport != null)
                    if (typeof object.teereport === "string")
                        $util.base64.decode(object.teereport, message.teereport = $util.newBuffer($util.base64.length(object.teereport)), 0);
                    else if (object.teereport.length >= 0)
                        message.teereport = object.teereport;
                return message;
            };

            /**
             * Creates a plain object from a LocalAccountInfoCheckReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @static
             * @param {dcnet.pb.LocalAccountInfoCheckReply} message LocalAccountInfoCheckReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocalAccountInfoCheckReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.failkey = "";
                    else {
                        object.failkey = [];
                        if (options.bytes !== Array)
                            object.failkey = $util.newBuffer(object.failkey);
                    }
                    if (options.bytes === String)
                        object.teereport = "";
                    else {
                        object.teereport = [];
                        if (options.bytes !== Array)
                            object.teereport = $util.newBuffer(object.teereport);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.failkey != null && message.hasOwnProperty("failkey"))
                    object.failkey = options.bytes === String ? $util.base64.encode(message.failkey, 0, message.failkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.failkey) : message.failkey;
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    object.teereport = options.bytes === String ? $util.base64.encode(message.teereport, 0, message.teereport.length) : options.bytes === Array ? Array.prototype.slice.call(message.teereport) : message.teereport;
                return object;
            };

            /**
             * Converts this LocalAccountInfoCheckReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocalAccountInfoCheckReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LocalAccountInfoCheckReply
             * @function getTypeUrl
             * @memberof dcnet.pb.LocalAccountInfoCheckReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LocalAccountInfoCheckReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.LocalAccountInfoCheckReply";
            };

            return LocalAccountInfoCheckReply;
        })();

        pb.AccountInfoSyncRequest = (function() {

            /**
             * Properties of an AccountInfoSyncRequest.
             * @memberof dcnet.pb
             * @interface IAccountInfoSyncRequest
             * @property {Uint8Array|null} [accounthash] AccountInfoSyncRequest accounthash
             * @property {number|null} [blockheight] AccountInfoSyncRequest blockheight
             * @property {Uint8Array|null} [prikeyencrypthash] AccountInfoSyncRequest prikeyencrypthash
             */

            /**
             * Constructs a new AccountInfoSyncRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AccountInfoSyncRequest.
             * @implements IAccountInfoSyncRequest
             * @constructor
             * @param {dcnet.pb.IAccountInfoSyncRequest=} [properties] Properties to set
             */
            function AccountInfoSyncRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AccountInfoSyncRequest accounthash.
             * @member {Uint8Array} accounthash
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @instance
             */
            AccountInfoSyncRequest.prototype.accounthash = $util.newBuffer([]);

            /**
             * AccountInfoSyncRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @instance
             */
            AccountInfoSyncRequest.prototype.blockheight = 0;

            /**
             * AccountInfoSyncRequest prikeyencrypthash.
             * @member {Uint8Array} prikeyencrypthash
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @instance
             */
            AccountInfoSyncRequest.prototype.prikeyencrypthash = $util.newBuffer([]);

            /**
             * Creates a new AccountInfoSyncRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @static
             * @param {dcnet.pb.IAccountInfoSyncRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AccountInfoSyncRequest} AccountInfoSyncRequest instance
             */
            AccountInfoSyncRequest.create = function create(properties) {
                return new AccountInfoSyncRequest(properties);
            };

            /**
             * Encodes the specified AccountInfoSyncRequest message. Does not implicitly {@link dcnet.pb.AccountInfoSyncRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @static
             * @param {dcnet.pb.IAccountInfoSyncRequest} message AccountInfoSyncRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountInfoSyncRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accounthash != null && Object.hasOwnProperty.call(message, "accounthash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accounthash);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.prikeyencrypthash != null && Object.hasOwnProperty.call(message, "prikeyencrypthash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.prikeyencrypthash);
                return writer;
            };

            /**
             * Encodes the specified AccountInfoSyncRequest message, length delimited. Does not implicitly {@link dcnet.pb.AccountInfoSyncRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @static
             * @param {dcnet.pb.IAccountInfoSyncRequest} message AccountInfoSyncRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountInfoSyncRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AccountInfoSyncRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AccountInfoSyncRequest} AccountInfoSyncRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountInfoSyncRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AccountInfoSyncRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accounthash = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.prikeyencrypthash = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AccountInfoSyncRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AccountInfoSyncRequest} AccountInfoSyncRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountInfoSyncRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AccountInfoSyncRequest message.
             * @function verify
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AccountInfoSyncRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accounthash != null && message.hasOwnProperty("accounthash"))
                    if (!(message.accounthash && typeof message.accounthash.length === "number" || $util.isString(message.accounthash)))
                        return "accounthash: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.prikeyencrypthash != null && message.hasOwnProperty("prikeyencrypthash"))
                    if (!(message.prikeyencrypthash && typeof message.prikeyencrypthash.length === "number" || $util.isString(message.prikeyencrypthash)))
                        return "prikeyencrypthash: buffer expected";
                return null;
            };

            /**
             * Creates an AccountInfoSyncRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AccountInfoSyncRequest} AccountInfoSyncRequest
             */
            AccountInfoSyncRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AccountInfoSyncRequest)
                    return object;
                let message = new $root.dcnet.pb.AccountInfoSyncRequest();
                if (object.accounthash != null)
                    if (typeof object.accounthash === "string")
                        $util.base64.decode(object.accounthash, message.accounthash = $util.newBuffer($util.base64.length(object.accounthash)), 0);
                    else if (object.accounthash.length >= 0)
                        message.accounthash = object.accounthash;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.prikeyencrypthash != null)
                    if (typeof object.prikeyencrypthash === "string")
                        $util.base64.decode(object.prikeyencrypthash, message.prikeyencrypthash = $util.newBuffer($util.base64.length(object.prikeyencrypthash)), 0);
                    else if (object.prikeyencrypthash.length >= 0)
                        message.prikeyencrypthash = object.prikeyencrypthash;
                return message;
            };

            /**
             * Creates a plain object from an AccountInfoSyncRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @static
             * @param {dcnet.pb.AccountInfoSyncRequest} message AccountInfoSyncRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AccountInfoSyncRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.accounthash = "";
                    else {
                        object.accounthash = [];
                        if (options.bytes !== Array)
                            object.accounthash = $util.newBuffer(object.accounthash);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.prikeyencrypthash = "";
                    else {
                        object.prikeyencrypthash = [];
                        if (options.bytes !== Array)
                            object.prikeyencrypthash = $util.newBuffer(object.prikeyencrypthash);
                    }
                }
                if (message.accounthash != null && message.hasOwnProperty("accounthash"))
                    object.accounthash = options.bytes === String ? $util.base64.encode(message.accounthash, 0, message.accounthash.length) : options.bytes === Array ? Array.prototype.slice.call(message.accounthash) : message.accounthash;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.prikeyencrypthash != null && message.hasOwnProperty("prikeyencrypthash"))
                    object.prikeyencrypthash = options.bytes === String ? $util.base64.encode(message.prikeyencrypthash, 0, message.prikeyencrypthash.length) : options.bytes === Array ? Array.prototype.slice.call(message.prikeyencrypthash) : message.prikeyencrypthash;
                return object;
            };

            /**
             * Converts this AccountInfoSyncRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AccountInfoSyncRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AccountInfoSyncRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AccountInfoSyncRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountInfoSyncRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AccountInfoSyncRequest";
            };

            return AccountInfoSyncRequest;
        })();

        pb.AccountInfoSyncReply = (function() {

            /**
             * Properties of an AccountInfoSyncReply.
             * @memberof dcnet.pb
             * @interface IAccountInfoSyncReply
             */

            /**
             * Constructs a new AccountInfoSyncReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AccountInfoSyncReply.
             * @implements IAccountInfoSyncReply
             * @constructor
             * @param {dcnet.pb.IAccountInfoSyncReply=} [properties] Properties to set
             */
            function AccountInfoSyncReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AccountInfoSyncReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AccountInfoSyncReply
             * @static
             * @param {dcnet.pb.IAccountInfoSyncReply=} [properties] Properties to set
             * @returns {dcnet.pb.AccountInfoSyncReply} AccountInfoSyncReply instance
             */
            AccountInfoSyncReply.create = function create(properties) {
                return new AccountInfoSyncReply(properties);
            };

            /**
             * Encodes the specified AccountInfoSyncReply message. Does not implicitly {@link dcnet.pb.AccountInfoSyncReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AccountInfoSyncReply
             * @static
             * @param {dcnet.pb.IAccountInfoSyncReply} message AccountInfoSyncReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountInfoSyncReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AccountInfoSyncReply message, length delimited. Does not implicitly {@link dcnet.pb.AccountInfoSyncReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AccountInfoSyncReply
             * @static
             * @param {dcnet.pb.IAccountInfoSyncReply} message AccountInfoSyncReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountInfoSyncReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AccountInfoSyncReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AccountInfoSyncReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AccountInfoSyncReply} AccountInfoSyncReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountInfoSyncReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AccountInfoSyncReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AccountInfoSyncReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AccountInfoSyncReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AccountInfoSyncReply} AccountInfoSyncReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountInfoSyncReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AccountInfoSyncReply message.
             * @function verify
             * @memberof dcnet.pb.AccountInfoSyncReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AccountInfoSyncReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AccountInfoSyncReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AccountInfoSyncReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AccountInfoSyncReply} AccountInfoSyncReply
             */
            AccountInfoSyncReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AccountInfoSyncReply)
                    return object;
                return new $root.dcnet.pb.AccountInfoSyncReply();
            };

            /**
             * Creates a plain object from an AccountInfoSyncReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AccountInfoSyncReply
             * @static
             * @param {dcnet.pb.AccountInfoSyncReply} message AccountInfoSyncReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AccountInfoSyncReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AccountInfoSyncReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AccountInfoSyncReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AccountInfoSyncReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AccountInfoSyncReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AccountInfoSyncReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountInfoSyncReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AccountInfoSyncReply";
            };

            return AccountInfoSyncReply;
        })();

        pb.SetEncryptKeyWithScanRequest = (function() {

            /**
             * Properties of a SetEncryptKeyWithScanRequest.
             * @memberof dcnet.pb
             * @interface ISetEncryptKeyWithScanRequest
             * @property {Uint8Array|null} [encryptPrivkey] SetEncryptKeyWithScanRequest encryptPrivkey
             * @property {Uint8Array|null} [mapkey] SetEncryptKeyWithScanRequest mapkey
             */

            /**
             * Constructs a new SetEncryptKeyWithScanRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a SetEncryptKeyWithScanRequest.
             * @implements ISetEncryptKeyWithScanRequest
             * @constructor
             * @param {dcnet.pb.ISetEncryptKeyWithScanRequest=} [properties] Properties to set
             */
            function SetEncryptKeyWithScanRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetEncryptKeyWithScanRequest encryptPrivkey.
             * @member {Uint8Array} encryptPrivkey
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @instance
             */
            SetEncryptKeyWithScanRequest.prototype.encryptPrivkey = $util.newBuffer([]);

            /**
             * SetEncryptKeyWithScanRequest mapkey.
             * @member {Uint8Array} mapkey
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @instance
             */
            SetEncryptKeyWithScanRequest.prototype.mapkey = $util.newBuffer([]);

            /**
             * Creates a new SetEncryptKeyWithScanRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @static
             * @param {dcnet.pb.ISetEncryptKeyWithScanRequest=} [properties] Properties to set
             * @returns {dcnet.pb.SetEncryptKeyWithScanRequest} SetEncryptKeyWithScanRequest instance
             */
            SetEncryptKeyWithScanRequest.create = function create(properties) {
                return new SetEncryptKeyWithScanRequest(properties);
            };

            /**
             * Encodes the specified SetEncryptKeyWithScanRequest message. Does not implicitly {@link dcnet.pb.SetEncryptKeyWithScanRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @static
             * @param {dcnet.pb.ISetEncryptKeyWithScanRequest} message SetEncryptKeyWithScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEncryptKeyWithScanRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.encryptPrivkey != null && Object.hasOwnProperty.call(message, "encryptPrivkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptPrivkey);
                if (message.mapkey != null && Object.hasOwnProperty.call(message, "mapkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.mapkey);
                return writer;
            };

            /**
             * Encodes the specified SetEncryptKeyWithScanRequest message, length delimited. Does not implicitly {@link dcnet.pb.SetEncryptKeyWithScanRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @static
             * @param {dcnet.pb.ISetEncryptKeyWithScanRequest} message SetEncryptKeyWithScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEncryptKeyWithScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetEncryptKeyWithScanRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SetEncryptKeyWithScanRequest} SetEncryptKeyWithScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEncryptKeyWithScanRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SetEncryptKeyWithScanRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.encryptPrivkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.mapkey = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetEncryptKeyWithScanRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SetEncryptKeyWithScanRequest} SetEncryptKeyWithScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEncryptKeyWithScanRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetEncryptKeyWithScanRequest message.
             * @function verify
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetEncryptKeyWithScanRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.encryptPrivkey != null && message.hasOwnProperty("encryptPrivkey"))
                    if (!(message.encryptPrivkey && typeof message.encryptPrivkey.length === "number" || $util.isString(message.encryptPrivkey)))
                        return "encryptPrivkey: buffer expected";
                if (message.mapkey != null && message.hasOwnProperty("mapkey"))
                    if (!(message.mapkey && typeof message.mapkey.length === "number" || $util.isString(message.mapkey)))
                        return "mapkey: buffer expected";
                return null;
            };

            /**
             * Creates a SetEncryptKeyWithScanRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SetEncryptKeyWithScanRequest} SetEncryptKeyWithScanRequest
             */
            SetEncryptKeyWithScanRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SetEncryptKeyWithScanRequest)
                    return object;
                let message = new $root.dcnet.pb.SetEncryptKeyWithScanRequest();
                if (object.encryptPrivkey != null)
                    if (typeof object.encryptPrivkey === "string")
                        $util.base64.decode(object.encryptPrivkey, message.encryptPrivkey = $util.newBuffer($util.base64.length(object.encryptPrivkey)), 0);
                    else if (object.encryptPrivkey.length >= 0)
                        message.encryptPrivkey = object.encryptPrivkey;
                if (object.mapkey != null)
                    if (typeof object.mapkey === "string")
                        $util.base64.decode(object.mapkey, message.mapkey = $util.newBuffer($util.base64.length(object.mapkey)), 0);
                    else if (object.mapkey.length >= 0)
                        message.mapkey = object.mapkey;
                return message;
            };

            /**
             * Creates a plain object from a SetEncryptKeyWithScanRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @static
             * @param {dcnet.pb.SetEncryptKeyWithScanRequest} message SetEncryptKeyWithScanRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetEncryptKeyWithScanRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.encryptPrivkey = "";
                    else {
                        object.encryptPrivkey = [];
                        if (options.bytes !== Array)
                            object.encryptPrivkey = $util.newBuffer(object.encryptPrivkey);
                    }
                    if (options.bytes === String)
                        object.mapkey = "";
                    else {
                        object.mapkey = [];
                        if (options.bytes !== Array)
                            object.mapkey = $util.newBuffer(object.mapkey);
                    }
                }
                if (message.encryptPrivkey != null && message.hasOwnProperty("encryptPrivkey"))
                    object.encryptPrivkey = options.bytes === String ? $util.base64.encode(message.encryptPrivkey, 0, message.encryptPrivkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptPrivkey) : message.encryptPrivkey;
                if (message.mapkey != null && message.hasOwnProperty("mapkey"))
                    object.mapkey = options.bytes === String ? $util.base64.encode(message.mapkey, 0, message.mapkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mapkey) : message.mapkey;
                return object;
            };

            /**
             * Converts this SetEncryptKeyWithScanRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetEncryptKeyWithScanRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetEncryptKeyWithScanRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.SetEncryptKeyWithScanRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetEncryptKeyWithScanRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SetEncryptKeyWithScanRequest";
            };

            return SetEncryptKeyWithScanRequest;
        })();

        pb.SetEncryptKeyWithScanReply = (function() {

            /**
             * Properties of a SetEncryptKeyWithScanReply.
             * @memberof dcnet.pb
             * @interface ISetEncryptKeyWithScanReply
             */

            /**
             * Constructs a new SetEncryptKeyWithScanReply.
             * @memberof dcnet.pb
             * @classdesc Represents a SetEncryptKeyWithScanReply.
             * @implements ISetEncryptKeyWithScanReply
             * @constructor
             * @param {dcnet.pb.ISetEncryptKeyWithScanReply=} [properties] Properties to set
             */
            function SetEncryptKeyWithScanReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetEncryptKeyWithScanReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SetEncryptKeyWithScanReply
             * @static
             * @param {dcnet.pb.ISetEncryptKeyWithScanReply=} [properties] Properties to set
             * @returns {dcnet.pb.SetEncryptKeyWithScanReply} SetEncryptKeyWithScanReply instance
             */
            SetEncryptKeyWithScanReply.create = function create(properties) {
                return new SetEncryptKeyWithScanReply(properties);
            };

            /**
             * Encodes the specified SetEncryptKeyWithScanReply message. Does not implicitly {@link dcnet.pb.SetEncryptKeyWithScanReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SetEncryptKeyWithScanReply
             * @static
             * @param {dcnet.pb.ISetEncryptKeyWithScanReply} message SetEncryptKeyWithScanReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEncryptKeyWithScanReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetEncryptKeyWithScanReply message, length delimited. Does not implicitly {@link dcnet.pb.SetEncryptKeyWithScanReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SetEncryptKeyWithScanReply
             * @static
             * @param {dcnet.pb.ISetEncryptKeyWithScanReply} message SetEncryptKeyWithScanReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEncryptKeyWithScanReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetEncryptKeyWithScanReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SetEncryptKeyWithScanReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SetEncryptKeyWithScanReply} SetEncryptKeyWithScanReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEncryptKeyWithScanReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SetEncryptKeyWithScanReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetEncryptKeyWithScanReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SetEncryptKeyWithScanReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SetEncryptKeyWithScanReply} SetEncryptKeyWithScanReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEncryptKeyWithScanReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetEncryptKeyWithScanReply message.
             * @function verify
             * @memberof dcnet.pb.SetEncryptKeyWithScanReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetEncryptKeyWithScanReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetEncryptKeyWithScanReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SetEncryptKeyWithScanReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SetEncryptKeyWithScanReply} SetEncryptKeyWithScanReply
             */
            SetEncryptKeyWithScanReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SetEncryptKeyWithScanReply)
                    return object;
                return new $root.dcnet.pb.SetEncryptKeyWithScanReply();
            };

            /**
             * Creates a plain object from a SetEncryptKeyWithScanReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SetEncryptKeyWithScanReply
             * @static
             * @param {dcnet.pb.SetEncryptKeyWithScanReply} message SetEncryptKeyWithScanReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetEncryptKeyWithScanReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetEncryptKeyWithScanReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SetEncryptKeyWithScanReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetEncryptKeyWithScanReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetEncryptKeyWithScanReply
             * @function getTypeUrl
             * @memberof dcnet.pb.SetEncryptKeyWithScanReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetEncryptKeyWithScanReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SetEncryptKeyWithScanReply";
            };

            return SetEncryptKeyWithScanReply;
        })();

        pb.GetEncryptKeyWithScanRequest = (function() {

            /**
             * Properties of a GetEncryptKeyWithScanRequest.
             * @memberof dcnet.pb
             * @interface IGetEncryptKeyWithScanRequest
             * @property {Uint8Array|null} [mapkey] GetEncryptKeyWithScanRequest mapkey
             */

            /**
             * Constructs a new GetEncryptKeyWithScanRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetEncryptKeyWithScanRequest.
             * @implements IGetEncryptKeyWithScanRequest
             * @constructor
             * @param {dcnet.pb.IGetEncryptKeyWithScanRequest=} [properties] Properties to set
             */
            function GetEncryptKeyWithScanRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEncryptKeyWithScanRequest mapkey.
             * @member {Uint8Array} mapkey
             * @memberof dcnet.pb.GetEncryptKeyWithScanRequest
             * @instance
             */
            GetEncryptKeyWithScanRequest.prototype.mapkey = $util.newBuffer([]);

            /**
             * Creates a new GetEncryptKeyWithScanRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetEncryptKeyWithScanRequest
             * @static
             * @param {dcnet.pb.IGetEncryptKeyWithScanRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetEncryptKeyWithScanRequest} GetEncryptKeyWithScanRequest instance
             */
            GetEncryptKeyWithScanRequest.create = function create(properties) {
                return new GetEncryptKeyWithScanRequest(properties);
            };

            /**
             * Encodes the specified GetEncryptKeyWithScanRequest message. Does not implicitly {@link dcnet.pb.GetEncryptKeyWithScanRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetEncryptKeyWithScanRequest
             * @static
             * @param {dcnet.pb.IGetEncryptKeyWithScanRequest} message GetEncryptKeyWithScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEncryptKeyWithScanRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mapkey != null && Object.hasOwnProperty.call(message, "mapkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.mapkey);
                return writer;
            };

            /**
             * Encodes the specified GetEncryptKeyWithScanRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetEncryptKeyWithScanRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetEncryptKeyWithScanRequest
             * @static
             * @param {dcnet.pb.IGetEncryptKeyWithScanRequest} message GetEncryptKeyWithScanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEncryptKeyWithScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEncryptKeyWithScanRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetEncryptKeyWithScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetEncryptKeyWithScanRequest} GetEncryptKeyWithScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEncryptKeyWithScanRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetEncryptKeyWithScanRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.mapkey = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEncryptKeyWithScanRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetEncryptKeyWithScanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetEncryptKeyWithScanRequest} GetEncryptKeyWithScanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEncryptKeyWithScanRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEncryptKeyWithScanRequest message.
             * @function verify
             * @memberof dcnet.pb.GetEncryptKeyWithScanRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEncryptKeyWithScanRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mapkey != null && message.hasOwnProperty("mapkey"))
                    if (!(message.mapkey && typeof message.mapkey.length === "number" || $util.isString(message.mapkey)))
                        return "mapkey: buffer expected";
                return null;
            };

            /**
             * Creates a GetEncryptKeyWithScanRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetEncryptKeyWithScanRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetEncryptKeyWithScanRequest} GetEncryptKeyWithScanRequest
             */
            GetEncryptKeyWithScanRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetEncryptKeyWithScanRequest)
                    return object;
                let message = new $root.dcnet.pb.GetEncryptKeyWithScanRequest();
                if (object.mapkey != null)
                    if (typeof object.mapkey === "string")
                        $util.base64.decode(object.mapkey, message.mapkey = $util.newBuffer($util.base64.length(object.mapkey)), 0);
                    else if (object.mapkey.length >= 0)
                        message.mapkey = object.mapkey;
                return message;
            };

            /**
             * Creates a plain object from a GetEncryptKeyWithScanRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetEncryptKeyWithScanRequest
             * @static
             * @param {dcnet.pb.GetEncryptKeyWithScanRequest} message GetEncryptKeyWithScanRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetEncryptKeyWithScanRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.mapkey = "";
                    else {
                        object.mapkey = [];
                        if (options.bytes !== Array)
                            object.mapkey = $util.newBuffer(object.mapkey);
                    }
                if (message.mapkey != null && message.hasOwnProperty("mapkey"))
                    object.mapkey = options.bytes === String ? $util.base64.encode(message.mapkey, 0, message.mapkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mapkey) : message.mapkey;
                return object;
            };

            /**
             * Converts this GetEncryptKeyWithScanRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetEncryptKeyWithScanRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetEncryptKeyWithScanRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetEncryptKeyWithScanRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetEncryptKeyWithScanRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetEncryptKeyWithScanRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetEncryptKeyWithScanRequest";
            };

            return GetEncryptKeyWithScanRequest;
        })();

        pb.GetEncryptKeyWithScanReply = (function() {

            /**
             * Properties of a GetEncryptKeyWithScanReply.
             * @memberof dcnet.pb
             * @interface IGetEncryptKeyWithScanReply
             * @property {Uint8Array|null} [encryptPrivkey] GetEncryptKeyWithScanReply encryptPrivkey
             */

            /**
             * Constructs a new GetEncryptKeyWithScanReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetEncryptKeyWithScanReply.
             * @implements IGetEncryptKeyWithScanReply
             * @constructor
             * @param {dcnet.pb.IGetEncryptKeyWithScanReply=} [properties] Properties to set
             */
            function GetEncryptKeyWithScanReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEncryptKeyWithScanReply encryptPrivkey.
             * @member {Uint8Array} encryptPrivkey
             * @memberof dcnet.pb.GetEncryptKeyWithScanReply
             * @instance
             */
            GetEncryptKeyWithScanReply.prototype.encryptPrivkey = $util.newBuffer([]);

            /**
             * Creates a new GetEncryptKeyWithScanReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetEncryptKeyWithScanReply
             * @static
             * @param {dcnet.pb.IGetEncryptKeyWithScanReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetEncryptKeyWithScanReply} GetEncryptKeyWithScanReply instance
             */
            GetEncryptKeyWithScanReply.create = function create(properties) {
                return new GetEncryptKeyWithScanReply(properties);
            };

            /**
             * Encodes the specified GetEncryptKeyWithScanReply message. Does not implicitly {@link dcnet.pb.GetEncryptKeyWithScanReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetEncryptKeyWithScanReply
             * @static
             * @param {dcnet.pb.IGetEncryptKeyWithScanReply} message GetEncryptKeyWithScanReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEncryptKeyWithScanReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.encryptPrivkey != null && Object.hasOwnProperty.call(message, "encryptPrivkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptPrivkey);
                return writer;
            };

            /**
             * Encodes the specified GetEncryptKeyWithScanReply message, length delimited. Does not implicitly {@link dcnet.pb.GetEncryptKeyWithScanReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetEncryptKeyWithScanReply
             * @static
             * @param {dcnet.pb.IGetEncryptKeyWithScanReply} message GetEncryptKeyWithScanReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEncryptKeyWithScanReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEncryptKeyWithScanReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetEncryptKeyWithScanReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetEncryptKeyWithScanReply} GetEncryptKeyWithScanReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEncryptKeyWithScanReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetEncryptKeyWithScanReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.encryptPrivkey = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEncryptKeyWithScanReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetEncryptKeyWithScanReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetEncryptKeyWithScanReply} GetEncryptKeyWithScanReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEncryptKeyWithScanReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEncryptKeyWithScanReply message.
             * @function verify
             * @memberof dcnet.pb.GetEncryptKeyWithScanReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEncryptKeyWithScanReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.encryptPrivkey != null && message.hasOwnProperty("encryptPrivkey"))
                    if (!(message.encryptPrivkey && typeof message.encryptPrivkey.length === "number" || $util.isString(message.encryptPrivkey)))
                        return "encryptPrivkey: buffer expected";
                return null;
            };

            /**
             * Creates a GetEncryptKeyWithScanReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetEncryptKeyWithScanReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetEncryptKeyWithScanReply} GetEncryptKeyWithScanReply
             */
            GetEncryptKeyWithScanReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetEncryptKeyWithScanReply)
                    return object;
                let message = new $root.dcnet.pb.GetEncryptKeyWithScanReply();
                if (object.encryptPrivkey != null)
                    if (typeof object.encryptPrivkey === "string")
                        $util.base64.decode(object.encryptPrivkey, message.encryptPrivkey = $util.newBuffer($util.base64.length(object.encryptPrivkey)), 0);
                    else if (object.encryptPrivkey.length >= 0)
                        message.encryptPrivkey = object.encryptPrivkey;
                return message;
            };

            /**
             * Creates a plain object from a GetEncryptKeyWithScanReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetEncryptKeyWithScanReply
             * @static
             * @param {dcnet.pb.GetEncryptKeyWithScanReply} message GetEncryptKeyWithScanReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetEncryptKeyWithScanReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.encryptPrivkey = "";
                    else {
                        object.encryptPrivkey = [];
                        if (options.bytes !== Array)
                            object.encryptPrivkey = $util.newBuffer(object.encryptPrivkey);
                    }
                if (message.encryptPrivkey != null && message.hasOwnProperty("encryptPrivkey"))
                    object.encryptPrivkey = options.bytes === String ? $util.base64.encode(message.encryptPrivkey, 0, message.encryptPrivkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptPrivkey) : message.encryptPrivkey;
                return object;
            };

            /**
             * Converts this GetEncryptKeyWithScanReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetEncryptKeyWithScanReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetEncryptKeyWithScanReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetEncryptKeyWithScanReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetEncryptKeyWithScanReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetEncryptKeyWithScanReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetEncryptKeyWithScanReply";
            };

            return GetEncryptKeyWithScanReply;
        })();

        pb.RequestRandEncryptKeyRequest = (function() {

            /**
             * Properties of a RequestRandEncryptKeyRequest.
             * @memberof dcnet.pb
             * @interface IRequestRandEncryptKeyRequest
             * @property {Uint8Array|null} [enclaveid] RequestRandEncryptKeyRequest enclaveid
             */

            /**
             * Constructs a new RequestRandEncryptKeyRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a RequestRandEncryptKeyRequest.
             * @implements IRequestRandEncryptKeyRequest
             * @constructor
             * @param {dcnet.pb.IRequestRandEncryptKeyRequest=} [properties] Properties to set
             */
            function RequestRandEncryptKeyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestRandEncryptKeyRequest enclaveid.
             * @member {Uint8Array} enclaveid
             * @memberof dcnet.pb.RequestRandEncryptKeyRequest
             * @instance
             */
            RequestRandEncryptKeyRequest.prototype.enclaveid = $util.newBuffer([]);

            /**
             * Creates a new RequestRandEncryptKeyRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.RequestRandEncryptKeyRequest
             * @static
             * @param {dcnet.pb.IRequestRandEncryptKeyRequest=} [properties] Properties to set
             * @returns {dcnet.pb.RequestRandEncryptKeyRequest} RequestRandEncryptKeyRequest instance
             */
            RequestRandEncryptKeyRequest.create = function create(properties) {
                return new RequestRandEncryptKeyRequest(properties);
            };

            /**
             * Encodes the specified RequestRandEncryptKeyRequest message. Does not implicitly {@link dcnet.pb.RequestRandEncryptKeyRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.RequestRandEncryptKeyRequest
             * @static
             * @param {dcnet.pb.IRequestRandEncryptKeyRequest} message RequestRandEncryptKeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestRandEncryptKeyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enclaveid != null && Object.hasOwnProperty.call(message, "enclaveid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.enclaveid);
                return writer;
            };

            /**
             * Encodes the specified RequestRandEncryptKeyRequest message, length delimited. Does not implicitly {@link dcnet.pb.RequestRandEncryptKeyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.RequestRandEncryptKeyRequest
             * @static
             * @param {dcnet.pb.IRequestRandEncryptKeyRequest} message RequestRandEncryptKeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestRandEncryptKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestRandEncryptKeyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.RequestRandEncryptKeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.RequestRandEncryptKeyRequest} RequestRandEncryptKeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestRandEncryptKeyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.RequestRandEncryptKeyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.enclaveid = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestRandEncryptKeyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.RequestRandEncryptKeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.RequestRandEncryptKeyRequest} RequestRandEncryptKeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestRandEncryptKeyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestRandEncryptKeyRequest message.
             * @function verify
             * @memberof dcnet.pb.RequestRandEncryptKeyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestRandEncryptKeyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enclaveid != null && message.hasOwnProperty("enclaveid"))
                    if (!(message.enclaveid && typeof message.enclaveid.length === "number" || $util.isString(message.enclaveid)))
                        return "enclaveid: buffer expected";
                return null;
            };

            /**
             * Creates a RequestRandEncryptKeyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.RequestRandEncryptKeyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.RequestRandEncryptKeyRequest} RequestRandEncryptKeyRequest
             */
            RequestRandEncryptKeyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.RequestRandEncryptKeyRequest)
                    return object;
                let message = new $root.dcnet.pb.RequestRandEncryptKeyRequest();
                if (object.enclaveid != null)
                    if (typeof object.enclaveid === "string")
                        $util.base64.decode(object.enclaveid, message.enclaveid = $util.newBuffer($util.base64.length(object.enclaveid)), 0);
                    else if (object.enclaveid.length >= 0)
                        message.enclaveid = object.enclaveid;
                return message;
            };

            /**
             * Creates a plain object from a RequestRandEncryptKeyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.RequestRandEncryptKeyRequest
             * @static
             * @param {dcnet.pb.RequestRandEncryptKeyRequest} message RequestRandEncryptKeyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestRandEncryptKeyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.enclaveid = "";
                    else {
                        object.enclaveid = [];
                        if (options.bytes !== Array)
                            object.enclaveid = $util.newBuffer(object.enclaveid);
                    }
                if (message.enclaveid != null && message.hasOwnProperty("enclaveid"))
                    object.enclaveid = options.bytes === String ? $util.base64.encode(message.enclaveid, 0, message.enclaveid.length) : options.bytes === Array ? Array.prototype.slice.call(message.enclaveid) : message.enclaveid;
                return object;
            };

            /**
             * Converts this RequestRandEncryptKeyRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.RequestRandEncryptKeyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestRandEncryptKeyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RequestRandEncryptKeyRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.RequestRandEncryptKeyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RequestRandEncryptKeyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.RequestRandEncryptKeyRequest";
            };

            return RequestRandEncryptKeyRequest;
        })();

        pb.RequestRandEncryptKeyReply = (function() {

            /**
             * Properties of a RequestRandEncryptKeyReply.
             * @memberof dcnet.pb
             * @interface IRequestRandEncryptKeyReply
             * @property {Uint8Array|null} [encryptKey] RequestRandEncryptKeyReply encryptKey
             * @property {Uint8Array|null} [signature] RequestRandEncryptKeyReply signature
             */

            /**
             * Constructs a new RequestRandEncryptKeyReply.
             * @memberof dcnet.pb
             * @classdesc Represents a RequestRandEncryptKeyReply.
             * @implements IRequestRandEncryptKeyReply
             * @constructor
             * @param {dcnet.pb.IRequestRandEncryptKeyReply=} [properties] Properties to set
             */
            function RequestRandEncryptKeyReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestRandEncryptKeyReply encryptKey.
             * @member {Uint8Array} encryptKey
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @instance
             */
            RequestRandEncryptKeyReply.prototype.encryptKey = $util.newBuffer([]);

            /**
             * RequestRandEncryptKeyReply signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @instance
             */
            RequestRandEncryptKeyReply.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new RequestRandEncryptKeyReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @static
             * @param {dcnet.pb.IRequestRandEncryptKeyReply=} [properties] Properties to set
             * @returns {dcnet.pb.RequestRandEncryptKeyReply} RequestRandEncryptKeyReply instance
             */
            RequestRandEncryptKeyReply.create = function create(properties) {
                return new RequestRandEncryptKeyReply(properties);
            };

            /**
             * Encodes the specified RequestRandEncryptKeyReply message. Does not implicitly {@link dcnet.pb.RequestRandEncryptKeyReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @static
             * @param {dcnet.pb.IRequestRandEncryptKeyReply} message RequestRandEncryptKeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestRandEncryptKeyReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.encryptKey != null && Object.hasOwnProperty.call(message, "encryptKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptKey);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified RequestRandEncryptKeyReply message, length delimited. Does not implicitly {@link dcnet.pb.RequestRandEncryptKeyReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @static
             * @param {dcnet.pb.IRequestRandEncryptKeyReply} message RequestRandEncryptKeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestRandEncryptKeyReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestRandEncryptKeyReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.RequestRandEncryptKeyReply} RequestRandEncryptKeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestRandEncryptKeyReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.RequestRandEncryptKeyReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.encryptKey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestRandEncryptKeyReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.RequestRandEncryptKeyReply} RequestRandEncryptKeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestRandEncryptKeyReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestRandEncryptKeyReply message.
             * @function verify
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestRandEncryptKeyReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.encryptKey != null && message.hasOwnProperty("encryptKey"))
                    if (!(message.encryptKey && typeof message.encryptKey.length === "number" || $util.isString(message.encryptKey)))
                        return "encryptKey: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a RequestRandEncryptKeyReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.RequestRandEncryptKeyReply} RequestRandEncryptKeyReply
             */
            RequestRandEncryptKeyReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.RequestRandEncryptKeyReply)
                    return object;
                let message = new $root.dcnet.pb.RequestRandEncryptKeyReply();
                if (object.encryptKey != null)
                    if (typeof object.encryptKey === "string")
                        $util.base64.decode(object.encryptKey, message.encryptKey = $util.newBuffer($util.base64.length(object.encryptKey)), 0);
                    else if (object.encryptKey.length >= 0)
                        message.encryptKey = object.encryptKey;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a RequestRandEncryptKeyReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @static
             * @param {dcnet.pb.RequestRandEncryptKeyReply} message RequestRandEncryptKeyReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestRandEncryptKeyReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.encryptKey = "";
                    else {
                        object.encryptKey = [];
                        if (options.bytes !== Array)
                            object.encryptKey = $util.newBuffer(object.encryptKey);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.encryptKey != null && message.hasOwnProperty("encryptKey"))
                    object.encryptKey = options.bytes === String ? $util.base64.encode(message.encryptKey, 0, message.encryptKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptKey) : message.encryptKey;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this RequestRandEncryptKeyReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestRandEncryptKeyReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RequestRandEncryptKeyReply
             * @function getTypeUrl
             * @memberof dcnet.pb.RequestRandEncryptKeyReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RequestRandEncryptKeyReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.RequestRandEncryptKeyReply";
            };

            return RequestRandEncryptKeyReply;
        })();

        pb.GetEncryptKeyRequest = (function() {

            /**
             * Properties of a GetEncryptKeyRequest.
             * @memberof dcnet.pb
             * @interface IGetEncryptKeyRequest
             * @property {Uint8Array|null} [peerId] GetEncryptKeyRequest peerId
             * @property {Uint8Array|null} [teereport] GetEncryptKeyRequest teereport
             */

            /**
             * Constructs a new GetEncryptKeyRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetEncryptKeyRequest.
             * @implements IGetEncryptKeyRequest
             * @constructor
             * @param {dcnet.pb.IGetEncryptKeyRequest=} [properties] Properties to set
             */
            function GetEncryptKeyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEncryptKeyRequest peerId.
             * @member {Uint8Array} peerId
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @instance
             */
            GetEncryptKeyRequest.prototype.peerId = $util.newBuffer([]);

            /**
             * GetEncryptKeyRequest teereport.
             * @member {Uint8Array} teereport
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @instance
             */
            GetEncryptKeyRequest.prototype.teereport = $util.newBuffer([]);

            /**
             * Creates a new GetEncryptKeyRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @static
             * @param {dcnet.pb.IGetEncryptKeyRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetEncryptKeyRequest} GetEncryptKeyRequest instance
             */
            GetEncryptKeyRequest.create = function create(properties) {
                return new GetEncryptKeyRequest(properties);
            };

            /**
             * Encodes the specified GetEncryptKeyRequest message. Does not implicitly {@link dcnet.pb.GetEncryptKeyRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @static
             * @param {dcnet.pb.IGetEncryptKeyRequest} message GetEncryptKeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEncryptKeyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peerId != null && Object.hasOwnProperty.call(message, "peerId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.peerId);
                if (message.teereport != null && Object.hasOwnProperty.call(message, "teereport"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.teereport);
                return writer;
            };

            /**
             * Encodes the specified GetEncryptKeyRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetEncryptKeyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @static
             * @param {dcnet.pb.IGetEncryptKeyRequest} message GetEncryptKeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEncryptKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEncryptKeyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetEncryptKeyRequest} GetEncryptKeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEncryptKeyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetEncryptKeyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.peerId = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.teereport = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEncryptKeyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetEncryptKeyRequest} GetEncryptKeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEncryptKeyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEncryptKeyRequest message.
             * @function verify
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEncryptKeyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peerId != null && message.hasOwnProperty("peerId"))
                    if (!(message.peerId && typeof message.peerId.length === "number" || $util.isString(message.peerId)))
                        return "peerId: buffer expected";
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    if (!(message.teereport && typeof message.teereport.length === "number" || $util.isString(message.teereport)))
                        return "teereport: buffer expected";
                return null;
            };

            /**
             * Creates a GetEncryptKeyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetEncryptKeyRequest} GetEncryptKeyRequest
             */
            GetEncryptKeyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetEncryptKeyRequest)
                    return object;
                let message = new $root.dcnet.pb.GetEncryptKeyRequest();
                if (object.peerId != null)
                    if (typeof object.peerId === "string")
                        $util.base64.decode(object.peerId, message.peerId = $util.newBuffer($util.base64.length(object.peerId)), 0);
                    else if (object.peerId.length >= 0)
                        message.peerId = object.peerId;
                if (object.teereport != null)
                    if (typeof object.teereport === "string")
                        $util.base64.decode(object.teereport, message.teereport = $util.newBuffer($util.base64.length(object.teereport)), 0);
                    else if (object.teereport.length >= 0)
                        message.teereport = object.teereport;
                return message;
            };

            /**
             * Creates a plain object from a GetEncryptKeyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @static
             * @param {dcnet.pb.GetEncryptKeyRequest} message GetEncryptKeyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetEncryptKeyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.peerId = "";
                    else {
                        object.peerId = [];
                        if (options.bytes !== Array)
                            object.peerId = $util.newBuffer(object.peerId);
                    }
                    if (options.bytes === String)
                        object.teereport = "";
                    else {
                        object.teereport = [];
                        if (options.bytes !== Array)
                            object.teereport = $util.newBuffer(object.teereport);
                    }
                }
                if (message.peerId != null && message.hasOwnProperty("peerId"))
                    object.peerId = options.bytes === String ? $util.base64.encode(message.peerId, 0, message.peerId.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerId) : message.peerId;
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    object.teereport = options.bytes === String ? $util.base64.encode(message.teereport, 0, message.teereport.length) : options.bytes === Array ? Array.prototype.slice.call(message.teereport) : message.teereport;
                return object;
            };

            /**
             * Converts this GetEncryptKeyRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetEncryptKeyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetEncryptKeyRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetEncryptKeyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetEncryptKeyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetEncryptKeyRequest";
            };

            return GetEncryptKeyRequest;
        })();

        pb.GetEncryptKeyReply = (function() {

            /**
             * Properties of a GetEncryptKeyReply.
             * @memberof dcnet.pb
             * @interface IGetEncryptKeyReply
             * @property {Uint8Array|null} [encryptKey] GetEncryptKeyReply encryptKey
             * @property {Uint8Array|null} [signature] GetEncryptKeyReply signature
             */

            /**
             * Constructs a new GetEncryptKeyReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetEncryptKeyReply.
             * @implements IGetEncryptKeyReply
             * @constructor
             * @param {dcnet.pb.IGetEncryptKeyReply=} [properties] Properties to set
             */
            function GetEncryptKeyReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEncryptKeyReply encryptKey.
             * @member {Uint8Array} encryptKey
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @instance
             */
            GetEncryptKeyReply.prototype.encryptKey = $util.newBuffer([]);

            /**
             * GetEncryptKeyReply signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @instance
             */
            GetEncryptKeyReply.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new GetEncryptKeyReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @static
             * @param {dcnet.pb.IGetEncryptKeyReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetEncryptKeyReply} GetEncryptKeyReply instance
             */
            GetEncryptKeyReply.create = function create(properties) {
                return new GetEncryptKeyReply(properties);
            };

            /**
             * Encodes the specified GetEncryptKeyReply message. Does not implicitly {@link dcnet.pb.GetEncryptKeyReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @static
             * @param {dcnet.pb.IGetEncryptKeyReply} message GetEncryptKeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEncryptKeyReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.encryptKey != null && Object.hasOwnProperty.call(message, "encryptKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptKey);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified GetEncryptKeyReply message, length delimited. Does not implicitly {@link dcnet.pb.GetEncryptKeyReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @static
             * @param {dcnet.pb.IGetEncryptKeyReply} message GetEncryptKeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEncryptKeyReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEncryptKeyReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetEncryptKeyReply} GetEncryptKeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEncryptKeyReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetEncryptKeyReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.encryptKey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEncryptKeyReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetEncryptKeyReply} GetEncryptKeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEncryptKeyReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEncryptKeyReply message.
             * @function verify
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEncryptKeyReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.encryptKey != null && message.hasOwnProperty("encryptKey"))
                    if (!(message.encryptKey && typeof message.encryptKey.length === "number" || $util.isString(message.encryptKey)))
                        return "encryptKey: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a GetEncryptKeyReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetEncryptKeyReply} GetEncryptKeyReply
             */
            GetEncryptKeyReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetEncryptKeyReply)
                    return object;
                let message = new $root.dcnet.pb.GetEncryptKeyReply();
                if (object.encryptKey != null)
                    if (typeof object.encryptKey === "string")
                        $util.base64.decode(object.encryptKey, message.encryptKey = $util.newBuffer($util.base64.length(object.encryptKey)), 0);
                    else if (object.encryptKey.length >= 0)
                        message.encryptKey = object.encryptKey;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a GetEncryptKeyReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @static
             * @param {dcnet.pb.GetEncryptKeyReply} message GetEncryptKeyReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetEncryptKeyReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.encryptKey = "";
                    else {
                        object.encryptKey = [];
                        if (options.bytes !== Array)
                            object.encryptKey = $util.newBuffer(object.encryptKey);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.encryptKey != null && message.hasOwnProperty("encryptKey"))
                    object.encryptKey = options.bytes === String ? $util.base64.encode(message.encryptKey, 0, message.encryptKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptKey) : message.encryptKey;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this GetEncryptKeyReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetEncryptKeyReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetEncryptKeyReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetEncryptKeyReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetEncryptKeyReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetEncryptKeyReply";
            };

            return GetEncryptKeyReply;
        })();

        pb.GetPeersWithSidRequest = (function() {

            /**
             * Properties of a GetPeersWithSidRequest.
             * @memberof dcnet.pb
             * @interface IGetPeersWithSidRequest
             * @property {string|null} [sid] GetPeersWithSidRequest sid
             */

            /**
             * Constructs a new GetPeersWithSidRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetPeersWithSidRequest.
             * @implements IGetPeersWithSidRequest
             * @constructor
             * @param {dcnet.pb.IGetPeersWithSidRequest=} [properties] Properties to set
             */
            function GetPeersWithSidRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetPeersWithSidRequest sid.
             * @member {string} sid
             * @memberof dcnet.pb.GetPeersWithSidRequest
             * @instance
             */
            GetPeersWithSidRequest.prototype.sid = "";

            /**
             * Creates a new GetPeersWithSidRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetPeersWithSidRequest
             * @static
             * @param {dcnet.pb.IGetPeersWithSidRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetPeersWithSidRequest} GetPeersWithSidRequest instance
             */
            GetPeersWithSidRequest.create = function create(properties) {
                return new GetPeersWithSidRequest(properties);
            };

            /**
             * Encodes the specified GetPeersWithSidRequest message. Does not implicitly {@link dcnet.pb.GetPeersWithSidRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetPeersWithSidRequest
             * @static
             * @param {dcnet.pb.IGetPeersWithSidRequest} message GetPeersWithSidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPeersWithSidRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sid != null && Object.hasOwnProperty.call(message, "sid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sid);
                return writer;
            };

            /**
             * Encodes the specified GetPeersWithSidRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetPeersWithSidRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetPeersWithSidRequest
             * @static
             * @param {dcnet.pb.IGetPeersWithSidRequest} message GetPeersWithSidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPeersWithSidRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetPeersWithSidRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetPeersWithSidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetPeersWithSidRequest} GetPeersWithSidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPeersWithSidRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetPeersWithSidRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sid = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetPeersWithSidRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetPeersWithSidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetPeersWithSidRequest} GetPeersWithSidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPeersWithSidRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetPeersWithSidRequest message.
             * @function verify
             * @memberof dcnet.pb.GetPeersWithSidRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetPeersWithSidRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sid != null && message.hasOwnProperty("sid"))
                    if (!$util.isString(message.sid))
                        return "sid: string expected";
                return null;
            };

            /**
             * Creates a GetPeersWithSidRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetPeersWithSidRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetPeersWithSidRequest} GetPeersWithSidRequest
             */
            GetPeersWithSidRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetPeersWithSidRequest)
                    return object;
                let message = new $root.dcnet.pb.GetPeersWithSidRequest();
                if (object.sid != null)
                    message.sid = String(object.sid);
                return message;
            };

            /**
             * Creates a plain object from a GetPeersWithSidRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetPeersWithSidRequest
             * @static
             * @param {dcnet.pb.GetPeersWithSidRequest} message GetPeersWithSidRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetPeersWithSidRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.sid = "";
                if (message.sid != null && message.hasOwnProperty("sid"))
                    object.sid = message.sid;
                return object;
            };

            /**
             * Converts this GetPeersWithSidRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetPeersWithSidRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetPeersWithSidRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetPeersWithSidRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetPeersWithSidRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetPeersWithSidRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetPeersWithSidRequest";
            };

            return GetPeersWithSidRequest;
        })();

        pb.GetPeersWithSidReply = (function() {

            /**
             * Properties of a GetPeersWithSidReply.
             * @memberof dcnet.pb
             * @interface IGetPeersWithSidReply
             * @property {Array.<string>|null} [peerids] GetPeersWithSidReply peerids
             */

            /**
             * Constructs a new GetPeersWithSidReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetPeersWithSidReply.
             * @implements IGetPeersWithSidReply
             * @constructor
             * @param {dcnet.pb.IGetPeersWithSidReply=} [properties] Properties to set
             */
            function GetPeersWithSidReply(properties) {
                this.peerids = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetPeersWithSidReply peerids.
             * @member {Array.<string>} peerids
             * @memberof dcnet.pb.GetPeersWithSidReply
             * @instance
             */
            GetPeersWithSidReply.prototype.peerids = $util.emptyArray;

            /**
             * Creates a new GetPeersWithSidReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetPeersWithSidReply
             * @static
             * @param {dcnet.pb.IGetPeersWithSidReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetPeersWithSidReply} GetPeersWithSidReply instance
             */
            GetPeersWithSidReply.create = function create(properties) {
                return new GetPeersWithSidReply(properties);
            };

            /**
             * Encodes the specified GetPeersWithSidReply message. Does not implicitly {@link dcnet.pb.GetPeersWithSidReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetPeersWithSidReply
             * @static
             * @param {dcnet.pb.IGetPeersWithSidReply} message GetPeersWithSidReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPeersWithSidReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peerids != null && message.peerids.length)
                    for (let i = 0; i < message.peerids.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerids[i]);
                return writer;
            };

            /**
             * Encodes the specified GetPeersWithSidReply message, length delimited. Does not implicitly {@link dcnet.pb.GetPeersWithSidReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetPeersWithSidReply
             * @static
             * @param {dcnet.pb.IGetPeersWithSidReply} message GetPeersWithSidReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPeersWithSidReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetPeersWithSidReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetPeersWithSidReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetPeersWithSidReply} GetPeersWithSidReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPeersWithSidReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetPeersWithSidReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.peerids && message.peerids.length))
                                message.peerids = [];
                            message.peerids.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetPeersWithSidReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetPeersWithSidReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetPeersWithSidReply} GetPeersWithSidReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPeersWithSidReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetPeersWithSidReply message.
             * @function verify
             * @memberof dcnet.pb.GetPeersWithSidReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetPeersWithSidReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peerids != null && message.hasOwnProperty("peerids")) {
                    if (!Array.isArray(message.peerids))
                        return "peerids: array expected";
                    for (let i = 0; i < message.peerids.length; ++i)
                        if (!$util.isString(message.peerids[i]))
                            return "peerids: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GetPeersWithSidReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetPeersWithSidReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetPeersWithSidReply} GetPeersWithSidReply
             */
            GetPeersWithSidReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetPeersWithSidReply)
                    return object;
                let message = new $root.dcnet.pb.GetPeersWithSidReply();
                if (object.peerids) {
                    if (!Array.isArray(object.peerids))
                        throw TypeError(".dcnet.pb.GetPeersWithSidReply.peerids: array expected");
                    message.peerids = [];
                    for (let i = 0; i < object.peerids.length; ++i)
                        message.peerids[i] = String(object.peerids[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetPeersWithSidReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetPeersWithSidReply
             * @static
             * @param {dcnet.pb.GetPeersWithSidReply} message GetPeersWithSidReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetPeersWithSidReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.peerids = [];
                if (message.peerids && message.peerids.length) {
                    object.peerids = [];
                    for (let j = 0; j < message.peerids.length; ++j)
                        object.peerids[j] = message.peerids[j];
                }
                return object;
            };

            /**
             * Converts this GetPeersWithSidReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetPeersWithSidReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetPeersWithSidReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetPeersWithSidReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetPeersWithSidReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetPeersWithSidReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetPeersWithSidReply";
            };

            return GetPeersWithSidReply;
        })();

        pb.GetPeersWithAccountHashRequest = (function() {

            /**
             * Properties of a GetPeersWithAccountHashRequest.
             * @memberof dcnet.pb
             * @interface IGetPeersWithAccountHashRequest
             * @property {Uint8Array|null} [accounthash] GetPeersWithAccountHashRequest accounthash
             */

            /**
             * Constructs a new GetPeersWithAccountHashRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetPeersWithAccountHashRequest.
             * @implements IGetPeersWithAccountHashRequest
             * @constructor
             * @param {dcnet.pb.IGetPeersWithAccountHashRequest=} [properties] Properties to set
             */
            function GetPeersWithAccountHashRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetPeersWithAccountHashRequest accounthash.
             * @member {Uint8Array} accounthash
             * @memberof dcnet.pb.GetPeersWithAccountHashRequest
             * @instance
             */
            GetPeersWithAccountHashRequest.prototype.accounthash = $util.newBuffer([]);

            /**
             * Creates a new GetPeersWithAccountHashRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetPeersWithAccountHashRequest
             * @static
             * @param {dcnet.pb.IGetPeersWithAccountHashRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetPeersWithAccountHashRequest} GetPeersWithAccountHashRequest instance
             */
            GetPeersWithAccountHashRequest.create = function create(properties) {
                return new GetPeersWithAccountHashRequest(properties);
            };

            /**
             * Encodes the specified GetPeersWithAccountHashRequest message. Does not implicitly {@link dcnet.pb.GetPeersWithAccountHashRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetPeersWithAccountHashRequest
             * @static
             * @param {dcnet.pb.IGetPeersWithAccountHashRequest} message GetPeersWithAccountHashRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPeersWithAccountHashRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accounthash != null && Object.hasOwnProperty.call(message, "accounthash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accounthash);
                return writer;
            };

            /**
             * Encodes the specified GetPeersWithAccountHashRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetPeersWithAccountHashRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetPeersWithAccountHashRequest
             * @static
             * @param {dcnet.pb.IGetPeersWithAccountHashRequest} message GetPeersWithAccountHashRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPeersWithAccountHashRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetPeersWithAccountHashRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetPeersWithAccountHashRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetPeersWithAccountHashRequest} GetPeersWithAccountHashRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPeersWithAccountHashRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetPeersWithAccountHashRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accounthash = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetPeersWithAccountHashRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetPeersWithAccountHashRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetPeersWithAccountHashRequest} GetPeersWithAccountHashRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPeersWithAccountHashRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetPeersWithAccountHashRequest message.
             * @function verify
             * @memberof dcnet.pb.GetPeersWithAccountHashRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetPeersWithAccountHashRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accounthash != null && message.hasOwnProperty("accounthash"))
                    if (!(message.accounthash && typeof message.accounthash.length === "number" || $util.isString(message.accounthash)))
                        return "accounthash: buffer expected";
                return null;
            };

            /**
             * Creates a GetPeersWithAccountHashRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetPeersWithAccountHashRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetPeersWithAccountHashRequest} GetPeersWithAccountHashRequest
             */
            GetPeersWithAccountHashRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetPeersWithAccountHashRequest)
                    return object;
                let message = new $root.dcnet.pb.GetPeersWithAccountHashRequest();
                if (object.accounthash != null)
                    if (typeof object.accounthash === "string")
                        $util.base64.decode(object.accounthash, message.accounthash = $util.newBuffer($util.base64.length(object.accounthash)), 0);
                    else if (object.accounthash.length >= 0)
                        message.accounthash = object.accounthash;
                return message;
            };

            /**
             * Creates a plain object from a GetPeersWithAccountHashRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetPeersWithAccountHashRequest
             * @static
             * @param {dcnet.pb.GetPeersWithAccountHashRequest} message GetPeersWithAccountHashRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetPeersWithAccountHashRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.accounthash = "";
                    else {
                        object.accounthash = [];
                        if (options.bytes !== Array)
                            object.accounthash = $util.newBuffer(object.accounthash);
                    }
                if (message.accounthash != null && message.hasOwnProperty("accounthash"))
                    object.accounthash = options.bytes === String ? $util.base64.encode(message.accounthash, 0, message.accounthash.length) : options.bytes === Array ? Array.prototype.slice.call(message.accounthash) : message.accounthash;
                return object;
            };

            /**
             * Converts this GetPeersWithAccountHashRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetPeersWithAccountHashRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetPeersWithAccountHashRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetPeersWithAccountHashRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetPeersWithAccountHashRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetPeersWithAccountHashRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetPeersWithAccountHashRequest";
            };

            return GetPeersWithAccountHashRequest;
        })();

        pb.GetPeersWithAccountHashReply = (function() {

            /**
             * Properties of a GetPeersWithAccountHashReply.
             * @memberof dcnet.pb
             * @interface IGetPeersWithAccountHashReply
             * @property {Array.<string>|null} [peerids] GetPeersWithAccountHashReply peerids
             */

            /**
             * Constructs a new GetPeersWithAccountHashReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetPeersWithAccountHashReply.
             * @implements IGetPeersWithAccountHashReply
             * @constructor
             * @param {dcnet.pb.IGetPeersWithAccountHashReply=} [properties] Properties to set
             */
            function GetPeersWithAccountHashReply(properties) {
                this.peerids = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetPeersWithAccountHashReply peerids.
             * @member {Array.<string>} peerids
             * @memberof dcnet.pb.GetPeersWithAccountHashReply
             * @instance
             */
            GetPeersWithAccountHashReply.prototype.peerids = $util.emptyArray;

            /**
             * Creates a new GetPeersWithAccountHashReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetPeersWithAccountHashReply
             * @static
             * @param {dcnet.pb.IGetPeersWithAccountHashReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetPeersWithAccountHashReply} GetPeersWithAccountHashReply instance
             */
            GetPeersWithAccountHashReply.create = function create(properties) {
                return new GetPeersWithAccountHashReply(properties);
            };

            /**
             * Encodes the specified GetPeersWithAccountHashReply message. Does not implicitly {@link dcnet.pb.GetPeersWithAccountHashReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetPeersWithAccountHashReply
             * @static
             * @param {dcnet.pb.IGetPeersWithAccountHashReply} message GetPeersWithAccountHashReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPeersWithAccountHashReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peerids != null && message.peerids.length)
                    for (let i = 0; i < message.peerids.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.peerids[i]);
                return writer;
            };

            /**
             * Encodes the specified GetPeersWithAccountHashReply message, length delimited. Does not implicitly {@link dcnet.pb.GetPeersWithAccountHashReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetPeersWithAccountHashReply
             * @static
             * @param {dcnet.pb.IGetPeersWithAccountHashReply} message GetPeersWithAccountHashReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPeersWithAccountHashReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetPeersWithAccountHashReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetPeersWithAccountHashReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetPeersWithAccountHashReply} GetPeersWithAccountHashReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPeersWithAccountHashReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetPeersWithAccountHashReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.peerids && message.peerids.length))
                                message.peerids = [];
                            message.peerids.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetPeersWithAccountHashReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetPeersWithAccountHashReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetPeersWithAccountHashReply} GetPeersWithAccountHashReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPeersWithAccountHashReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetPeersWithAccountHashReply message.
             * @function verify
             * @memberof dcnet.pb.GetPeersWithAccountHashReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetPeersWithAccountHashReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peerids != null && message.hasOwnProperty("peerids")) {
                    if (!Array.isArray(message.peerids))
                        return "peerids: array expected";
                    for (let i = 0; i < message.peerids.length; ++i)
                        if (!$util.isString(message.peerids[i]))
                            return "peerids: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GetPeersWithAccountHashReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetPeersWithAccountHashReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetPeersWithAccountHashReply} GetPeersWithAccountHashReply
             */
            GetPeersWithAccountHashReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetPeersWithAccountHashReply)
                    return object;
                let message = new $root.dcnet.pb.GetPeersWithAccountHashReply();
                if (object.peerids) {
                    if (!Array.isArray(object.peerids))
                        throw TypeError(".dcnet.pb.GetPeersWithAccountHashReply.peerids: array expected");
                    message.peerids = [];
                    for (let i = 0; i < object.peerids.length; ++i)
                        message.peerids[i] = String(object.peerids[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetPeersWithAccountHashReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetPeersWithAccountHashReply
             * @static
             * @param {dcnet.pb.GetPeersWithAccountHashReply} message GetPeersWithAccountHashReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetPeersWithAccountHashReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.peerids = [];
                if (message.peerids && message.peerids.length) {
                    object.peerids = [];
                    for (let j = 0; j < message.peerids.length; ++j)
                        object.peerids[j] = message.peerids[j];
                }
                return object;
            };

            /**
             * Converts this GetPeersWithAccountHashReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetPeersWithAccountHashReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetPeersWithAccountHashReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetPeersWithAccountHashReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetPeersWithAccountHashReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetPeersWithAccountHashReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetPeersWithAccountHashReply";
            };

            return GetPeersWithAccountHashReply;
        })();

        pb.AccountDealBackupRequest = (function() {

            /**
             * Properties of an AccountDealBackupRequest.
             * @memberof dcnet.pb
             * @interface IAccountDealBackupRequest
             * @property {Uint8Array|null} [pubkey] AccountDealBackupRequest pubkey
             * @property {Uint8Array|null} [accountencrypt] AccountDealBackupRequest accountencrypt
             * @property {Uint8Array|null} [accounthashencrypt] AccountDealBackupRequest accounthashencrypt
             * @property {Uint8Array|null} [prikeyencrypt2] AccountDealBackupRequest prikeyencrypt2
             * @property {number|null} [blockheight] AccountDealBackupRequest blockheight
             * @property {Uint8Array|null} [randkeyencrypt] AccountDealBackupRequest randkeyencrypt
             * @property {Uint8Array|null} [loginkeyrandencrypt] AccountDealBackupRequest loginkeyrandencrypt
             * @property {Uint8Array|null} [peerid] AccountDealBackupRequest peerid
             * @property {Uint8Array|null} [signature] AccountDealBackupRequest signature
             * @property {Uint8Array|null} [vaccount] AccountDealBackupRequest vaccount
             */

            /**
             * Constructs a new AccountDealBackupRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AccountDealBackupRequest.
             * @implements IAccountDealBackupRequest
             * @constructor
             * @param {dcnet.pb.IAccountDealBackupRequest=} [properties] Properties to set
             */
            function AccountDealBackupRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AccountDealBackupRequest pubkey.
             * @member {Uint8Array} pubkey
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @instance
             */
            AccountDealBackupRequest.prototype.pubkey = $util.newBuffer([]);

            /**
             * AccountDealBackupRequest accountencrypt.
             * @member {Uint8Array} accountencrypt
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @instance
             */
            AccountDealBackupRequest.prototype.accountencrypt = $util.newBuffer([]);

            /**
             * AccountDealBackupRequest accounthashencrypt.
             * @member {Uint8Array} accounthashencrypt
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @instance
             */
            AccountDealBackupRequest.prototype.accounthashencrypt = $util.newBuffer([]);

            /**
             * AccountDealBackupRequest prikeyencrypt2.
             * @member {Uint8Array} prikeyencrypt2
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @instance
             */
            AccountDealBackupRequest.prototype.prikeyencrypt2 = $util.newBuffer([]);

            /**
             * AccountDealBackupRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @instance
             */
            AccountDealBackupRequest.prototype.blockheight = 0;

            /**
             * AccountDealBackupRequest randkeyencrypt.
             * @member {Uint8Array} randkeyencrypt
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @instance
             */
            AccountDealBackupRequest.prototype.randkeyencrypt = $util.newBuffer([]);

            /**
             * AccountDealBackupRequest loginkeyrandencrypt.
             * @member {Uint8Array} loginkeyrandencrypt
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @instance
             */
            AccountDealBackupRequest.prototype.loginkeyrandencrypt = $util.newBuffer([]);

            /**
             * AccountDealBackupRequest peerid.
             * @member {Uint8Array} peerid
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @instance
             */
            AccountDealBackupRequest.prototype.peerid = $util.newBuffer([]);

            /**
             * AccountDealBackupRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @instance
             */
            AccountDealBackupRequest.prototype.signature = $util.newBuffer([]);

            /**
             * AccountDealBackupRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @instance
             */
            AccountDealBackupRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new AccountDealBackupRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @static
             * @param {dcnet.pb.IAccountDealBackupRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AccountDealBackupRequest} AccountDealBackupRequest instance
             */
            AccountDealBackupRequest.create = function create(properties) {
                return new AccountDealBackupRequest(properties);
            };

            /**
             * Encodes the specified AccountDealBackupRequest message. Does not implicitly {@link dcnet.pb.AccountDealBackupRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @static
             * @param {dcnet.pb.IAccountDealBackupRequest} message AccountDealBackupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountDealBackupRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pubkey != null && Object.hasOwnProperty.call(message, "pubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pubkey);
                if (message.accountencrypt != null && Object.hasOwnProperty.call(message, "accountencrypt"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accountencrypt);
                if (message.accounthashencrypt != null && Object.hasOwnProperty.call(message, "accounthashencrypt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.accounthashencrypt);
                if (message.prikeyencrypt2 != null && Object.hasOwnProperty.call(message, "prikeyencrypt2"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.prikeyencrypt2);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.blockheight);
                if (message.randkeyencrypt != null && Object.hasOwnProperty.call(message, "randkeyencrypt"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.randkeyencrypt);
                if (message.loginkeyrandencrypt != null && Object.hasOwnProperty.call(message, "loginkeyrandencrypt"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.loginkeyrandencrypt);
                if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.peerid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified AccountDealBackupRequest message, length delimited. Does not implicitly {@link dcnet.pb.AccountDealBackupRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @static
             * @param {dcnet.pb.IAccountDealBackupRequest} message AccountDealBackupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountDealBackupRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AccountDealBackupRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AccountDealBackupRequest} AccountDealBackupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountDealBackupRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AccountDealBackupRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.pubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.accountencrypt = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.accounthashencrypt = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.prikeyencrypt2 = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.randkeyencrypt = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.loginkeyrandencrypt = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.peerid = reader.bytes();
                            break;
                        }
                    case 9: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 10: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AccountDealBackupRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AccountDealBackupRequest} AccountDealBackupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountDealBackupRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AccountDealBackupRequest message.
             * @function verify
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AccountDealBackupRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                    if (!(message.pubkey && typeof message.pubkey.length === "number" || $util.isString(message.pubkey)))
                        return "pubkey: buffer expected";
                if (message.accountencrypt != null && message.hasOwnProperty("accountencrypt"))
                    if (!(message.accountencrypt && typeof message.accountencrypt.length === "number" || $util.isString(message.accountencrypt)))
                        return "accountencrypt: buffer expected";
                if (message.accounthashencrypt != null && message.hasOwnProperty("accounthashencrypt"))
                    if (!(message.accounthashencrypt && typeof message.accounthashencrypt.length === "number" || $util.isString(message.accounthashencrypt)))
                        return "accounthashencrypt: buffer expected";
                if (message.prikeyencrypt2 != null && message.hasOwnProperty("prikeyencrypt2"))
                    if (!(message.prikeyencrypt2 && typeof message.prikeyencrypt2.length === "number" || $util.isString(message.prikeyencrypt2)))
                        return "prikeyencrypt2: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.randkeyencrypt != null && message.hasOwnProperty("randkeyencrypt"))
                    if (!(message.randkeyencrypt && typeof message.randkeyencrypt.length === "number" || $util.isString(message.randkeyencrypt)))
                        return "randkeyencrypt: buffer expected";
                if (message.loginkeyrandencrypt != null && message.hasOwnProperty("loginkeyrandencrypt"))
                    if (!(message.loginkeyrandencrypt && typeof message.loginkeyrandencrypt.length === "number" || $util.isString(message.loginkeyrandencrypt)))
                        return "loginkeyrandencrypt: buffer expected";
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                        return "peerid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates an AccountDealBackupRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AccountDealBackupRequest} AccountDealBackupRequest
             */
            AccountDealBackupRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AccountDealBackupRequest)
                    return object;
                let message = new $root.dcnet.pb.AccountDealBackupRequest();
                if (object.pubkey != null)
                    if (typeof object.pubkey === "string")
                        $util.base64.decode(object.pubkey, message.pubkey = $util.newBuffer($util.base64.length(object.pubkey)), 0);
                    else if (object.pubkey.length >= 0)
                        message.pubkey = object.pubkey;
                if (object.accountencrypt != null)
                    if (typeof object.accountencrypt === "string")
                        $util.base64.decode(object.accountencrypt, message.accountencrypt = $util.newBuffer($util.base64.length(object.accountencrypt)), 0);
                    else if (object.accountencrypt.length >= 0)
                        message.accountencrypt = object.accountencrypt;
                if (object.accounthashencrypt != null)
                    if (typeof object.accounthashencrypt === "string")
                        $util.base64.decode(object.accounthashencrypt, message.accounthashencrypt = $util.newBuffer($util.base64.length(object.accounthashencrypt)), 0);
                    else if (object.accounthashencrypt.length >= 0)
                        message.accounthashencrypt = object.accounthashencrypt;
                if (object.prikeyencrypt2 != null)
                    if (typeof object.prikeyencrypt2 === "string")
                        $util.base64.decode(object.prikeyencrypt2, message.prikeyencrypt2 = $util.newBuffer($util.base64.length(object.prikeyencrypt2)), 0);
                    else if (object.prikeyencrypt2.length >= 0)
                        message.prikeyencrypt2 = object.prikeyencrypt2;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.randkeyencrypt != null)
                    if (typeof object.randkeyencrypt === "string")
                        $util.base64.decode(object.randkeyencrypt, message.randkeyencrypt = $util.newBuffer($util.base64.length(object.randkeyencrypt)), 0);
                    else if (object.randkeyencrypt.length >= 0)
                        message.randkeyencrypt = object.randkeyencrypt;
                if (object.loginkeyrandencrypt != null)
                    if (typeof object.loginkeyrandencrypt === "string")
                        $util.base64.decode(object.loginkeyrandencrypt, message.loginkeyrandencrypt = $util.newBuffer($util.base64.length(object.loginkeyrandencrypt)), 0);
                    else if (object.loginkeyrandencrypt.length >= 0)
                        message.loginkeyrandencrypt = object.loginkeyrandencrypt;
                if (object.peerid != null)
                    if (typeof object.peerid === "string")
                        $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                    else if (object.peerid.length >= 0)
                        message.peerid = object.peerid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from an AccountDealBackupRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @static
             * @param {dcnet.pb.AccountDealBackupRequest} message AccountDealBackupRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AccountDealBackupRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.pubkey = "";
                    else {
                        object.pubkey = [];
                        if (options.bytes !== Array)
                            object.pubkey = $util.newBuffer(object.pubkey);
                    }
                    if (options.bytes === String)
                        object.accountencrypt = "";
                    else {
                        object.accountencrypt = [];
                        if (options.bytes !== Array)
                            object.accountencrypt = $util.newBuffer(object.accountencrypt);
                    }
                    if (options.bytes === String)
                        object.accounthashencrypt = "";
                    else {
                        object.accounthashencrypt = [];
                        if (options.bytes !== Array)
                            object.accounthashencrypt = $util.newBuffer(object.accounthashencrypt);
                    }
                    if (options.bytes === String)
                        object.prikeyencrypt2 = "";
                    else {
                        object.prikeyencrypt2 = [];
                        if (options.bytes !== Array)
                            object.prikeyencrypt2 = $util.newBuffer(object.prikeyencrypt2);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.randkeyencrypt = "";
                    else {
                        object.randkeyencrypt = [];
                        if (options.bytes !== Array)
                            object.randkeyencrypt = $util.newBuffer(object.randkeyencrypt);
                    }
                    if (options.bytes === String)
                        object.loginkeyrandencrypt = "";
                    else {
                        object.loginkeyrandencrypt = [];
                        if (options.bytes !== Array)
                            object.loginkeyrandencrypt = $util.newBuffer(object.loginkeyrandencrypt);
                    }
                    if (options.bytes === String)
                        object.peerid = "";
                    else {
                        object.peerid = [];
                        if (options.bytes !== Array)
                            object.peerid = $util.newBuffer(object.peerid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                    object.pubkey = options.bytes === String ? $util.base64.encode(message.pubkey, 0, message.pubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubkey) : message.pubkey;
                if (message.accountencrypt != null && message.hasOwnProperty("accountencrypt"))
                    object.accountencrypt = options.bytes === String ? $util.base64.encode(message.accountencrypt, 0, message.accountencrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountencrypt) : message.accountencrypt;
                if (message.accounthashencrypt != null && message.hasOwnProperty("accounthashencrypt"))
                    object.accounthashencrypt = options.bytes === String ? $util.base64.encode(message.accounthashencrypt, 0, message.accounthashencrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.accounthashencrypt) : message.accounthashencrypt;
                if (message.prikeyencrypt2 != null && message.hasOwnProperty("prikeyencrypt2"))
                    object.prikeyencrypt2 = options.bytes === String ? $util.base64.encode(message.prikeyencrypt2, 0, message.prikeyencrypt2.length) : options.bytes === Array ? Array.prototype.slice.call(message.prikeyencrypt2) : message.prikeyencrypt2;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.randkeyencrypt != null && message.hasOwnProperty("randkeyencrypt"))
                    object.randkeyencrypt = options.bytes === String ? $util.base64.encode(message.randkeyencrypt, 0, message.randkeyencrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.randkeyencrypt) : message.randkeyencrypt;
                if (message.loginkeyrandencrypt != null && message.hasOwnProperty("loginkeyrandencrypt"))
                    object.loginkeyrandencrypt = options.bytes === String ? $util.base64.encode(message.loginkeyrandencrypt, 0, message.loginkeyrandencrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.loginkeyrandencrypt) : message.loginkeyrandencrypt;
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this AccountDealBackupRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AccountDealBackupRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AccountDealBackupRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AccountDealBackupRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountDealBackupRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AccountDealBackupRequest";
            };

            return AccountDealBackupRequest;
        })();

        pb.AccountDealBackupReply = (function() {

            /**
             * Properties of an AccountDealBackupReply.
             * @memberof dcnet.pb
             * @interface IAccountDealBackupReply
             */

            /**
             * Constructs a new AccountDealBackupReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AccountDealBackupReply.
             * @implements IAccountDealBackupReply
             * @constructor
             * @param {dcnet.pb.IAccountDealBackupReply=} [properties] Properties to set
             */
            function AccountDealBackupReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AccountDealBackupReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AccountDealBackupReply
             * @static
             * @param {dcnet.pb.IAccountDealBackupReply=} [properties] Properties to set
             * @returns {dcnet.pb.AccountDealBackupReply} AccountDealBackupReply instance
             */
            AccountDealBackupReply.create = function create(properties) {
                return new AccountDealBackupReply(properties);
            };

            /**
             * Encodes the specified AccountDealBackupReply message. Does not implicitly {@link dcnet.pb.AccountDealBackupReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AccountDealBackupReply
             * @static
             * @param {dcnet.pb.IAccountDealBackupReply} message AccountDealBackupReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountDealBackupReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AccountDealBackupReply message, length delimited. Does not implicitly {@link dcnet.pb.AccountDealBackupReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AccountDealBackupReply
             * @static
             * @param {dcnet.pb.IAccountDealBackupReply} message AccountDealBackupReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountDealBackupReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AccountDealBackupReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AccountDealBackupReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AccountDealBackupReply} AccountDealBackupReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountDealBackupReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AccountDealBackupReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AccountDealBackupReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AccountDealBackupReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AccountDealBackupReply} AccountDealBackupReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountDealBackupReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AccountDealBackupReply message.
             * @function verify
             * @memberof dcnet.pb.AccountDealBackupReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AccountDealBackupReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AccountDealBackupReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AccountDealBackupReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AccountDealBackupReply} AccountDealBackupReply
             */
            AccountDealBackupReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AccountDealBackupReply)
                    return object;
                return new $root.dcnet.pb.AccountDealBackupReply();
            };

            /**
             * Creates a plain object from an AccountDealBackupReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AccountDealBackupReply
             * @static
             * @param {dcnet.pb.AccountDealBackupReply} message AccountDealBackupReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AccountDealBackupReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AccountDealBackupReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AccountDealBackupReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AccountDealBackupReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AccountDealBackupReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AccountDealBackupReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountDealBackupReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AccountDealBackupReply";
            };

            return AccountDealBackupReply;
        })();

        pb.GetHostIDRequest = (function() {

            /**
             * Properties of a GetHostIDRequest.
             * @memberof dcnet.pb
             * @interface IGetHostIDRequest
             */

            /**
             * Constructs a new GetHostIDRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetHostIDRequest.
             * @implements IGetHostIDRequest
             * @constructor
             * @param {dcnet.pb.IGetHostIDRequest=} [properties] Properties to set
             */
            function GetHostIDRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetHostIDRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetHostIDRequest
             * @static
             * @param {dcnet.pb.IGetHostIDRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetHostIDRequest} GetHostIDRequest instance
             */
            GetHostIDRequest.create = function create(properties) {
                return new GetHostIDRequest(properties);
            };

            /**
             * Encodes the specified GetHostIDRequest message. Does not implicitly {@link dcnet.pb.GetHostIDRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetHostIDRequest
             * @static
             * @param {dcnet.pb.IGetHostIDRequest} message GetHostIDRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHostIDRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetHostIDRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetHostIDRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetHostIDRequest
             * @static
             * @param {dcnet.pb.IGetHostIDRequest} message GetHostIDRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHostIDRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHostIDRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetHostIDRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetHostIDRequest} GetHostIDRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHostIDRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetHostIDRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHostIDRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetHostIDRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetHostIDRequest} GetHostIDRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHostIDRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHostIDRequest message.
             * @function verify
             * @memberof dcnet.pb.GetHostIDRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHostIDRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetHostIDRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetHostIDRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetHostIDRequest} GetHostIDRequest
             */
            GetHostIDRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetHostIDRequest)
                    return object;
                return new $root.dcnet.pb.GetHostIDRequest();
            };

            /**
             * Creates a plain object from a GetHostIDRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetHostIDRequest
             * @static
             * @param {dcnet.pb.GetHostIDRequest} message GetHostIDRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHostIDRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetHostIDRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetHostIDRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHostIDRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHostIDRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetHostIDRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHostIDRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetHostIDRequest";
            };

            return GetHostIDRequest;
        })();

        pb.GetHostIDReply = (function() {

            /**
             * Properties of a GetHostIDReply.
             * @memberof dcnet.pb
             * @interface IGetHostIDReply
             * @property {Uint8Array|null} [peerID] GetHostIDReply peerID
             * @property {Uint8Array|null} [reqAddr] GetHostIDReply reqAddr
             */

            /**
             * Constructs a new GetHostIDReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetHostIDReply.
             * @implements IGetHostIDReply
             * @constructor
             * @param {dcnet.pb.IGetHostIDReply=} [properties] Properties to set
             */
            function GetHostIDReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHostIDReply peerID.
             * @member {Uint8Array} peerID
             * @memberof dcnet.pb.GetHostIDReply
             * @instance
             */
            GetHostIDReply.prototype.peerID = $util.newBuffer([]);

            /**
             * GetHostIDReply reqAddr.
             * @member {Uint8Array} reqAddr
             * @memberof dcnet.pb.GetHostIDReply
             * @instance
             */
            GetHostIDReply.prototype.reqAddr = $util.newBuffer([]);

            /**
             * Creates a new GetHostIDReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetHostIDReply
             * @static
             * @param {dcnet.pb.IGetHostIDReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetHostIDReply} GetHostIDReply instance
             */
            GetHostIDReply.create = function create(properties) {
                return new GetHostIDReply(properties);
            };

            /**
             * Encodes the specified GetHostIDReply message. Does not implicitly {@link dcnet.pb.GetHostIDReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetHostIDReply
             * @static
             * @param {dcnet.pb.IGetHostIDReply} message GetHostIDReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHostIDReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peerID != null && Object.hasOwnProperty.call(message, "peerID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.peerID);
                if (message.reqAddr != null && Object.hasOwnProperty.call(message, "reqAddr"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.reqAddr);
                return writer;
            };

            /**
             * Encodes the specified GetHostIDReply message, length delimited. Does not implicitly {@link dcnet.pb.GetHostIDReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetHostIDReply
             * @static
             * @param {dcnet.pb.IGetHostIDReply} message GetHostIDReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHostIDReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHostIDReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetHostIDReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetHostIDReply} GetHostIDReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHostIDReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetHostIDReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.peerID = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.reqAddr = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHostIDReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetHostIDReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetHostIDReply} GetHostIDReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHostIDReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHostIDReply message.
             * @function verify
             * @memberof dcnet.pb.GetHostIDReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHostIDReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peerID != null && message.hasOwnProperty("peerID"))
                    if (!(message.peerID && typeof message.peerID.length === "number" || $util.isString(message.peerID)))
                        return "peerID: buffer expected";
                if (message.reqAddr != null && message.hasOwnProperty("reqAddr"))
                    if (!(message.reqAddr && typeof message.reqAddr.length === "number" || $util.isString(message.reqAddr)))
                        return "reqAddr: buffer expected";
                return null;
            };

            /**
             * Creates a GetHostIDReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetHostIDReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetHostIDReply} GetHostIDReply
             */
            GetHostIDReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetHostIDReply)
                    return object;
                let message = new $root.dcnet.pb.GetHostIDReply();
                if (object.peerID != null)
                    if (typeof object.peerID === "string")
                        $util.base64.decode(object.peerID, message.peerID = $util.newBuffer($util.base64.length(object.peerID)), 0);
                    else if (object.peerID.length >= 0)
                        message.peerID = object.peerID;
                if (object.reqAddr != null)
                    if (typeof object.reqAddr === "string")
                        $util.base64.decode(object.reqAddr, message.reqAddr = $util.newBuffer($util.base64.length(object.reqAddr)), 0);
                    else if (object.reqAddr.length >= 0)
                        message.reqAddr = object.reqAddr;
                return message;
            };

            /**
             * Creates a plain object from a GetHostIDReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetHostIDReply
             * @static
             * @param {dcnet.pb.GetHostIDReply} message GetHostIDReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHostIDReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.peerID = "";
                    else {
                        object.peerID = [];
                        if (options.bytes !== Array)
                            object.peerID = $util.newBuffer(object.peerID);
                    }
                    if (options.bytes === String)
                        object.reqAddr = "";
                    else {
                        object.reqAddr = [];
                        if (options.bytes !== Array)
                            object.reqAddr = $util.newBuffer(object.reqAddr);
                    }
                }
                if (message.peerID != null && message.hasOwnProperty("peerID"))
                    object.peerID = options.bytes === String ? $util.base64.encode(message.peerID, 0, message.peerID.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerID) : message.peerID;
                if (message.reqAddr != null && message.hasOwnProperty("reqAddr"))
                    object.reqAddr = options.bytes === String ? $util.base64.encode(message.reqAddr, 0, message.reqAddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.reqAddr) : message.reqAddr;
                return object;
            };

            /**
             * Converts this GetHostIDReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetHostIDReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHostIDReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHostIDReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetHostIDReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHostIDReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetHostIDReply";
            };

            return GetHostIDReply;
        })();

        pb.ReportLocalMultilAddrRequest = (function() {

            /**
             * Properties of a ReportLocalMultilAddrRequest.
             * @memberof dcnet.pb
             * @interface IReportLocalMultilAddrRequest
             * @property {string|null} [addr] ReportLocalMultilAddrRequest addr
             */

            /**
             * Constructs a new ReportLocalMultilAddrRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a ReportLocalMultilAddrRequest.
             * @implements IReportLocalMultilAddrRequest
             * @constructor
             * @param {dcnet.pb.IReportLocalMultilAddrRequest=} [properties] Properties to set
             */
            function ReportLocalMultilAddrRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReportLocalMultilAddrRequest addr.
             * @member {string} addr
             * @memberof dcnet.pb.ReportLocalMultilAddrRequest
             * @instance
             */
            ReportLocalMultilAddrRequest.prototype.addr = "";

            /**
             * Creates a new ReportLocalMultilAddrRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ReportLocalMultilAddrRequest
             * @static
             * @param {dcnet.pb.IReportLocalMultilAddrRequest=} [properties] Properties to set
             * @returns {dcnet.pb.ReportLocalMultilAddrRequest} ReportLocalMultilAddrRequest instance
             */
            ReportLocalMultilAddrRequest.create = function create(properties) {
                return new ReportLocalMultilAddrRequest(properties);
            };

            /**
             * Encodes the specified ReportLocalMultilAddrRequest message. Does not implicitly {@link dcnet.pb.ReportLocalMultilAddrRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ReportLocalMultilAddrRequest
             * @static
             * @param {dcnet.pb.IReportLocalMultilAddrRequest} message ReportLocalMultilAddrRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportLocalMultilAddrRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.addr != null && Object.hasOwnProperty.call(message, "addr"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.addr);
                return writer;
            };

            /**
             * Encodes the specified ReportLocalMultilAddrRequest message, length delimited. Does not implicitly {@link dcnet.pb.ReportLocalMultilAddrRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ReportLocalMultilAddrRequest
             * @static
             * @param {dcnet.pb.IReportLocalMultilAddrRequest} message ReportLocalMultilAddrRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportLocalMultilAddrRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReportLocalMultilAddrRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ReportLocalMultilAddrRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ReportLocalMultilAddrRequest} ReportLocalMultilAddrRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportLocalMultilAddrRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ReportLocalMultilAddrRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.addr = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReportLocalMultilAddrRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ReportLocalMultilAddrRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ReportLocalMultilAddrRequest} ReportLocalMultilAddrRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportLocalMultilAddrRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReportLocalMultilAddrRequest message.
             * @function verify
             * @memberof dcnet.pb.ReportLocalMultilAddrRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReportLocalMultilAddrRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.addr != null && message.hasOwnProperty("addr"))
                    if (!$util.isString(message.addr))
                        return "addr: string expected";
                return null;
            };

            /**
             * Creates a ReportLocalMultilAddrRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ReportLocalMultilAddrRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ReportLocalMultilAddrRequest} ReportLocalMultilAddrRequest
             */
            ReportLocalMultilAddrRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ReportLocalMultilAddrRequest)
                    return object;
                let message = new $root.dcnet.pb.ReportLocalMultilAddrRequest();
                if (object.addr != null)
                    message.addr = String(object.addr);
                return message;
            };

            /**
             * Creates a plain object from a ReportLocalMultilAddrRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ReportLocalMultilAddrRequest
             * @static
             * @param {dcnet.pb.ReportLocalMultilAddrRequest} message ReportLocalMultilAddrRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReportLocalMultilAddrRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.addr = "";
                if (message.addr != null && message.hasOwnProperty("addr"))
                    object.addr = message.addr;
                return object;
            };

            /**
             * Converts this ReportLocalMultilAddrRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ReportLocalMultilAddrRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReportLocalMultilAddrRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReportLocalMultilAddrRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.ReportLocalMultilAddrRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReportLocalMultilAddrRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ReportLocalMultilAddrRequest";
            };

            return ReportLocalMultilAddrRequest;
        })();

        pb.ReportLocalMultilAddrReply = (function() {

            /**
             * Properties of a ReportLocalMultilAddrReply.
             * @memberof dcnet.pb
             * @interface IReportLocalMultilAddrReply
             */

            /**
             * Constructs a new ReportLocalMultilAddrReply.
             * @memberof dcnet.pb
             * @classdesc Represents a ReportLocalMultilAddrReply.
             * @implements IReportLocalMultilAddrReply
             * @constructor
             * @param {dcnet.pb.IReportLocalMultilAddrReply=} [properties] Properties to set
             */
            function ReportLocalMultilAddrReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ReportLocalMultilAddrReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ReportLocalMultilAddrReply
             * @static
             * @param {dcnet.pb.IReportLocalMultilAddrReply=} [properties] Properties to set
             * @returns {dcnet.pb.ReportLocalMultilAddrReply} ReportLocalMultilAddrReply instance
             */
            ReportLocalMultilAddrReply.create = function create(properties) {
                return new ReportLocalMultilAddrReply(properties);
            };

            /**
             * Encodes the specified ReportLocalMultilAddrReply message. Does not implicitly {@link dcnet.pb.ReportLocalMultilAddrReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ReportLocalMultilAddrReply
             * @static
             * @param {dcnet.pb.IReportLocalMultilAddrReply} message ReportLocalMultilAddrReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportLocalMultilAddrReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ReportLocalMultilAddrReply message, length delimited. Does not implicitly {@link dcnet.pb.ReportLocalMultilAddrReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ReportLocalMultilAddrReply
             * @static
             * @param {dcnet.pb.IReportLocalMultilAddrReply} message ReportLocalMultilAddrReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportLocalMultilAddrReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReportLocalMultilAddrReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ReportLocalMultilAddrReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ReportLocalMultilAddrReply} ReportLocalMultilAddrReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportLocalMultilAddrReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ReportLocalMultilAddrReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReportLocalMultilAddrReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ReportLocalMultilAddrReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ReportLocalMultilAddrReply} ReportLocalMultilAddrReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportLocalMultilAddrReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReportLocalMultilAddrReply message.
             * @function verify
             * @memberof dcnet.pb.ReportLocalMultilAddrReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReportLocalMultilAddrReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ReportLocalMultilAddrReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ReportLocalMultilAddrReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ReportLocalMultilAddrReply} ReportLocalMultilAddrReply
             */
            ReportLocalMultilAddrReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ReportLocalMultilAddrReply)
                    return object;
                return new $root.dcnet.pb.ReportLocalMultilAddrReply();
            };

            /**
             * Creates a plain object from a ReportLocalMultilAddrReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ReportLocalMultilAddrReply
             * @static
             * @param {dcnet.pb.ReportLocalMultilAddrReply} message ReportLocalMultilAddrReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReportLocalMultilAddrReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ReportLocalMultilAddrReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ReportLocalMultilAddrReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReportLocalMultilAddrReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReportLocalMultilAddrReply
             * @function getTypeUrl
             * @memberof dcnet.pb.ReportLocalMultilAddrReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReportLocalMultilAddrReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ReportLocalMultilAddrReply";
            };

            return ReportLocalMultilAddrReply;
        })();

        pb.GetTokenRequest = (function() {

            /**
             * Properties of a GetTokenRequest.
             * @memberof dcnet.pb
             * @interface IGetTokenRequest
             * @property {string|null} [key] GetTokenRequest key
             * @property {Uint8Array|null} [signature] GetTokenRequest signature
             */

            /**
             * Constructs a new GetTokenRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetTokenRequest.
             * @implements IGetTokenRequest
             * @constructor
             * @param {dcnet.pb.IGetTokenRequest=} [properties] Properties to set
             */
            function GetTokenRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetTokenRequest key.
             * @member {string|null|undefined} key
             * @memberof dcnet.pb.GetTokenRequest
             * @instance
             */
            GetTokenRequest.prototype.key = null;

            /**
             * GetTokenRequest signature.
             * @member {Uint8Array|null|undefined} signature
             * @memberof dcnet.pb.GetTokenRequest
             * @instance
             */
            GetTokenRequest.prototype.signature = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetTokenRequest payload.
             * @member {"key"|"signature"|undefined} payload
             * @memberof dcnet.pb.GetTokenRequest
             * @instance
             */
            Object.defineProperty(GetTokenRequest.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["key", "signature"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetTokenRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetTokenRequest
             * @static
             * @param {dcnet.pb.IGetTokenRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetTokenRequest} GetTokenRequest instance
             */
            GetTokenRequest.create = function create(properties) {
                return new GetTokenRequest(properties);
            };

            /**
             * Encodes the specified GetTokenRequest message. Does not implicitly {@link dcnet.pb.GetTokenRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetTokenRequest
             * @static
             * @param {dcnet.pb.IGetTokenRequest} message GetTokenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTokenRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified GetTokenRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetTokenRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetTokenRequest
             * @static
             * @param {dcnet.pb.IGetTokenRequest} message GetTokenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetTokenRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetTokenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetTokenRequest} GetTokenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTokenRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetTokenRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.string();
                            break;
                        }
                    case 2: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetTokenRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetTokenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetTokenRequest} GetTokenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTokenRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetTokenRequest message.
             * @function verify
             * @memberof dcnet.pb.GetTokenRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetTokenRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.key != null && message.hasOwnProperty("key")) {
                    properties.payload = 1;
                    if (!$util.isString(message.key))
                        return "key: string expected";
                }
                if (message.signature != null && message.hasOwnProperty("signature")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                }
                return null;
            };

            /**
             * Creates a GetTokenRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetTokenRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetTokenRequest} GetTokenRequest
             */
            GetTokenRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetTokenRequest)
                    return object;
                let message = new $root.dcnet.pb.GetTokenRequest();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a GetTokenRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetTokenRequest
             * @static
             * @param {dcnet.pb.GetTokenRequest} message GetTokenRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetTokenRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.key != null && message.hasOwnProperty("key")) {
                    object.key = message.key;
                    if (options.oneofs)
                        object.payload = "key";
                }
                if (message.signature != null && message.hasOwnProperty("signature")) {
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                    if (options.oneofs)
                        object.payload = "signature";
                }
                return object;
            };

            /**
             * Converts this GetTokenRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetTokenRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetTokenRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetTokenRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetTokenRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetTokenRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetTokenRequest";
            };

            return GetTokenRequest;
        })();

        pb.GetTokenReply = (function() {

            /**
             * Properties of a GetTokenReply.
             * @memberof dcnet.pb
             * @interface IGetTokenReply
             * @property {Uint8Array|null} [challenge] GetTokenReply challenge
             * @property {string|null} [token] GetTokenReply token
             */

            /**
             * Constructs a new GetTokenReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetTokenReply.
             * @implements IGetTokenReply
             * @constructor
             * @param {dcnet.pb.IGetTokenReply=} [properties] Properties to set
             */
            function GetTokenReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetTokenReply challenge.
             * @member {Uint8Array|null|undefined} challenge
             * @memberof dcnet.pb.GetTokenReply
             * @instance
             */
            GetTokenReply.prototype.challenge = null;

            /**
             * GetTokenReply token.
             * @member {string|null|undefined} token
             * @memberof dcnet.pb.GetTokenReply
             * @instance
             */
            GetTokenReply.prototype.token = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetTokenReply payload.
             * @member {"challenge"|"token"|undefined} payload
             * @memberof dcnet.pb.GetTokenReply
             * @instance
             */
            Object.defineProperty(GetTokenReply.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["challenge", "token"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetTokenReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetTokenReply
             * @static
             * @param {dcnet.pb.IGetTokenReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetTokenReply} GetTokenReply instance
             */
            GetTokenReply.create = function create(properties) {
                return new GetTokenReply(properties);
            };

            /**
             * Encodes the specified GetTokenReply message. Does not implicitly {@link dcnet.pb.GetTokenReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetTokenReply
             * @static
             * @param {dcnet.pb.IGetTokenReply} message GetTokenReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTokenReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.challenge != null && Object.hasOwnProperty.call(message, "challenge"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.challenge);
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
                return writer;
            };

            /**
             * Encodes the specified GetTokenReply message, length delimited. Does not implicitly {@link dcnet.pb.GetTokenReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetTokenReply
             * @static
             * @param {dcnet.pb.IGetTokenReply} message GetTokenReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTokenReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetTokenReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetTokenReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetTokenReply} GetTokenReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTokenReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetTokenReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.challenge = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.token = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetTokenReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetTokenReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetTokenReply} GetTokenReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTokenReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetTokenReply message.
             * @function verify
             * @memberof dcnet.pb.GetTokenReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetTokenReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.challenge != null && message.hasOwnProperty("challenge")) {
                    properties.payload = 1;
                    if (!(message.challenge && typeof message.challenge.length === "number" || $util.isString(message.challenge)))
                        return "challenge: buffer expected";
                }
                if (message.token != null && message.hasOwnProperty("token")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    if (!$util.isString(message.token))
                        return "token: string expected";
                }
                return null;
            };

            /**
             * Creates a GetTokenReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetTokenReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetTokenReply} GetTokenReply
             */
            GetTokenReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetTokenReply)
                    return object;
                let message = new $root.dcnet.pb.GetTokenReply();
                if (object.challenge != null)
                    if (typeof object.challenge === "string")
                        $util.base64.decode(object.challenge, message.challenge = $util.newBuffer($util.base64.length(object.challenge)), 0);
                    else if (object.challenge.length >= 0)
                        message.challenge = object.challenge;
                if (object.token != null)
                    message.token = String(object.token);
                return message;
            };

            /**
             * Creates a plain object from a GetTokenReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetTokenReply
             * @static
             * @param {dcnet.pb.GetTokenReply} message GetTokenReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetTokenReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.challenge != null && message.hasOwnProperty("challenge")) {
                    object.challenge = options.bytes === String ? $util.base64.encode(message.challenge, 0, message.challenge.length) : options.bytes === Array ? Array.prototype.slice.call(message.challenge) : message.challenge;
                    if (options.oneofs)
                        object.payload = "challenge";
                }
                if (message.token != null && message.hasOwnProperty("token")) {
                    object.token = message.token;
                    if (options.oneofs)
                        object.payload = "token";
                }
                return object;
            };

            /**
             * Converts this GetTokenReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetTokenReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetTokenReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetTokenReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetTokenReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetTokenReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetTokenReply";
            };

            return GetTokenReply;
        })();

        pb.CreateThreadRequest = (function() {

            /**
             * Properties of a CreateThreadRequest.
             * @memberof dcnet.pb
             * @interface ICreateThreadRequest
             * @property {Uint8Array|null} [threadID] CreateThreadRequest threadID
             * @property {dcnet.pb.IKeys|null} [keys] CreateThreadRequest keys
             * @property {number|null} [blockheight] CreateThreadRequest blockheight
             * @property {Uint8Array|null} [signature] CreateThreadRequest signature
             * @property {Uint8Array|null} [vaccount] CreateThreadRequest vaccount
             */

            /**
             * Constructs a new CreateThreadRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a CreateThreadRequest.
             * @implements ICreateThreadRequest
             * @constructor
             * @param {dcnet.pb.ICreateThreadRequest=} [properties] Properties to set
             */
            function CreateThreadRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateThreadRequest threadID.
             * @member {Uint8Array} threadID
             * @memberof dcnet.pb.CreateThreadRequest
             * @instance
             */
            CreateThreadRequest.prototype.threadID = $util.newBuffer([]);

            /**
             * CreateThreadRequest keys.
             * @member {dcnet.pb.IKeys|null|undefined} keys
             * @memberof dcnet.pb.CreateThreadRequest
             * @instance
             */
            CreateThreadRequest.prototype.keys = null;

            /**
             * CreateThreadRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.CreateThreadRequest
             * @instance
             */
            CreateThreadRequest.prototype.blockheight = 0;

            /**
             * CreateThreadRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.CreateThreadRequest
             * @instance
             */
            CreateThreadRequest.prototype.signature = $util.newBuffer([]);

            /**
             * CreateThreadRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.CreateThreadRequest
             * @instance
             */
            CreateThreadRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new CreateThreadRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.CreateThreadRequest
             * @static
             * @param {dcnet.pb.ICreateThreadRequest=} [properties] Properties to set
             * @returns {dcnet.pb.CreateThreadRequest} CreateThreadRequest instance
             */
            CreateThreadRequest.create = function create(properties) {
                return new CreateThreadRequest(properties);
            };

            /**
             * Encodes the specified CreateThreadRequest message. Does not implicitly {@link dcnet.pb.CreateThreadRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.CreateThreadRequest
             * @static
             * @param {dcnet.pb.ICreateThreadRequest} message CreateThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateThreadRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadID != null && Object.hasOwnProperty.call(message, "threadID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.threadID);
                if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
                    $root.dcnet.pb.Keys.encode(message.keys, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.blockheight);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified CreateThreadRequest message, length delimited. Does not implicitly {@link dcnet.pb.CreateThreadRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.CreateThreadRequest
             * @static
             * @param {dcnet.pb.ICreateThreadRequest} message CreateThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateThreadRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateThreadRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.CreateThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.CreateThreadRequest} CreateThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateThreadRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.CreateThreadRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadID = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.keys = $root.dcnet.pb.Keys.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateThreadRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.CreateThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.CreateThreadRequest} CreateThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateThreadRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateThreadRequest message.
             * @function verify
             * @memberof dcnet.pb.CreateThreadRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateThreadRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    if (!(message.threadID && typeof message.threadID.length === "number" || $util.isString(message.threadID)))
                        return "threadID: buffer expected";
                if (message.keys != null && message.hasOwnProperty("keys")) {
                    let error = $root.dcnet.pb.Keys.verify(message.keys);
                    if (error)
                        return "keys." + error;
                }
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a CreateThreadRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.CreateThreadRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.CreateThreadRequest} CreateThreadRequest
             */
            CreateThreadRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.CreateThreadRequest)
                    return object;
                let message = new $root.dcnet.pb.CreateThreadRequest();
                if (object.threadID != null)
                    if (typeof object.threadID === "string")
                        $util.base64.decode(object.threadID, message.threadID = $util.newBuffer($util.base64.length(object.threadID)), 0);
                    else if (object.threadID.length >= 0)
                        message.threadID = object.threadID;
                if (object.keys != null) {
                    if (typeof object.keys !== "object")
                        throw TypeError(".dcnet.pb.CreateThreadRequest.keys: object expected");
                    message.keys = $root.dcnet.pb.Keys.fromObject(object.keys);
                }
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a CreateThreadRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.CreateThreadRequest
             * @static
             * @param {dcnet.pb.CreateThreadRequest} message CreateThreadRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateThreadRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.threadID = "";
                    else {
                        object.threadID = [];
                        if (options.bytes !== Array)
                            object.threadID = $util.newBuffer(object.threadID);
                    }
                    object.keys = null;
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    object.threadID = options.bytes === String ? $util.base64.encode(message.threadID, 0, message.threadID.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadID) : message.threadID;
                if (message.keys != null && message.hasOwnProperty("keys"))
                    object.keys = $root.dcnet.pb.Keys.toObject(message.keys, options);
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this CreateThreadRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.CreateThreadRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateThreadRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateThreadRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.CreateThreadRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateThreadRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.CreateThreadRequest";
            };

            return CreateThreadRequest;
        })();

        pb.Keys = (function() {

            /**
             * Properties of a Keys.
             * @memberof dcnet.pb
             * @interface IKeys
             * @property {Uint8Array|null} [threadKeyEncrpt] Keys threadKeyEncrpt
             * @property {Uint8Array|null} [logKeyEncrpt] Keys logKeyEncrpt
             */

            /**
             * Constructs a new Keys.
             * @memberof dcnet.pb
             * @classdesc Represents a Keys.
             * @implements IKeys
             * @constructor
             * @param {dcnet.pb.IKeys=} [properties] Properties to set
             */
            function Keys(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Keys threadKeyEncrpt.
             * @member {Uint8Array} threadKeyEncrpt
             * @memberof dcnet.pb.Keys
             * @instance
             */
            Keys.prototype.threadKeyEncrpt = $util.newBuffer([]);

            /**
             * Keys logKeyEncrpt.
             * @member {Uint8Array} logKeyEncrpt
             * @memberof dcnet.pb.Keys
             * @instance
             */
            Keys.prototype.logKeyEncrpt = $util.newBuffer([]);

            /**
             * Creates a new Keys instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.Keys
             * @static
             * @param {dcnet.pb.IKeys=} [properties] Properties to set
             * @returns {dcnet.pb.Keys} Keys instance
             */
            Keys.create = function create(properties) {
                return new Keys(properties);
            };

            /**
             * Encodes the specified Keys message. Does not implicitly {@link dcnet.pb.Keys.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.Keys
             * @static
             * @param {dcnet.pb.IKeys} message Keys message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Keys.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadKeyEncrpt != null && Object.hasOwnProperty.call(message, "threadKeyEncrpt"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.threadKeyEncrpt);
                if (message.logKeyEncrpt != null && Object.hasOwnProperty.call(message, "logKeyEncrpt"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.logKeyEncrpt);
                return writer;
            };

            /**
             * Encodes the specified Keys message, length delimited. Does not implicitly {@link dcnet.pb.Keys.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.Keys
             * @static
             * @param {dcnet.pb.IKeys} message Keys message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Keys.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Keys message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.Keys
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.Keys} Keys
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Keys.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.Keys();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadKeyEncrpt = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.logKeyEncrpt = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Keys message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.Keys
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.Keys} Keys
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Keys.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Keys message.
             * @function verify
             * @memberof dcnet.pb.Keys
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Keys.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadKeyEncrpt != null && message.hasOwnProperty("threadKeyEncrpt"))
                    if (!(message.threadKeyEncrpt && typeof message.threadKeyEncrpt.length === "number" || $util.isString(message.threadKeyEncrpt)))
                        return "threadKeyEncrpt: buffer expected";
                if (message.logKeyEncrpt != null && message.hasOwnProperty("logKeyEncrpt"))
                    if (!(message.logKeyEncrpt && typeof message.logKeyEncrpt.length === "number" || $util.isString(message.logKeyEncrpt)))
                        return "logKeyEncrpt: buffer expected";
                return null;
            };

            /**
             * Creates a Keys message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.Keys
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.Keys} Keys
             */
            Keys.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.Keys)
                    return object;
                let message = new $root.dcnet.pb.Keys();
                if (object.threadKeyEncrpt != null)
                    if (typeof object.threadKeyEncrpt === "string")
                        $util.base64.decode(object.threadKeyEncrpt, message.threadKeyEncrpt = $util.newBuffer($util.base64.length(object.threadKeyEncrpt)), 0);
                    else if (object.threadKeyEncrpt.length >= 0)
                        message.threadKeyEncrpt = object.threadKeyEncrpt;
                if (object.logKeyEncrpt != null)
                    if (typeof object.logKeyEncrpt === "string")
                        $util.base64.decode(object.logKeyEncrpt, message.logKeyEncrpt = $util.newBuffer($util.base64.length(object.logKeyEncrpt)), 0);
                    else if (object.logKeyEncrpt.length >= 0)
                        message.logKeyEncrpt = object.logKeyEncrpt;
                return message;
            };

            /**
             * Creates a plain object from a Keys message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.Keys
             * @static
             * @param {dcnet.pb.Keys} message Keys
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Keys.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.threadKeyEncrpt = "";
                    else {
                        object.threadKeyEncrpt = [];
                        if (options.bytes !== Array)
                            object.threadKeyEncrpt = $util.newBuffer(object.threadKeyEncrpt);
                    }
                    if (options.bytes === String)
                        object.logKeyEncrpt = "";
                    else {
                        object.logKeyEncrpt = [];
                        if (options.bytes !== Array)
                            object.logKeyEncrpt = $util.newBuffer(object.logKeyEncrpt);
                    }
                }
                if (message.threadKeyEncrpt != null && message.hasOwnProperty("threadKeyEncrpt"))
                    object.threadKeyEncrpt = options.bytes === String ? $util.base64.encode(message.threadKeyEncrpt, 0, message.threadKeyEncrpt.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadKeyEncrpt) : message.threadKeyEncrpt;
                if (message.logKeyEncrpt != null && message.hasOwnProperty("logKeyEncrpt"))
                    object.logKeyEncrpt = options.bytes === String ? $util.base64.encode(message.logKeyEncrpt, 0, message.logKeyEncrpt.length) : options.bytes === Array ? Array.prototype.slice.call(message.logKeyEncrpt) : message.logKeyEncrpt;
                return object;
            };

            /**
             * Converts this Keys to JSON.
             * @function toJSON
             * @memberof dcnet.pb.Keys
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Keys.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Keys
             * @function getTypeUrl
             * @memberof dcnet.pb.Keys
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Keys.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.Keys";
            };

            return Keys;
        })();

        pb.ThreadInfoReply = (function() {

            /**
             * Properties of a ThreadInfoReply.
             * @memberof dcnet.pb
             * @interface IThreadInfoReply
             * @property {Uint8Array|null} [threadID] ThreadInfoReply threadID
             * @property {Array.<dcnet.pb.ILogInfo>|null} [logs] ThreadInfoReply logs
             * @property {Array.<Uint8Array>|null} [addrs] ThreadInfoReply addrs
             */

            /**
             * Constructs a new ThreadInfoReply.
             * @memberof dcnet.pb
             * @classdesc Represents a ThreadInfoReply.
             * @implements IThreadInfoReply
             * @constructor
             * @param {dcnet.pb.IThreadInfoReply=} [properties] Properties to set
             */
            function ThreadInfoReply(properties) {
                this.logs = [];
                this.addrs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ThreadInfoReply threadID.
             * @member {Uint8Array} threadID
             * @memberof dcnet.pb.ThreadInfoReply
             * @instance
             */
            ThreadInfoReply.prototype.threadID = $util.newBuffer([]);

            /**
             * ThreadInfoReply logs.
             * @member {Array.<dcnet.pb.ILogInfo>} logs
             * @memberof dcnet.pb.ThreadInfoReply
             * @instance
             */
            ThreadInfoReply.prototype.logs = $util.emptyArray;

            /**
             * ThreadInfoReply addrs.
             * @member {Array.<Uint8Array>} addrs
             * @memberof dcnet.pb.ThreadInfoReply
             * @instance
             */
            ThreadInfoReply.prototype.addrs = $util.emptyArray;

            /**
             * Creates a new ThreadInfoReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ThreadInfoReply
             * @static
             * @param {dcnet.pb.IThreadInfoReply=} [properties] Properties to set
             * @returns {dcnet.pb.ThreadInfoReply} ThreadInfoReply instance
             */
            ThreadInfoReply.create = function create(properties) {
                return new ThreadInfoReply(properties);
            };

            /**
             * Encodes the specified ThreadInfoReply message. Does not implicitly {@link dcnet.pb.ThreadInfoReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ThreadInfoReply
             * @static
             * @param {dcnet.pb.IThreadInfoReply} message ThreadInfoReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadInfoReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadID != null && Object.hasOwnProperty.call(message, "threadID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.threadID);
                if (message.logs != null && message.logs.length)
                    for (let i = 0; i < message.logs.length; ++i)
                        $root.dcnet.pb.LogInfo.encode(message.logs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.addrs != null && message.addrs.length)
                    for (let i = 0; i < message.addrs.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.addrs[i]);
                return writer;
            };

            /**
             * Encodes the specified ThreadInfoReply message, length delimited. Does not implicitly {@link dcnet.pb.ThreadInfoReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ThreadInfoReply
             * @static
             * @param {dcnet.pb.IThreadInfoReply} message ThreadInfoReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadInfoReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ThreadInfoReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ThreadInfoReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ThreadInfoReply} ThreadInfoReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadInfoReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ThreadInfoReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadID = reader.bytes();
                            break;
                        }
                    case 3: {
                            if (!(message.logs && message.logs.length))
                                message.logs = [];
                            message.logs.push($root.dcnet.pb.LogInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            if (!(message.addrs && message.addrs.length))
                                message.addrs = [];
                            message.addrs.push(reader.bytes());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ThreadInfoReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ThreadInfoReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ThreadInfoReply} ThreadInfoReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadInfoReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ThreadInfoReply message.
             * @function verify
             * @memberof dcnet.pb.ThreadInfoReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ThreadInfoReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    if (!(message.threadID && typeof message.threadID.length === "number" || $util.isString(message.threadID)))
                        return "threadID: buffer expected";
                if (message.logs != null && message.hasOwnProperty("logs")) {
                    if (!Array.isArray(message.logs))
                        return "logs: array expected";
                    for (let i = 0; i < message.logs.length; ++i) {
                        let error = $root.dcnet.pb.LogInfo.verify(message.logs[i]);
                        if (error)
                            return "logs." + error;
                    }
                }
                if (message.addrs != null && message.hasOwnProperty("addrs")) {
                    if (!Array.isArray(message.addrs))
                        return "addrs: array expected";
                    for (let i = 0; i < message.addrs.length; ++i)
                        if (!(message.addrs[i] && typeof message.addrs[i].length === "number" || $util.isString(message.addrs[i])))
                            return "addrs: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates a ThreadInfoReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ThreadInfoReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ThreadInfoReply} ThreadInfoReply
             */
            ThreadInfoReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ThreadInfoReply)
                    return object;
                let message = new $root.dcnet.pb.ThreadInfoReply();
                if (object.threadID != null)
                    if (typeof object.threadID === "string")
                        $util.base64.decode(object.threadID, message.threadID = $util.newBuffer($util.base64.length(object.threadID)), 0);
                    else if (object.threadID.length >= 0)
                        message.threadID = object.threadID;
                if (object.logs) {
                    if (!Array.isArray(object.logs))
                        throw TypeError(".dcnet.pb.ThreadInfoReply.logs: array expected");
                    message.logs = [];
                    for (let i = 0; i < object.logs.length; ++i) {
                        if (typeof object.logs[i] !== "object")
                            throw TypeError(".dcnet.pb.ThreadInfoReply.logs: object expected");
                        message.logs[i] = $root.dcnet.pb.LogInfo.fromObject(object.logs[i]);
                    }
                }
                if (object.addrs) {
                    if (!Array.isArray(object.addrs))
                        throw TypeError(".dcnet.pb.ThreadInfoReply.addrs: array expected");
                    message.addrs = [];
                    for (let i = 0; i < object.addrs.length; ++i)
                        if (typeof object.addrs[i] === "string")
                            $util.base64.decode(object.addrs[i], message.addrs[i] = $util.newBuffer($util.base64.length(object.addrs[i])), 0);
                        else if (object.addrs[i].length >= 0)
                            message.addrs[i] = object.addrs[i];
                }
                return message;
            };

            /**
             * Creates a plain object from a ThreadInfoReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ThreadInfoReply
             * @static
             * @param {dcnet.pb.ThreadInfoReply} message ThreadInfoReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ThreadInfoReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.logs = [];
                    object.addrs = [];
                }
                if (options.defaults)
                    if (options.bytes === String)
                        object.threadID = "";
                    else {
                        object.threadID = [];
                        if (options.bytes !== Array)
                            object.threadID = $util.newBuffer(object.threadID);
                    }
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    object.threadID = options.bytes === String ? $util.base64.encode(message.threadID, 0, message.threadID.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadID) : message.threadID;
                if (message.logs && message.logs.length) {
                    object.logs = [];
                    for (let j = 0; j < message.logs.length; ++j)
                        object.logs[j] = $root.dcnet.pb.LogInfo.toObject(message.logs[j], options);
                }
                if (message.addrs && message.addrs.length) {
                    object.addrs = [];
                    for (let j = 0; j < message.addrs.length; ++j)
                        object.addrs[j] = options.bytes === String ? $util.base64.encode(message.addrs[j], 0, message.addrs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.addrs[j]) : message.addrs[j];
                }
                return object;
            };

            /**
             * Converts this ThreadInfoReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ThreadInfoReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ThreadInfoReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ThreadInfoReply
             * @function getTypeUrl
             * @memberof dcnet.pb.ThreadInfoReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ThreadInfoReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ThreadInfoReply";
            };

            return ThreadInfoReply;
        })();

        pb.LogInfo = (function() {

            /**
             * Properties of a LogInfo.
             * @memberof dcnet.pb
             * @interface ILogInfo
             * @property {Uint8Array|null} [ID] LogInfo ID
             * @property {Uint8Array|null} [pubKey] LogInfo pubKey
             * @property {Uint8Array|null} [privKey] LogInfo privKey
             * @property {Array.<Uint8Array>|null} [addrs] LogInfo addrs
             * @property {Uint8Array|null} [head] LogInfo head
             * @property {Uint8Array|null} [counter] LogInfo counter
             */

            /**
             * Constructs a new LogInfo.
             * @memberof dcnet.pb
             * @classdesc Represents a LogInfo.
             * @implements ILogInfo
             * @constructor
             * @param {dcnet.pb.ILogInfo=} [properties] Properties to set
             */
            function LogInfo(properties) {
                this.addrs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LogInfo ID.
             * @member {Uint8Array} ID
             * @memberof dcnet.pb.LogInfo
             * @instance
             */
            LogInfo.prototype.ID = $util.newBuffer([]);

            /**
             * LogInfo pubKey.
             * @member {Uint8Array} pubKey
             * @memberof dcnet.pb.LogInfo
             * @instance
             */
            LogInfo.prototype.pubKey = $util.newBuffer([]);

            /**
             * LogInfo privKey.
             * @member {Uint8Array} privKey
             * @memberof dcnet.pb.LogInfo
             * @instance
             */
            LogInfo.prototype.privKey = $util.newBuffer([]);

            /**
             * LogInfo addrs.
             * @member {Array.<Uint8Array>} addrs
             * @memberof dcnet.pb.LogInfo
             * @instance
             */
            LogInfo.prototype.addrs = $util.emptyArray;

            /**
             * LogInfo head.
             * @member {Uint8Array} head
             * @memberof dcnet.pb.LogInfo
             * @instance
             */
            LogInfo.prototype.head = $util.newBuffer([]);

            /**
             * LogInfo counter.
             * @member {Uint8Array} counter
             * @memberof dcnet.pb.LogInfo
             * @instance
             */
            LogInfo.prototype.counter = $util.newBuffer([]);

            /**
             * Creates a new LogInfo instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.LogInfo
             * @static
             * @param {dcnet.pb.ILogInfo=} [properties] Properties to set
             * @returns {dcnet.pb.LogInfo} LogInfo instance
             */
            LogInfo.create = function create(properties) {
                return new LogInfo(properties);
            };

            /**
             * Encodes the specified LogInfo message. Does not implicitly {@link dcnet.pb.LogInfo.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.LogInfo
             * @static
             * @param {dcnet.pb.ILogInfo} message LogInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LogInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ID != null && Object.hasOwnProperty.call(message, "ID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ID);
                if (message.pubKey != null && Object.hasOwnProperty.call(message, "pubKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.pubKey);
                if (message.privKey != null && Object.hasOwnProperty.call(message, "privKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.privKey);
                if (message.addrs != null && message.addrs.length)
                    for (let i = 0; i < message.addrs.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.addrs[i]);
                if (message.head != null && Object.hasOwnProperty.call(message, "head"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.head);
                if (message.counter != null && Object.hasOwnProperty.call(message, "counter"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.counter);
                return writer;
            };

            /**
             * Encodes the specified LogInfo message, length delimited. Does not implicitly {@link dcnet.pb.LogInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.LogInfo
             * @static
             * @param {dcnet.pb.ILogInfo} message LogInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LogInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LogInfo message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.LogInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.LogInfo} LogInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LogInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.LogInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.ID = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.pubKey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.privKey = reader.bytes();
                            break;
                        }
                    case 4: {
                            if (!(message.addrs && message.addrs.length))
                                message.addrs = [];
                            message.addrs.push(reader.bytes());
                            break;
                        }
                    case 5: {
                            message.head = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.counter = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LogInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.LogInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.LogInfo} LogInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LogInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LogInfo message.
             * @function verify
             * @memberof dcnet.pb.LogInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LogInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ID != null && message.hasOwnProperty("ID"))
                    if (!(message.ID && typeof message.ID.length === "number" || $util.isString(message.ID)))
                        return "ID: buffer expected";
                if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                    if (!(message.pubKey && typeof message.pubKey.length === "number" || $util.isString(message.pubKey)))
                        return "pubKey: buffer expected";
                if (message.privKey != null && message.hasOwnProperty("privKey"))
                    if (!(message.privKey && typeof message.privKey.length === "number" || $util.isString(message.privKey)))
                        return "privKey: buffer expected";
                if (message.addrs != null && message.hasOwnProperty("addrs")) {
                    if (!Array.isArray(message.addrs))
                        return "addrs: array expected";
                    for (let i = 0; i < message.addrs.length; ++i)
                        if (!(message.addrs[i] && typeof message.addrs[i].length === "number" || $util.isString(message.addrs[i])))
                            return "addrs: buffer[] expected";
                }
                if (message.head != null && message.hasOwnProperty("head"))
                    if (!(message.head && typeof message.head.length === "number" || $util.isString(message.head)))
                        return "head: buffer expected";
                if (message.counter != null && message.hasOwnProperty("counter"))
                    if (!(message.counter && typeof message.counter.length === "number" || $util.isString(message.counter)))
                        return "counter: buffer expected";
                return null;
            };

            /**
             * Creates a LogInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.LogInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.LogInfo} LogInfo
             */
            LogInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.LogInfo)
                    return object;
                let message = new $root.dcnet.pb.LogInfo();
                if (object.ID != null)
                    if (typeof object.ID === "string")
                        $util.base64.decode(object.ID, message.ID = $util.newBuffer($util.base64.length(object.ID)), 0);
                    else if (object.ID.length >= 0)
                        message.ID = object.ID;
                if (object.pubKey != null)
                    if (typeof object.pubKey === "string")
                        $util.base64.decode(object.pubKey, message.pubKey = $util.newBuffer($util.base64.length(object.pubKey)), 0);
                    else if (object.pubKey.length >= 0)
                        message.pubKey = object.pubKey;
                if (object.privKey != null)
                    if (typeof object.privKey === "string")
                        $util.base64.decode(object.privKey, message.privKey = $util.newBuffer($util.base64.length(object.privKey)), 0);
                    else if (object.privKey.length >= 0)
                        message.privKey = object.privKey;
                if (object.addrs) {
                    if (!Array.isArray(object.addrs))
                        throw TypeError(".dcnet.pb.LogInfo.addrs: array expected");
                    message.addrs = [];
                    for (let i = 0; i < object.addrs.length; ++i)
                        if (typeof object.addrs[i] === "string")
                            $util.base64.decode(object.addrs[i], message.addrs[i] = $util.newBuffer($util.base64.length(object.addrs[i])), 0);
                        else if (object.addrs[i].length >= 0)
                            message.addrs[i] = object.addrs[i];
                }
                if (object.head != null)
                    if (typeof object.head === "string")
                        $util.base64.decode(object.head, message.head = $util.newBuffer($util.base64.length(object.head)), 0);
                    else if (object.head.length >= 0)
                        message.head = object.head;
                if (object.counter != null)
                    if (typeof object.counter === "string")
                        $util.base64.decode(object.counter, message.counter = $util.newBuffer($util.base64.length(object.counter)), 0);
                    else if (object.counter.length >= 0)
                        message.counter = object.counter;
                return message;
            };

            /**
             * Creates a plain object from a LogInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.LogInfo
             * @static
             * @param {dcnet.pb.LogInfo} message LogInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LogInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.addrs = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.ID = "";
                    else {
                        object.ID = [];
                        if (options.bytes !== Array)
                            object.ID = $util.newBuffer(object.ID);
                    }
                    if (options.bytes === String)
                        object.pubKey = "";
                    else {
                        object.pubKey = [];
                        if (options.bytes !== Array)
                            object.pubKey = $util.newBuffer(object.pubKey);
                    }
                    if (options.bytes === String)
                        object.privKey = "";
                    else {
                        object.privKey = [];
                        if (options.bytes !== Array)
                            object.privKey = $util.newBuffer(object.privKey);
                    }
                    if (options.bytes === String)
                        object.head = "";
                    else {
                        object.head = [];
                        if (options.bytes !== Array)
                            object.head = $util.newBuffer(object.head);
                    }
                    if (options.bytes === String)
                        object.counter = "";
                    else {
                        object.counter = [];
                        if (options.bytes !== Array)
                            object.counter = $util.newBuffer(object.counter);
                    }
                }
                if (message.ID != null && message.hasOwnProperty("ID"))
                    object.ID = options.bytes === String ? $util.base64.encode(message.ID, 0, message.ID.length) : options.bytes === Array ? Array.prototype.slice.call(message.ID) : message.ID;
                if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                    object.pubKey = options.bytes === String ? $util.base64.encode(message.pubKey, 0, message.pubKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKey) : message.pubKey;
                if (message.privKey != null && message.hasOwnProperty("privKey"))
                    object.privKey = options.bytes === String ? $util.base64.encode(message.privKey, 0, message.privKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privKey) : message.privKey;
                if (message.addrs && message.addrs.length) {
                    object.addrs = [];
                    for (let j = 0; j < message.addrs.length; ++j)
                        object.addrs[j] = options.bytes === String ? $util.base64.encode(message.addrs[j], 0, message.addrs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.addrs[j]) : message.addrs[j];
                }
                if (message.head != null && message.hasOwnProperty("head"))
                    object.head = options.bytes === String ? $util.base64.encode(message.head, 0, message.head.length) : options.bytes === Array ? Array.prototype.slice.call(message.head) : message.head;
                if (message.counter != null && message.hasOwnProperty("counter"))
                    object.counter = options.bytes === String ? $util.base64.encode(message.counter, 0, message.counter.length) : options.bytes === Array ? Array.prototype.slice.call(message.counter) : message.counter;
                return object;
            };

            /**
             * Converts this LogInfo to JSON.
             * @function toJSON
             * @memberof dcnet.pb.LogInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LogInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LogInfo
             * @function getTypeUrl
             * @memberof dcnet.pb.LogInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LogInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.LogInfo";
            };

            return LogInfo;
        })();

        pb.ThreadIDRequest = (function() {

            /**
             * Properties of a ThreadIDRequest.
             * @memberof dcnet.pb
             * @interface IThreadIDRequest
             * @property {Uint8Array|null} [vaccount] ThreadIDRequest vaccount
             */

            /**
             * Constructs a new ThreadIDRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a ThreadIDRequest.
             * @implements IThreadIDRequest
             * @constructor
             * @param {dcnet.pb.IThreadIDRequest=} [properties] Properties to set
             */
            function ThreadIDRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ThreadIDRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.ThreadIDRequest
             * @instance
             */
            ThreadIDRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new ThreadIDRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ThreadIDRequest
             * @static
             * @param {dcnet.pb.IThreadIDRequest=} [properties] Properties to set
             * @returns {dcnet.pb.ThreadIDRequest} ThreadIDRequest instance
             */
            ThreadIDRequest.create = function create(properties) {
                return new ThreadIDRequest(properties);
            };

            /**
             * Encodes the specified ThreadIDRequest message. Does not implicitly {@link dcnet.pb.ThreadIDRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ThreadIDRequest
             * @static
             * @param {dcnet.pb.IThreadIDRequest} message ThreadIDRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadIDRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified ThreadIDRequest message, length delimited. Does not implicitly {@link dcnet.pb.ThreadIDRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ThreadIDRequest
             * @static
             * @param {dcnet.pb.IThreadIDRequest} message ThreadIDRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadIDRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ThreadIDRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ThreadIDRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ThreadIDRequest} ThreadIDRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadIDRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ThreadIDRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ThreadIDRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ThreadIDRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ThreadIDRequest} ThreadIDRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadIDRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ThreadIDRequest message.
             * @function verify
             * @memberof dcnet.pb.ThreadIDRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ThreadIDRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a ThreadIDRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ThreadIDRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ThreadIDRequest} ThreadIDRequest
             */
            ThreadIDRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ThreadIDRequest)
                    return object;
                let message = new $root.dcnet.pb.ThreadIDRequest();
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a ThreadIDRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ThreadIDRequest
             * @static
             * @param {dcnet.pb.ThreadIDRequest} message ThreadIDRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ThreadIDRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this ThreadIDRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ThreadIDRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ThreadIDRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ThreadIDRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.ThreadIDRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ThreadIDRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ThreadIDRequest";
            };

            return ThreadIDRequest;
        })();

        pb.ThreadIDReply = (function() {

            /**
             * Properties of a ThreadIDReply.
             * @memberof dcnet.pb
             * @interface IThreadIDReply
             * @property {Uint8Array|null} [threadID] ThreadIDReply threadID
             */

            /**
             * Constructs a new ThreadIDReply.
             * @memberof dcnet.pb
             * @classdesc Represents a ThreadIDReply.
             * @implements IThreadIDReply
             * @constructor
             * @param {dcnet.pb.IThreadIDReply=} [properties] Properties to set
             */
            function ThreadIDReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ThreadIDReply threadID.
             * @member {Uint8Array} threadID
             * @memberof dcnet.pb.ThreadIDReply
             * @instance
             */
            ThreadIDReply.prototype.threadID = $util.newBuffer([]);

            /**
             * Creates a new ThreadIDReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ThreadIDReply
             * @static
             * @param {dcnet.pb.IThreadIDReply=} [properties] Properties to set
             * @returns {dcnet.pb.ThreadIDReply} ThreadIDReply instance
             */
            ThreadIDReply.create = function create(properties) {
                return new ThreadIDReply(properties);
            };

            /**
             * Encodes the specified ThreadIDReply message. Does not implicitly {@link dcnet.pb.ThreadIDReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ThreadIDReply
             * @static
             * @param {dcnet.pb.IThreadIDReply} message ThreadIDReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadIDReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadID != null && Object.hasOwnProperty.call(message, "threadID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.threadID);
                return writer;
            };

            /**
             * Encodes the specified ThreadIDReply message, length delimited. Does not implicitly {@link dcnet.pb.ThreadIDReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ThreadIDReply
             * @static
             * @param {dcnet.pb.IThreadIDReply} message ThreadIDReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ThreadIDReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ThreadIDReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ThreadIDReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ThreadIDReply} ThreadIDReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadIDReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ThreadIDReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadID = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ThreadIDReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ThreadIDReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ThreadIDReply} ThreadIDReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ThreadIDReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ThreadIDReply message.
             * @function verify
             * @memberof dcnet.pb.ThreadIDReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ThreadIDReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    if (!(message.threadID && typeof message.threadID.length === "number" || $util.isString(message.threadID)))
                        return "threadID: buffer expected";
                return null;
            };

            /**
             * Creates a ThreadIDReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ThreadIDReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ThreadIDReply} ThreadIDReply
             */
            ThreadIDReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ThreadIDReply)
                    return object;
                let message = new $root.dcnet.pb.ThreadIDReply();
                if (object.threadID != null)
                    if (typeof object.threadID === "string")
                        $util.base64.decode(object.threadID, message.threadID = $util.newBuffer($util.base64.length(object.threadID)), 0);
                    else if (object.threadID.length >= 0)
                        message.threadID = object.threadID;
                return message;
            };

            /**
             * Creates a plain object from a ThreadIDReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ThreadIDReply
             * @static
             * @param {dcnet.pb.ThreadIDReply} message ThreadIDReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ThreadIDReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.threadID = "";
                    else {
                        object.threadID = [];
                        if (options.bytes !== Array)
                            object.threadID = $util.newBuffer(object.threadID);
                    }
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    object.threadID = options.bytes === String ? $util.base64.encode(message.threadID, 0, message.threadID.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadID) : message.threadID;
                return object;
            };

            /**
             * Converts this ThreadIDReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ThreadIDReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ThreadIDReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ThreadIDReply
             * @function getTypeUrl
             * @memberof dcnet.pb.ThreadIDReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ThreadIDReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ThreadIDReply";
            };

            return ThreadIDReply;
        })();

        pb.AddThreadToPeerRequest = (function() {

            /**
             * Properties of an AddThreadToPeerRequest.
             * @memberof dcnet.pb
             * @interface IAddThreadToPeerRequest
             * @property {Uint8Array|null} [threadID] AddThreadToPeerRequest threadID
             * @property {number|null} [blockheight] AddThreadToPeerRequest blockheight
             * @property {dcnet.pb.IKeys|null} [keys] AddThreadToPeerRequest keys
             * @property {Uint8Array|null} [signature] AddThreadToPeerRequest signature
             * @property {Uint8Array|null} [vaccount] AddThreadToPeerRequest vaccount
             */

            /**
             * Constructs a new AddThreadToPeerRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AddThreadToPeerRequest.
             * @implements IAddThreadToPeerRequest
             * @constructor
             * @param {dcnet.pb.IAddThreadToPeerRequest=} [properties] Properties to set
             */
            function AddThreadToPeerRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddThreadToPeerRequest threadID.
             * @member {Uint8Array} threadID
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @instance
             */
            AddThreadToPeerRequest.prototype.threadID = $util.newBuffer([]);

            /**
             * AddThreadToPeerRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @instance
             */
            AddThreadToPeerRequest.prototype.blockheight = 0;

            /**
             * AddThreadToPeerRequest keys.
             * @member {dcnet.pb.IKeys|null|undefined} keys
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @instance
             */
            AddThreadToPeerRequest.prototype.keys = null;

            /**
             * AddThreadToPeerRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @instance
             */
            AddThreadToPeerRequest.prototype.signature = $util.newBuffer([]);

            /**
             * AddThreadToPeerRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @instance
             */
            AddThreadToPeerRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new AddThreadToPeerRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @static
             * @param {dcnet.pb.IAddThreadToPeerRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AddThreadToPeerRequest} AddThreadToPeerRequest instance
             */
            AddThreadToPeerRequest.create = function create(properties) {
                return new AddThreadToPeerRequest(properties);
            };

            /**
             * Encodes the specified AddThreadToPeerRequest message. Does not implicitly {@link dcnet.pb.AddThreadToPeerRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @static
             * @param {dcnet.pb.IAddThreadToPeerRequest} message AddThreadToPeerRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThreadToPeerRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadID != null && Object.hasOwnProperty.call(message, "threadID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.threadID);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.keys != null && Object.hasOwnProperty.call(message, "keys"))
                    $root.dcnet.pb.Keys.encode(message.keys, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified AddThreadToPeerRequest message, length delimited. Does not implicitly {@link dcnet.pb.AddThreadToPeerRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @static
             * @param {dcnet.pb.IAddThreadToPeerRequest} message AddThreadToPeerRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThreadToPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddThreadToPeerRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddThreadToPeerRequest} AddThreadToPeerRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThreadToPeerRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddThreadToPeerRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadID = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.keys = $root.dcnet.pb.Keys.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddThreadToPeerRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddThreadToPeerRequest} AddThreadToPeerRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThreadToPeerRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddThreadToPeerRequest message.
             * @function verify
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddThreadToPeerRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    if (!(message.threadID && typeof message.threadID.length === "number" || $util.isString(message.threadID)))
                        return "threadID: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.keys != null && message.hasOwnProperty("keys")) {
                    let error = $root.dcnet.pb.Keys.verify(message.keys);
                    if (error)
                        return "keys." + error;
                }
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates an AddThreadToPeerRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddThreadToPeerRequest} AddThreadToPeerRequest
             */
            AddThreadToPeerRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddThreadToPeerRequest)
                    return object;
                let message = new $root.dcnet.pb.AddThreadToPeerRequest();
                if (object.threadID != null)
                    if (typeof object.threadID === "string")
                        $util.base64.decode(object.threadID, message.threadID = $util.newBuffer($util.base64.length(object.threadID)), 0);
                    else if (object.threadID.length >= 0)
                        message.threadID = object.threadID;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.keys != null) {
                    if (typeof object.keys !== "object")
                        throw TypeError(".dcnet.pb.AddThreadToPeerRequest.keys: object expected");
                    message.keys = $root.dcnet.pb.Keys.fromObject(object.keys);
                }
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from an AddThreadToPeerRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @static
             * @param {dcnet.pb.AddThreadToPeerRequest} message AddThreadToPeerRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddThreadToPeerRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.threadID = "";
                    else {
                        object.threadID = [];
                        if (options.bytes !== Array)
                            object.threadID = $util.newBuffer(object.threadID);
                    }
                    object.blockheight = 0;
                    object.keys = null;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    object.threadID = options.bytes === String ? $util.base64.encode(message.threadID, 0, message.threadID.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadID) : message.threadID;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.keys != null && message.hasOwnProperty("keys"))
                    object.keys = $root.dcnet.pb.Keys.toObject(message.keys, options);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this AddThreadToPeerRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddThreadToPeerRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddThreadToPeerRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AddThreadToPeerRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddThreadToPeerRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddThreadToPeerRequest";
            };

            return AddThreadToPeerRequest;
        })();

        pb.AddThreadToPeerReply = (function() {

            /**
             * Properties of an AddThreadToPeerReply.
             * @memberof dcnet.pb
             * @interface IAddThreadToPeerReply
             * @property {number|null} [status] AddThreadToPeerReply status
             * @property {number|Long|null} [count] AddThreadToPeerReply count
             */

            /**
             * Constructs a new AddThreadToPeerReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AddThreadToPeerReply.
             * @implements IAddThreadToPeerReply
             * @constructor
             * @param {dcnet.pb.IAddThreadToPeerReply=} [properties] Properties to set
             */
            function AddThreadToPeerReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddThreadToPeerReply status.
             * @member {number} status
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @instance
             */
            AddThreadToPeerReply.prototype.status = 0;

            /**
             * AddThreadToPeerReply count.
             * @member {number|Long} count
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @instance
             */
            AddThreadToPeerReply.prototype.count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new AddThreadToPeerReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @static
             * @param {dcnet.pb.IAddThreadToPeerReply=} [properties] Properties to set
             * @returns {dcnet.pb.AddThreadToPeerReply} AddThreadToPeerReply instance
             */
            AddThreadToPeerReply.create = function create(properties) {
                return new AddThreadToPeerReply(properties);
            };

            /**
             * Encodes the specified AddThreadToPeerReply message. Does not implicitly {@link dcnet.pb.AddThreadToPeerReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @static
             * @param {dcnet.pb.IAddThreadToPeerReply} message AddThreadToPeerReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThreadToPeerReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.count);
                return writer;
            };

            /**
             * Encodes the specified AddThreadToPeerReply message, length delimited. Does not implicitly {@link dcnet.pb.AddThreadToPeerReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @static
             * @param {dcnet.pb.IAddThreadToPeerReply} message AddThreadToPeerReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThreadToPeerReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddThreadToPeerReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddThreadToPeerReply} AddThreadToPeerReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThreadToPeerReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddThreadToPeerReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.status = reader.int32();
                            break;
                        }
                    case 2: {
                            message.count = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddThreadToPeerReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddThreadToPeerReply} AddThreadToPeerReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThreadToPeerReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddThreadToPeerReply message.
             * @function verify
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddThreadToPeerReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                        return "count: integer|Long expected";
                return null;
            };

            /**
             * Creates an AddThreadToPeerReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddThreadToPeerReply} AddThreadToPeerReply
             */
            AddThreadToPeerReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddThreadToPeerReply)
                    return object;
                let message = new $root.dcnet.pb.AddThreadToPeerReply();
                if (object.status != null)
                    message.status = object.status | 0;
                if (object.count != null)
                    if ($util.Long)
                        (message.count = $util.Long.fromValue(object.count)).unsigned = false;
                    else if (typeof object.count === "string")
                        message.count = parseInt(object.count, 10);
                    else if (typeof object.count === "number")
                        message.count = object.count;
                    else if (typeof object.count === "object")
                        message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an AddThreadToPeerReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @static
             * @param {dcnet.pb.AddThreadToPeerReply} message AddThreadToPeerReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddThreadToPeerReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.status = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.count = options.longs === String ? "0" : 0;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                if (message.count != null && message.hasOwnProperty("count"))
                    if (typeof message.count === "number")
                        object.count = options.longs === String ? String(message.count) : message.count;
                    else
                        object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
                return object;
            };

            /**
             * Converts this AddThreadToPeerReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddThreadToPeerReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddThreadToPeerReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AddThreadToPeerReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddThreadToPeerReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddThreadToPeerReply";
            };

            return AddThreadToPeerReply;
        })();

        pb.GetThreadRequest = (function() {

            /**
             * Properties of a GetThreadRequest.
             * @memberof dcnet.pb
             * @interface IGetThreadRequest
             * @property {Uint8Array|null} [threadID] GetThreadRequest threadID
             * @property {Uint8Array|null} [vaccount] GetThreadRequest vaccount
             */

            /**
             * Constructs a new GetThreadRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThreadRequest.
             * @implements IGetThreadRequest
             * @constructor
             * @param {dcnet.pb.IGetThreadRequest=} [properties] Properties to set
             */
            function GetThreadRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThreadRequest threadID.
             * @member {Uint8Array} threadID
             * @memberof dcnet.pb.GetThreadRequest
             * @instance
             */
            GetThreadRequest.prototype.threadID = $util.newBuffer([]);

            /**
             * GetThreadRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.GetThreadRequest
             * @instance
             */
            GetThreadRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new GetThreadRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThreadRequest
             * @static
             * @param {dcnet.pb.IGetThreadRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetThreadRequest} GetThreadRequest instance
             */
            GetThreadRequest.create = function create(properties) {
                return new GetThreadRequest(properties);
            };

            /**
             * Encodes the specified GetThreadRequest message. Does not implicitly {@link dcnet.pb.GetThreadRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThreadRequest
             * @static
             * @param {dcnet.pb.IGetThreadRequest} message GetThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThreadRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadID != null && Object.hasOwnProperty.call(message, "threadID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.threadID);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified GetThreadRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetThreadRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThreadRequest
             * @static
             * @param {dcnet.pb.IGetThreadRequest} message GetThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThreadRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThreadRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThreadRequest} GetThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThreadRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThreadRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadID = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThreadRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThreadRequest} GetThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThreadRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThreadRequest message.
             * @function verify
             * @memberof dcnet.pb.GetThreadRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThreadRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    if (!(message.threadID && typeof message.threadID.length === "number" || $util.isString(message.threadID)))
                        return "threadID: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a GetThreadRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThreadRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThreadRequest} GetThreadRequest
             */
            GetThreadRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThreadRequest)
                    return object;
                let message = new $root.dcnet.pb.GetThreadRequest();
                if (object.threadID != null)
                    if (typeof object.threadID === "string")
                        $util.base64.decode(object.threadID, message.threadID = $util.newBuffer($util.base64.length(object.threadID)), 0);
                    else if (object.threadID.length >= 0)
                        message.threadID = object.threadID;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a GetThreadRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThreadRequest
             * @static
             * @param {dcnet.pb.GetThreadRequest} message GetThreadRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThreadRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.threadID = "";
                    else {
                        object.threadID = [];
                        if (options.bytes !== Array)
                            object.threadID = $util.newBuffer(object.threadID);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    object.threadID = options.bytes === String ? $util.base64.encode(message.threadID, 0, message.threadID.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadID) : message.threadID;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this GetThreadRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThreadRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThreadRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThreadRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThreadRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThreadRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThreadRequest";
            };

            return GetThreadRequest;
        })();

        pb.DeleteThreadRequest = (function() {

            /**
             * Properties of a DeleteThreadRequest.
             * @memberof dcnet.pb
             * @interface IDeleteThreadRequest
             * @property {Uint8Array|null} [threadID] DeleteThreadRequest threadID
             * @property {number|null} [blockheight] DeleteThreadRequest blockheight
             * @property {Uint8Array|null} [signature] DeleteThreadRequest signature
             * @property {Uint8Array|null} [vaccount] DeleteThreadRequest vaccount
             */

            /**
             * Constructs a new DeleteThreadRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteThreadRequest.
             * @implements IDeleteThreadRequest
             * @constructor
             * @param {dcnet.pb.IDeleteThreadRequest=} [properties] Properties to set
             */
            function DeleteThreadRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteThreadRequest threadID.
             * @member {Uint8Array} threadID
             * @memberof dcnet.pb.DeleteThreadRequest
             * @instance
             */
            DeleteThreadRequest.prototype.threadID = $util.newBuffer([]);

            /**
             * DeleteThreadRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.DeleteThreadRequest
             * @instance
             */
            DeleteThreadRequest.prototype.blockheight = 0;

            /**
             * DeleteThreadRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.DeleteThreadRequest
             * @instance
             */
            DeleteThreadRequest.prototype.signature = $util.newBuffer([]);

            /**
             * DeleteThreadRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.DeleteThreadRequest
             * @instance
             */
            DeleteThreadRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new DeleteThreadRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteThreadRequest
             * @static
             * @param {dcnet.pb.IDeleteThreadRequest=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteThreadRequest} DeleteThreadRequest instance
             */
            DeleteThreadRequest.create = function create(properties) {
                return new DeleteThreadRequest(properties);
            };

            /**
             * Encodes the specified DeleteThreadRequest message. Does not implicitly {@link dcnet.pb.DeleteThreadRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteThreadRequest
             * @static
             * @param {dcnet.pb.IDeleteThreadRequest} message DeleteThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteThreadRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadID != null && Object.hasOwnProperty.call(message, "threadID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.threadID);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified DeleteThreadRequest message, length delimited. Does not implicitly {@link dcnet.pb.DeleteThreadRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteThreadRequest
             * @static
             * @param {dcnet.pb.IDeleteThreadRequest} message DeleteThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteThreadRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteThreadRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteThreadRequest} DeleteThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteThreadRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteThreadRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadID = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteThreadRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteThreadRequest} DeleteThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteThreadRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteThreadRequest message.
             * @function verify
             * @memberof dcnet.pb.DeleteThreadRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteThreadRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    if (!(message.threadID && typeof message.threadID.length === "number" || $util.isString(message.threadID)))
                        return "threadID: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a DeleteThreadRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteThreadRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteThreadRequest} DeleteThreadRequest
             */
            DeleteThreadRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteThreadRequest)
                    return object;
                let message = new $root.dcnet.pb.DeleteThreadRequest();
                if (object.threadID != null)
                    if (typeof object.threadID === "string")
                        $util.base64.decode(object.threadID, message.threadID = $util.newBuffer($util.base64.length(object.threadID)), 0);
                    else if (object.threadID.length >= 0)
                        message.threadID = object.threadID;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a DeleteThreadRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteThreadRequest
             * @static
             * @param {dcnet.pb.DeleteThreadRequest} message DeleteThreadRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteThreadRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.threadID = "";
                    else {
                        object.threadID = [];
                        if (options.bytes !== Array)
                            object.threadID = $util.newBuffer(object.threadID);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    object.threadID = options.bytes === String ? $util.base64.encode(message.threadID, 0, message.threadID.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadID) : message.threadID;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this DeleteThreadRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteThreadRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteThreadRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteThreadRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteThreadRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteThreadRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteThreadRequest";
            };

            return DeleteThreadRequest;
        })();

        pb.DeleteThreadReply = (function() {

            /**
             * Properties of a DeleteThreadReply.
             * @memberof dcnet.pb
             * @interface IDeleteThreadReply
             */

            /**
             * Constructs a new DeleteThreadReply.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteThreadReply.
             * @implements IDeleteThreadReply
             * @constructor
             * @param {dcnet.pb.IDeleteThreadReply=} [properties] Properties to set
             */
            function DeleteThreadReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteThreadReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteThreadReply
             * @static
             * @param {dcnet.pb.IDeleteThreadReply=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteThreadReply} DeleteThreadReply instance
             */
            DeleteThreadReply.create = function create(properties) {
                return new DeleteThreadReply(properties);
            };

            /**
             * Encodes the specified DeleteThreadReply message. Does not implicitly {@link dcnet.pb.DeleteThreadReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteThreadReply
             * @static
             * @param {dcnet.pb.IDeleteThreadReply} message DeleteThreadReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteThreadReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteThreadReply message, length delimited. Does not implicitly {@link dcnet.pb.DeleteThreadReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteThreadReply
             * @static
             * @param {dcnet.pb.IDeleteThreadReply} message DeleteThreadReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteThreadReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteThreadReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteThreadReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteThreadReply} DeleteThreadReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteThreadReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteThreadReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteThreadReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteThreadReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteThreadReply} DeleteThreadReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteThreadReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteThreadReply message.
             * @function verify
             * @memberof dcnet.pb.DeleteThreadReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteThreadReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteThreadReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteThreadReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteThreadReply} DeleteThreadReply
             */
            DeleteThreadReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteThreadReply)
                    return object;
                return new $root.dcnet.pb.DeleteThreadReply();
            };

            /**
             * Creates a plain object from a DeleteThreadReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteThreadReply
             * @static
             * @param {dcnet.pb.DeleteThreadReply} message DeleteThreadReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteThreadReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteThreadReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteThreadReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteThreadReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteThreadReply
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteThreadReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteThreadReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteThreadReply";
            };

            return DeleteThreadReply;
        })();

        pb.StroeFileRequest = (function() {

            /**
             * Properties of a StroeFileRequest.
             * @memberof dcnet.pb
             * @interface IStroeFileRequest
             * @property {Uint8Array|null} [cid] StroeFileRequest cid
             * @property {number|Long|null} [filesize] StroeFileRequest filesize
             * @property {number|null} [blockheight] StroeFileRequest blockheight
             * @property {Uint8Array|null} [signature] StroeFileRequest signature
             * @property {Uint8Array|null} [vaccount] StroeFileRequest vaccount
             */

            /**
             * Constructs a new StroeFileRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a StroeFileRequest.
             * @implements IStroeFileRequest
             * @constructor
             * @param {dcnet.pb.IStroeFileRequest=} [properties] Properties to set
             */
            function StroeFileRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StroeFileRequest cid.
             * @member {Uint8Array} cid
             * @memberof dcnet.pb.StroeFileRequest
             * @instance
             */
            StroeFileRequest.prototype.cid = $util.newBuffer([]);

            /**
             * StroeFileRequest filesize.
             * @member {number|Long} filesize
             * @memberof dcnet.pb.StroeFileRequest
             * @instance
             */
            StroeFileRequest.prototype.filesize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * StroeFileRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.StroeFileRequest
             * @instance
             */
            StroeFileRequest.prototype.blockheight = 0;

            /**
             * StroeFileRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.StroeFileRequest
             * @instance
             */
            StroeFileRequest.prototype.signature = $util.newBuffer([]);

            /**
             * StroeFileRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.StroeFileRequest
             * @instance
             */
            StroeFileRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new StroeFileRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.StroeFileRequest
             * @static
             * @param {dcnet.pb.IStroeFileRequest=} [properties] Properties to set
             * @returns {dcnet.pb.StroeFileRequest} StroeFileRequest instance
             */
            StroeFileRequest.create = function create(properties) {
                return new StroeFileRequest(properties);
            };

            /**
             * Encodes the specified StroeFileRequest message. Does not implicitly {@link dcnet.pb.StroeFileRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.StroeFileRequest
             * @static
             * @param {dcnet.pb.IStroeFileRequest} message StroeFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StroeFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cid != null && Object.hasOwnProperty.call(message, "cid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.cid);
                if (message.filesize != null && Object.hasOwnProperty.call(message, "filesize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.filesize);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.blockheight);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified StroeFileRequest message, length delimited. Does not implicitly {@link dcnet.pb.StroeFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.StroeFileRequest
             * @static
             * @param {dcnet.pb.IStroeFileRequest} message StroeFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StroeFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StroeFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.StroeFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.StroeFileRequest} StroeFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StroeFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.StroeFileRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cid = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.filesize = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StroeFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.StroeFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.StroeFileRequest} StroeFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StroeFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StroeFileRequest message.
             * @function verify
             * @memberof dcnet.pb.StroeFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StroeFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cid != null && message.hasOwnProperty("cid"))
                    if (!(message.cid && typeof message.cid.length === "number" || $util.isString(message.cid)))
                        return "cid: buffer expected";
                if (message.filesize != null && message.hasOwnProperty("filesize"))
                    if (!$util.isInteger(message.filesize) && !(message.filesize && $util.isInteger(message.filesize.low) && $util.isInteger(message.filesize.high)))
                        return "filesize: integer|Long expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a StroeFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.StroeFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.StroeFileRequest} StroeFileRequest
             */
            StroeFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.StroeFileRequest)
                    return object;
                let message = new $root.dcnet.pb.StroeFileRequest();
                if (object.cid != null)
                    if (typeof object.cid === "string")
                        $util.base64.decode(object.cid, message.cid = $util.newBuffer($util.base64.length(object.cid)), 0);
                    else if (object.cid.length >= 0)
                        message.cid = object.cid;
                if (object.filesize != null)
                    if ($util.Long)
                        (message.filesize = $util.Long.fromValue(object.filesize)).unsigned = true;
                    else if (typeof object.filesize === "string")
                        message.filesize = parseInt(object.filesize, 10);
                    else if (typeof object.filesize === "number")
                        message.filesize = object.filesize;
                    else if (typeof object.filesize === "object")
                        message.filesize = new $util.LongBits(object.filesize.low >>> 0, object.filesize.high >>> 0).toNumber(true);
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a StroeFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.StroeFileRequest
             * @static
             * @param {dcnet.pb.StroeFileRequest} message StroeFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StroeFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.cid = "";
                    else {
                        object.cid = [];
                        if (options.bytes !== Array)
                            object.cid = $util.newBuffer(object.cid);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.filesize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.filesize = options.longs === String ? "0" : 0;
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.cid != null && message.hasOwnProperty("cid"))
                    object.cid = options.bytes === String ? $util.base64.encode(message.cid, 0, message.cid.length) : options.bytes === Array ? Array.prototype.slice.call(message.cid) : message.cid;
                if (message.filesize != null && message.hasOwnProperty("filesize"))
                    if (typeof message.filesize === "number")
                        object.filesize = options.longs === String ? String(message.filesize) : message.filesize;
                    else
                        object.filesize = options.longs === String ? $util.Long.prototype.toString.call(message.filesize) : options.longs === Number ? new $util.LongBits(message.filesize.low >>> 0, message.filesize.high >>> 0).toNumber(true) : message.filesize;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this StroeFileRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.StroeFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StroeFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StroeFileRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.StroeFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StroeFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.StroeFileRequest";
            };

            return StroeFileRequest;
        })();

        pb.StroeFileReply = (function() {

            /**
             * Properties of a StroeFileReply.
             * @memberof dcnet.pb
             * @interface IStroeFileReply
             * @property {number|null} [status] StroeFileReply status
             * @property {number|Long|null} [receivesize] StroeFileReply receivesize
             */

            /**
             * Constructs a new StroeFileReply.
             * @memberof dcnet.pb
             * @classdesc Represents a StroeFileReply.
             * @implements IStroeFileReply
             * @constructor
             * @param {dcnet.pb.IStroeFileReply=} [properties] Properties to set
             */
            function StroeFileReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StroeFileReply status.
             * @member {number} status
             * @memberof dcnet.pb.StroeFileReply
             * @instance
             */
            StroeFileReply.prototype.status = 0;

            /**
             * StroeFileReply receivesize.
             * @member {number|Long} receivesize
             * @memberof dcnet.pb.StroeFileReply
             * @instance
             */
            StroeFileReply.prototype.receivesize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new StroeFileReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.StroeFileReply
             * @static
             * @param {dcnet.pb.IStroeFileReply=} [properties] Properties to set
             * @returns {dcnet.pb.StroeFileReply} StroeFileReply instance
             */
            StroeFileReply.create = function create(properties) {
                return new StroeFileReply(properties);
            };

            /**
             * Encodes the specified StroeFileReply message. Does not implicitly {@link dcnet.pb.StroeFileReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.StroeFileReply
             * @static
             * @param {dcnet.pb.IStroeFileReply} message StroeFileReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StroeFileReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.receivesize != null && Object.hasOwnProperty.call(message, "receivesize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.receivesize);
                return writer;
            };

            /**
             * Encodes the specified StroeFileReply message, length delimited. Does not implicitly {@link dcnet.pb.StroeFileReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.StroeFileReply
             * @static
             * @param {dcnet.pb.IStroeFileReply} message StroeFileReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StroeFileReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StroeFileReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.StroeFileReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.StroeFileReply} StroeFileReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StroeFileReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.StroeFileReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.status = reader.int32();
                            break;
                        }
                    case 2: {
                            message.receivesize = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StroeFileReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.StroeFileReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.StroeFileReply} StroeFileReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StroeFileReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StroeFileReply message.
             * @function verify
             * @memberof dcnet.pb.StroeFileReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StroeFileReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                if (message.receivesize != null && message.hasOwnProperty("receivesize"))
                    if (!$util.isInteger(message.receivesize) && !(message.receivesize && $util.isInteger(message.receivesize.low) && $util.isInteger(message.receivesize.high)))
                        return "receivesize: integer|Long expected";
                return null;
            };

            /**
             * Creates a StroeFileReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.StroeFileReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.StroeFileReply} StroeFileReply
             */
            StroeFileReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.StroeFileReply)
                    return object;
                let message = new $root.dcnet.pb.StroeFileReply();
                if (object.status != null)
                    message.status = object.status | 0;
                if (object.receivesize != null)
                    if ($util.Long)
                        (message.receivesize = $util.Long.fromValue(object.receivesize)).unsigned = true;
                    else if (typeof object.receivesize === "string")
                        message.receivesize = parseInt(object.receivesize, 10);
                    else if (typeof object.receivesize === "number")
                        message.receivesize = object.receivesize;
                    else if (typeof object.receivesize === "object")
                        message.receivesize = new $util.LongBits(object.receivesize.low >>> 0, object.receivesize.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a StroeFileReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.StroeFileReply
             * @static
             * @param {dcnet.pb.StroeFileReply} message StroeFileReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StroeFileReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.status = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.receivesize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.receivesize = options.longs === String ? "0" : 0;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                if (message.receivesize != null && message.hasOwnProperty("receivesize"))
                    if (typeof message.receivesize === "number")
                        object.receivesize = options.longs === String ? String(message.receivesize) : message.receivesize;
                    else
                        object.receivesize = options.longs === String ? $util.Long.prototype.toString.call(message.receivesize) : options.longs === Number ? new $util.LongBits(message.receivesize.low >>> 0, message.receivesize.high >>> 0).toNumber(true) : message.receivesize;
                return object;
            };

            /**
             * Converts this StroeFileReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.StroeFileReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StroeFileReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StroeFileReply
             * @function getTypeUrl
             * @memberof dcnet.pb.StroeFileReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StroeFileReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.StroeFileReply";
            };

            return StroeFileReply;
        })();

        pb.DeleteFileRequest = (function() {

            /**
             * Properties of a DeleteFileRequest.
             * @memberof dcnet.pb
             * @interface IDeleteFileRequest
             * @property {Uint8Array|null} [cid] DeleteFileRequest cid
             * @property {number|null} [blockheight] DeleteFileRequest blockheight
             * @property {Uint8Array|null} [signature] DeleteFileRequest signature
             * @property {Uint8Array|null} [vaccount] DeleteFileRequest vaccount
             */

            /**
             * Constructs a new DeleteFileRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteFileRequest.
             * @implements IDeleteFileRequest
             * @constructor
             * @param {dcnet.pb.IDeleteFileRequest=} [properties] Properties to set
             */
            function DeleteFileRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteFileRequest cid.
             * @member {Uint8Array} cid
             * @memberof dcnet.pb.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.cid = $util.newBuffer([]);

            /**
             * DeleteFileRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.blockheight = 0;

            /**
             * DeleteFileRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.signature = $util.newBuffer([]);

            /**
             * DeleteFileRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new DeleteFileRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteFileRequest
             * @static
             * @param {dcnet.pb.IDeleteFileRequest=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteFileRequest} DeleteFileRequest instance
             */
            DeleteFileRequest.create = function create(properties) {
                return new DeleteFileRequest(properties);
            };

            /**
             * Encodes the specified DeleteFileRequest message. Does not implicitly {@link dcnet.pb.DeleteFileRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteFileRequest
             * @static
             * @param {dcnet.pb.IDeleteFileRequest} message DeleteFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cid != null && Object.hasOwnProperty.call(message, "cid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.cid);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified DeleteFileRequest message, length delimited. Does not implicitly {@link dcnet.pb.DeleteFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteFileRequest
             * @static
             * @param {dcnet.pb.IDeleteFileRequest} message DeleteFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteFileRequest} DeleteFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteFileRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cid = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteFileRequest} DeleteFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFileRequest message.
             * @function verify
             * @memberof dcnet.pb.DeleteFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cid != null && message.hasOwnProperty("cid"))
                    if (!(message.cid && typeof message.cid.length === "number" || $util.isString(message.cid)))
                        return "cid: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a DeleteFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteFileRequest} DeleteFileRequest
             */
            DeleteFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteFileRequest)
                    return object;
                let message = new $root.dcnet.pb.DeleteFileRequest();
                if (object.cid != null)
                    if (typeof object.cid === "string")
                        $util.base64.decode(object.cid, message.cid = $util.newBuffer($util.base64.length(object.cid)), 0);
                    else if (object.cid.length >= 0)
                        message.cid = object.cid;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a DeleteFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteFileRequest
             * @static
             * @param {dcnet.pb.DeleteFileRequest} message DeleteFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.cid = "";
                    else {
                        object.cid = [];
                        if (options.bytes !== Array)
                            object.cid = $util.newBuffer(object.cid);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.cid != null && message.hasOwnProperty("cid"))
                    object.cid = options.bytes === String ? $util.base64.encode(message.cid, 0, message.cid.length) : options.bytes === Array ? Array.prototype.slice.call(message.cid) : message.cid;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this DeleteFileRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFileRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteFileRequest";
            };

            return DeleteFileRequest;
        })();

        pb.DeleteFileReply = (function() {

            /**
             * Properties of a DeleteFileReply.
             * @memberof dcnet.pb
             * @interface IDeleteFileReply
             * @property {boolean|null} [flag] DeleteFileReply flag
             */

            /**
             * Constructs a new DeleteFileReply.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteFileReply.
             * @implements IDeleteFileReply
             * @constructor
             * @param {dcnet.pb.IDeleteFileReply=} [properties] Properties to set
             */
            function DeleteFileReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteFileReply flag.
             * @member {boolean} flag
             * @memberof dcnet.pb.DeleteFileReply
             * @instance
             */
            DeleteFileReply.prototype.flag = false;

            /**
             * Creates a new DeleteFileReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteFileReply
             * @static
             * @param {dcnet.pb.IDeleteFileReply=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteFileReply} DeleteFileReply instance
             */
            DeleteFileReply.create = function create(properties) {
                return new DeleteFileReply(properties);
            };

            /**
             * Encodes the specified DeleteFileReply message. Does not implicitly {@link dcnet.pb.DeleteFileReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteFileReply
             * @static
             * @param {dcnet.pb.IDeleteFileReply} message DeleteFileReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.flag);
                return writer;
            };

            /**
             * Encodes the specified DeleteFileReply message, length delimited. Does not implicitly {@link dcnet.pb.DeleteFileReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteFileReply
             * @static
             * @param {dcnet.pb.IDeleteFileReply} message DeleteFileReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFileReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteFileReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteFileReply} DeleteFileReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteFileReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFileReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteFileReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteFileReply} DeleteFileReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFileReply message.
             * @function verify
             * @memberof dcnet.pb.DeleteFileReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFileReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (typeof message.flag !== "boolean")
                        return "flag: boolean expected";
                return null;
            };

            /**
             * Creates a DeleteFileReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteFileReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteFileReply} DeleteFileReply
             */
            DeleteFileReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteFileReply)
                    return object;
                let message = new $root.dcnet.pb.DeleteFileReply();
                if (object.flag != null)
                    message.flag = Boolean(object.flag);
                return message;
            };

            /**
             * Creates a plain object from a DeleteFileReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteFileReply
             * @static
             * @param {dcnet.pb.DeleteFileReply} message DeleteFileReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFileReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = false;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this DeleteFileReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteFileReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFileReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFileReply
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteFileReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFileReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteFileReply";
            };

            return DeleteFileReply;
        })();

        pb.StoreFolderRequest = (function() {

            /**
             * Properties of a StoreFolderRequest.
             * @memberof dcnet.pb
             * @interface IStoreFolderRequest
             * @property {Uint8Array|null} [cid] StoreFolderRequest cid
             * @property {number|Long|null} [foldersize] StoreFolderRequest foldersize
             * @property {number|null} [filecount] StoreFolderRequest filecount
             * @property {number|null} [blockheight] StoreFolderRequest blockheight
             * @property {Uint8Array|null} [signature] StoreFolderRequest signature
             * @property {Uint8Array|null} [vaccount] StoreFolderRequest vaccount
             */

            /**
             * Constructs a new StoreFolderRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a StoreFolderRequest.
             * @implements IStoreFolderRequest
             * @constructor
             * @param {dcnet.pb.IStoreFolderRequest=} [properties] Properties to set
             */
            function StoreFolderRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoreFolderRequest cid.
             * @member {Uint8Array} cid
             * @memberof dcnet.pb.StoreFolderRequest
             * @instance
             */
            StoreFolderRequest.prototype.cid = $util.newBuffer([]);

            /**
             * StoreFolderRequest foldersize.
             * @member {number|Long} foldersize
             * @memberof dcnet.pb.StoreFolderRequest
             * @instance
             */
            StoreFolderRequest.prototype.foldersize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * StoreFolderRequest filecount.
             * @member {number} filecount
             * @memberof dcnet.pb.StoreFolderRequest
             * @instance
             */
            StoreFolderRequest.prototype.filecount = 0;

            /**
             * StoreFolderRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.StoreFolderRequest
             * @instance
             */
            StoreFolderRequest.prototype.blockheight = 0;

            /**
             * StoreFolderRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.StoreFolderRequest
             * @instance
             */
            StoreFolderRequest.prototype.signature = $util.newBuffer([]);

            /**
             * StoreFolderRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.StoreFolderRequest
             * @instance
             */
            StoreFolderRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new StoreFolderRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.StoreFolderRequest
             * @static
             * @param {dcnet.pb.IStoreFolderRequest=} [properties] Properties to set
             * @returns {dcnet.pb.StoreFolderRequest} StoreFolderRequest instance
             */
            StoreFolderRequest.create = function create(properties) {
                return new StoreFolderRequest(properties);
            };

            /**
             * Encodes the specified StoreFolderRequest message. Does not implicitly {@link dcnet.pb.StoreFolderRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.StoreFolderRequest
             * @static
             * @param {dcnet.pb.IStoreFolderRequest} message StoreFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreFolderRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cid != null && Object.hasOwnProperty.call(message, "cid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.cid);
                if (message.foldersize != null && Object.hasOwnProperty.call(message, "foldersize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.foldersize);
                if (message.filecount != null && Object.hasOwnProperty.call(message, "filecount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.filecount);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockheight);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified StoreFolderRequest message, length delimited. Does not implicitly {@link dcnet.pb.StoreFolderRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.StoreFolderRequest
             * @static
             * @param {dcnet.pb.IStoreFolderRequest} message StoreFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreFolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoreFolderRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.StoreFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.StoreFolderRequest} StoreFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreFolderRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.StoreFolderRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cid = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.foldersize = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.filecount = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoreFolderRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.StoreFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.StoreFolderRequest} StoreFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreFolderRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoreFolderRequest message.
             * @function verify
             * @memberof dcnet.pb.StoreFolderRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoreFolderRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cid != null && message.hasOwnProperty("cid"))
                    if (!(message.cid && typeof message.cid.length === "number" || $util.isString(message.cid)))
                        return "cid: buffer expected";
                if (message.foldersize != null && message.hasOwnProperty("foldersize"))
                    if (!$util.isInteger(message.foldersize) && !(message.foldersize && $util.isInteger(message.foldersize.low) && $util.isInteger(message.foldersize.high)))
                        return "foldersize: integer|Long expected";
                if (message.filecount != null && message.hasOwnProperty("filecount"))
                    if (!$util.isInteger(message.filecount))
                        return "filecount: integer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a StoreFolderRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.StoreFolderRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.StoreFolderRequest} StoreFolderRequest
             */
            StoreFolderRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.StoreFolderRequest)
                    return object;
                let message = new $root.dcnet.pb.StoreFolderRequest();
                if (object.cid != null)
                    if (typeof object.cid === "string")
                        $util.base64.decode(object.cid, message.cid = $util.newBuffer($util.base64.length(object.cid)), 0);
                    else if (object.cid.length >= 0)
                        message.cid = object.cid;
                if (object.foldersize != null)
                    if ($util.Long)
                        (message.foldersize = $util.Long.fromValue(object.foldersize)).unsigned = true;
                    else if (typeof object.foldersize === "string")
                        message.foldersize = parseInt(object.foldersize, 10);
                    else if (typeof object.foldersize === "number")
                        message.foldersize = object.foldersize;
                    else if (typeof object.foldersize === "object")
                        message.foldersize = new $util.LongBits(object.foldersize.low >>> 0, object.foldersize.high >>> 0).toNumber(true);
                if (object.filecount != null)
                    message.filecount = object.filecount >>> 0;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a StoreFolderRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.StoreFolderRequest
             * @static
             * @param {dcnet.pb.StoreFolderRequest} message StoreFolderRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreFolderRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.cid = "";
                    else {
                        object.cid = [];
                        if (options.bytes !== Array)
                            object.cid = $util.newBuffer(object.cid);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.foldersize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.foldersize = options.longs === String ? "0" : 0;
                    object.filecount = 0;
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.cid != null && message.hasOwnProperty("cid"))
                    object.cid = options.bytes === String ? $util.base64.encode(message.cid, 0, message.cid.length) : options.bytes === Array ? Array.prototype.slice.call(message.cid) : message.cid;
                if (message.foldersize != null && message.hasOwnProperty("foldersize"))
                    if (typeof message.foldersize === "number")
                        object.foldersize = options.longs === String ? String(message.foldersize) : message.foldersize;
                    else
                        object.foldersize = options.longs === String ? $util.Long.prototype.toString.call(message.foldersize) : options.longs === Number ? new $util.LongBits(message.foldersize.low >>> 0, message.foldersize.high >>> 0).toNumber(true) : message.foldersize;
                if (message.filecount != null && message.hasOwnProperty("filecount"))
                    object.filecount = message.filecount;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this StoreFolderRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.StoreFolderRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoreFolderRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StoreFolderRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.StoreFolderRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StoreFolderRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.StoreFolderRequest";
            };

            return StoreFolderRequest;
        })();

        pb.StoreFolderReply = (function() {

            /**
             * Properties of a StoreFolderReply.
             * @memberof dcnet.pb
             * @interface IStoreFolderReply
             * @property {number|null} [status] StoreFolderReply status
             * @property {number|null} [receivecount] StoreFolderReply receivecount
             */

            /**
             * Constructs a new StoreFolderReply.
             * @memberof dcnet.pb
             * @classdesc Represents a StoreFolderReply.
             * @implements IStoreFolderReply
             * @constructor
             * @param {dcnet.pb.IStoreFolderReply=} [properties] Properties to set
             */
            function StoreFolderReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoreFolderReply status.
             * @member {number} status
             * @memberof dcnet.pb.StoreFolderReply
             * @instance
             */
            StoreFolderReply.prototype.status = 0;

            /**
             * StoreFolderReply receivecount.
             * @member {number} receivecount
             * @memberof dcnet.pb.StoreFolderReply
             * @instance
             */
            StoreFolderReply.prototype.receivecount = 0;

            /**
             * Creates a new StoreFolderReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.StoreFolderReply
             * @static
             * @param {dcnet.pb.IStoreFolderReply=} [properties] Properties to set
             * @returns {dcnet.pb.StoreFolderReply} StoreFolderReply instance
             */
            StoreFolderReply.create = function create(properties) {
                return new StoreFolderReply(properties);
            };

            /**
             * Encodes the specified StoreFolderReply message. Does not implicitly {@link dcnet.pb.StoreFolderReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.StoreFolderReply
             * @static
             * @param {dcnet.pb.IStoreFolderReply} message StoreFolderReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreFolderReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.receivecount != null && Object.hasOwnProperty.call(message, "receivecount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.receivecount);
                return writer;
            };

            /**
             * Encodes the specified StoreFolderReply message, length delimited. Does not implicitly {@link dcnet.pb.StoreFolderReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.StoreFolderReply
             * @static
             * @param {dcnet.pb.IStoreFolderReply} message StoreFolderReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreFolderReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoreFolderReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.StoreFolderReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.StoreFolderReply} StoreFolderReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreFolderReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.StoreFolderReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.status = reader.int32();
                            break;
                        }
                    case 2: {
                            message.receivecount = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoreFolderReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.StoreFolderReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.StoreFolderReply} StoreFolderReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreFolderReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoreFolderReply message.
             * @function verify
             * @memberof dcnet.pb.StoreFolderReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoreFolderReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                if (message.receivecount != null && message.hasOwnProperty("receivecount"))
                    if (!$util.isInteger(message.receivecount))
                        return "receivecount: integer expected";
                return null;
            };

            /**
             * Creates a StoreFolderReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.StoreFolderReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.StoreFolderReply} StoreFolderReply
             */
            StoreFolderReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.StoreFolderReply)
                    return object;
                let message = new $root.dcnet.pb.StoreFolderReply();
                if (object.status != null)
                    message.status = object.status | 0;
                if (object.receivecount != null)
                    message.receivecount = object.receivecount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a StoreFolderReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.StoreFolderReply
             * @static
             * @param {dcnet.pb.StoreFolderReply} message StoreFolderReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreFolderReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.status = 0;
                    object.receivecount = 0;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                if (message.receivecount != null && message.hasOwnProperty("receivecount"))
                    object.receivecount = message.receivecount;
                return object;
            };

            /**
             * Converts this StoreFolderReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.StoreFolderReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoreFolderReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StoreFolderReply
             * @function getTypeUrl
             * @memberof dcnet.pb.StoreFolderReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StoreFolderReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.StoreFolderReply";
            };

            return StoreFolderReply;
        })();

        pb.AccountDealRequest = (function() {

            /**
             * Properties of an AccountDealRequest.
             * @memberof dcnet.pb
             * @interface IAccountDealRequest
             * @property {Uint8Array|null} [accountencrypt] AccountDealRequest accountencrypt
             * @property {Uint8Array|null} [accounthashencrypt] AccountDealRequest accounthashencrypt
             * @property {Uint8Array|null} [prikeyencrypt2] AccountDealRequest prikeyencrypt2
             * @property {number|null} [blockheight] AccountDealRequest blockheight
             * @property {Uint8Array|null} [loginkeyrandencrypt] AccountDealRequest loginkeyrandencrypt
             * @property {Uint8Array|null} [peerid] AccountDealRequest peerid
             * @property {Uint8Array|null} [signature] AccountDealRequest signature
             * @property {Uint8Array|null} [vaccount] AccountDealRequest vaccount
             */

            /**
             * Constructs a new AccountDealRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AccountDealRequest.
             * @implements IAccountDealRequest
             * @constructor
             * @param {dcnet.pb.IAccountDealRequest=} [properties] Properties to set
             */
            function AccountDealRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AccountDealRequest accountencrypt.
             * @member {Uint8Array} accountencrypt
             * @memberof dcnet.pb.AccountDealRequest
             * @instance
             */
            AccountDealRequest.prototype.accountencrypt = $util.newBuffer([]);

            /**
             * AccountDealRequest accounthashencrypt.
             * @member {Uint8Array} accounthashencrypt
             * @memberof dcnet.pb.AccountDealRequest
             * @instance
             */
            AccountDealRequest.prototype.accounthashencrypt = $util.newBuffer([]);

            /**
             * AccountDealRequest prikeyencrypt2.
             * @member {Uint8Array} prikeyencrypt2
             * @memberof dcnet.pb.AccountDealRequest
             * @instance
             */
            AccountDealRequest.prototype.prikeyencrypt2 = $util.newBuffer([]);

            /**
             * AccountDealRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.AccountDealRequest
             * @instance
             */
            AccountDealRequest.prototype.blockheight = 0;

            /**
             * AccountDealRequest loginkeyrandencrypt.
             * @member {Uint8Array} loginkeyrandencrypt
             * @memberof dcnet.pb.AccountDealRequest
             * @instance
             */
            AccountDealRequest.prototype.loginkeyrandencrypt = $util.newBuffer([]);

            /**
             * AccountDealRequest peerid.
             * @member {Uint8Array} peerid
             * @memberof dcnet.pb.AccountDealRequest
             * @instance
             */
            AccountDealRequest.prototype.peerid = $util.newBuffer([]);

            /**
             * AccountDealRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.AccountDealRequest
             * @instance
             */
            AccountDealRequest.prototype.signature = $util.newBuffer([]);

            /**
             * AccountDealRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.AccountDealRequest
             * @instance
             */
            AccountDealRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new AccountDealRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AccountDealRequest
             * @static
             * @param {dcnet.pb.IAccountDealRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AccountDealRequest} AccountDealRequest instance
             */
            AccountDealRequest.create = function create(properties) {
                return new AccountDealRequest(properties);
            };

            /**
             * Encodes the specified AccountDealRequest message. Does not implicitly {@link dcnet.pb.AccountDealRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AccountDealRequest
             * @static
             * @param {dcnet.pb.IAccountDealRequest} message AccountDealRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountDealRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountencrypt != null && Object.hasOwnProperty.call(message, "accountencrypt"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountencrypt);
                if (message.accounthashencrypt != null && Object.hasOwnProperty.call(message, "accounthashencrypt"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accounthashencrypt);
                if (message.prikeyencrypt2 != null && Object.hasOwnProperty.call(message, "prikeyencrypt2"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.prikeyencrypt2);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockheight);
                if (message.loginkeyrandencrypt != null && Object.hasOwnProperty.call(message, "loginkeyrandencrypt"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.loginkeyrandencrypt);
                if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.peerid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified AccountDealRequest message, length delimited. Does not implicitly {@link dcnet.pb.AccountDealRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AccountDealRequest
             * @static
             * @param {dcnet.pb.IAccountDealRequest} message AccountDealRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountDealRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AccountDealRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AccountDealRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AccountDealRequest} AccountDealRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountDealRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AccountDealRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accountencrypt = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.accounthashencrypt = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.prikeyencrypt2 = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.loginkeyrandencrypt = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.peerid = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AccountDealRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AccountDealRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AccountDealRequest} AccountDealRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountDealRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AccountDealRequest message.
             * @function verify
             * @memberof dcnet.pb.AccountDealRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AccountDealRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accountencrypt != null && message.hasOwnProperty("accountencrypt"))
                    if (!(message.accountencrypt && typeof message.accountencrypt.length === "number" || $util.isString(message.accountencrypt)))
                        return "accountencrypt: buffer expected";
                if (message.accounthashencrypt != null && message.hasOwnProperty("accounthashencrypt"))
                    if (!(message.accounthashencrypt && typeof message.accounthashencrypt.length === "number" || $util.isString(message.accounthashencrypt)))
                        return "accounthashencrypt: buffer expected";
                if (message.prikeyencrypt2 != null && message.hasOwnProperty("prikeyencrypt2"))
                    if (!(message.prikeyencrypt2 && typeof message.prikeyencrypt2.length === "number" || $util.isString(message.prikeyencrypt2)))
                        return "prikeyencrypt2: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.loginkeyrandencrypt != null && message.hasOwnProperty("loginkeyrandencrypt"))
                    if (!(message.loginkeyrandencrypt && typeof message.loginkeyrandencrypt.length === "number" || $util.isString(message.loginkeyrandencrypt)))
                        return "loginkeyrandencrypt: buffer expected";
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                        return "peerid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates an AccountDealRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AccountDealRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AccountDealRequest} AccountDealRequest
             */
            AccountDealRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AccountDealRequest)
                    return object;
                let message = new $root.dcnet.pb.AccountDealRequest();
                if (object.accountencrypt != null)
                    if (typeof object.accountencrypt === "string")
                        $util.base64.decode(object.accountencrypt, message.accountencrypt = $util.newBuffer($util.base64.length(object.accountencrypt)), 0);
                    else if (object.accountencrypt.length >= 0)
                        message.accountencrypt = object.accountencrypt;
                if (object.accounthashencrypt != null)
                    if (typeof object.accounthashencrypt === "string")
                        $util.base64.decode(object.accounthashencrypt, message.accounthashencrypt = $util.newBuffer($util.base64.length(object.accounthashencrypt)), 0);
                    else if (object.accounthashencrypt.length >= 0)
                        message.accounthashencrypt = object.accounthashencrypt;
                if (object.prikeyencrypt2 != null)
                    if (typeof object.prikeyencrypt2 === "string")
                        $util.base64.decode(object.prikeyencrypt2, message.prikeyencrypt2 = $util.newBuffer($util.base64.length(object.prikeyencrypt2)), 0);
                    else if (object.prikeyencrypt2.length >= 0)
                        message.prikeyencrypt2 = object.prikeyencrypt2;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.loginkeyrandencrypt != null)
                    if (typeof object.loginkeyrandencrypt === "string")
                        $util.base64.decode(object.loginkeyrandencrypt, message.loginkeyrandencrypt = $util.newBuffer($util.base64.length(object.loginkeyrandencrypt)), 0);
                    else if (object.loginkeyrandencrypt.length >= 0)
                        message.loginkeyrandencrypt = object.loginkeyrandencrypt;
                if (object.peerid != null)
                    if (typeof object.peerid === "string")
                        $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                    else if (object.peerid.length >= 0)
                        message.peerid = object.peerid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from an AccountDealRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AccountDealRequest
             * @static
             * @param {dcnet.pb.AccountDealRequest} message AccountDealRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AccountDealRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.accountencrypt = "";
                    else {
                        object.accountencrypt = [];
                        if (options.bytes !== Array)
                            object.accountencrypt = $util.newBuffer(object.accountencrypt);
                    }
                    if (options.bytes === String)
                        object.accounthashencrypt = "";
                    else {
                        object.accounthashencrypt = [];
                        if (options.bytes !== Array)
                            object.accounthashencrypt = $util.newBuffer(object.accounthashencrypt);
                    }
                    if (options.bytes === String)
                        object.prikeyencrypt2 = "";
                    else {
                        object.prikeyencrypt2 = [];
                        if (options.bytes !== Array)
                            object.prikeyencrypt2 = $util.newBuffer(object.prikeyencrypt2);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.loginkeyrandencrypt = "";
                    else {
                        object.loginkeyrandencrypt = [];
                        if (options.bytes !== Array)
                            object.loginkeyrandencrypt = $util.newBuffer(object.loginkeyrandencrypt);
                    }
                    if (options.bytes === String)
                        object.peerid = "";
                    else {
                        object.peerid = [];
                        if (options.bytes !== Array)
                            object.peerid = $util.newBuffer(object.peerid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.accountencrypt != null && message.hasOwnProperty("accountencrypt"))
                    object.accountencrypt = options.bytes === String ? $util.base64.encode(message.accountencrypt, 0, message.accountencrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountencrypt) : message.accountencrypt;
                if (message.accounthashencrypt != null && message.hasOwnProperty("accounthashencrypt"))
                    object.accounthashencrypt = options.bytes === String ? $util.base64.encode(message.accounthashencrypt, 0, message.accounthashencrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.accounthashencrypt) : message.accounthashencrypt;
                if (message.prikeyencrypt2 != null && message.hasOwnProperty("prikeyencrypt2"))
                    object.prikeyencrypt2 = options.bytes === String ? $util.base64.encode(message.prikeyencrypt2, 0, message.prikeyencrypt2.length) : options.bytes === Array ? Array.prototype.slice.call(message.prikeyencrypt2) : message.prikeyencrypt2;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.loginkeyrandencrypt != null && message.hasOwnProperty("loginkeyrandencrypt"))
                    object.loginkeyrandencrypt = options.bytes === String ? $util.base64.encode(message.loginkeyrandencrypt, 0, message.loginkeyrandencrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.loginkeyrandencrypt) : message.loginkeyrandencrypt;
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this AccountDealRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AccountDealRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AccountDealRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AccountDealRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AccountDealRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountDealRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AccountDealRequest";
            };

            return AccountDealRequest;
        })();

        pb.AccountDealReply = (function() {

            /**
             * Properties of an AccountDealReply.
             * @memberof dcnet.pb
             * @interface IAccountDealReply
             */

            /**
             * Constructs a new AccountDealReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AccountDealReply.
             * @implements IAccountDealReply
             * @constructor
             * @param {dcnet.pb.IAccountDealReply=} [properties] Properties to set
             */
            function AccountDealReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AccountDealReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AccountDealReply
             * @static
             * @param {dcnet.pb.IAccountDealReply=} [properties] Properties to set
             * @returns {dcnet.pb.AccountDealReply} AccountDealReply instance
             */
            AccountDealReply.create = function create(properties) {
                return new AccountDealReply(properties);
            };

            /**
             * Encodes the specified AccountDealReply message. Does not implicitly {@link dcnet.pb.AccountDealReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AccountDealReply
             * @static
             * @param {dcnet.pb.IAccountDealReply} message AccountDealReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountDealReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AccountDealReply message, length delimited. Does not implicitly {@link dcnet.pb.AccountDealReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AccountDealReply
             * @static
             * @param {dcnet.pb.IAccountDealReply} message AccountDealReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountDealReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AccountDealReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AccountDealReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AccountDealReply} AccountDealReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountDealReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AccountDealReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AccountDealReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AccountDealReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AccountDealReply} AccountDealReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountDealReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AccountDealReply message.
             * @function verify
             * @memberof dcnet.pb.AccountDealReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AccountDealReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AccountDealReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AccountDealReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AccountDealReply} AccountDealReply
             */
            AccountDealReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AccountDealReply)
                    return object;
                return new $root.dcnet.pb.AccountDealReply();
            };

            /**
             * Creates a plain object from an AccountDealReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AccountDealReply
             * @static
             * @param {dcnet.pb.AccountDealReply} message AccountDealReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AccountDealReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AccountDealReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AccountDealReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AccountDealReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AccountDealReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AccountDealReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountDealReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AccountDealReply";
            };

            return AccountDealReply;
        })();

        pb.AccountLoginRequest = (function() {

            /**
             * Properties of an AccountLoginRequest.
             * @memberof dcnet.pb
             * @interface IAccountLoginRequest
             * @property {Uint8Array|null} [accounthashencrypt] AccountLoginRequest accounthashencrypt
             * @property {Uint8Array|null} [pubkeyencrypt] AccountLoginRequest pubkeyencrypt
             * @property {Uint8Array|null} [loginkeyrandencrypt] AccountLoginRequest loginkeyrandencrypt
             */

            /**
             * Constructs a new AccountLoginRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AccountLoginRequest.
             * @implements IAccountLoginRequest
             * @constructor
             * @param {dcnet.pb.IAccountLoginRequest=} [properties] Properties to set
             */
            function AccountLoginRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AccountLoginRequest accounthashencrypt.
             * @member {Uint8Array} accounthashencrypt
             * @memberof dcnet.pb.AccountLoginRequest
             * @instance
             */
            AccountLoginRequest.prototype.accounthashencrypt = $util.newBuffer([]);

            /**
             * AccountLoginRequest pubkeyencrypt.
             * @member {Uint8Array} pubkeyencrypt
             * @memberof dcnet.pb.AccountLoginRequest
             * @instance
             */
            AccountLoginRequest.prototype.pubkeyencrypt = $util.newBuffer([]);

            /**
             * AccountLoginRequest loginkeyrandencrypt.
             * @member {Uint8Array} loginkeyrandencrypt
             * @memberof dcnet.pb.AccountLoginRequest
             * @instance
             */
            AccountLoginRequest.prototype.loginkeyrandencrypt = $util.newBuffer([]);

            /**
             * Creates a new AccountLoginRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AccountLoginRequest
             * @static
             * @param {dcnet.pb.IAccountLoginRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AccountLoginRequest} AccountLoginRequest instance
             */
            AccountLoginRequest.create = function create(properties) {
                return new AccountLoginRequest(properties);
            };

            /**
             * Encodes the specified AccountLoginRequest message. Does not implicitly {@link dcnet.pb.AccountLoginRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AccountLoginRequest
             * @static
             * @param {dcnet.pb.IAccountLoginRequest} message AccountLoginRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountLoginRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accounthashencrypt != null && Object.hasOwnProperty.call(message, "accounthashencrypt"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accounthashencrypt);
                if (message.pubkeyencrypt != null && Object.hasOwnProperty.call(message, "pubkeyencrypt"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.pubkeyencrypt);
                if (message.loginkeyrandencrypt != null && Object.hasOwnProperty.call(message, "loginkeyrandencrypt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.loginkeyrandencrypt);
                return writer;
            };

            /**
             * Encodes the specified AccountLoginRequest message, length delimited. Does not implicitly {@link dcnet.pb.AccountLoginRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AccountLoginRequest
             * @static
             * @param {dcnet.pb.IAccountLoginRequest} message AccountLoginRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountLoginRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AccountLoginRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AccountLoginRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AccountLoginRequest} AccountLoginRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountLoginRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AccountLoginRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accounthashencrypt = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.pubkeyencrypt = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.loginkeyrandencrypt = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AccountLoginRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AccountLoginRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AccountLoginRequest} AccountLoginRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountLoginRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AccountLoginRequest message.
             * @function verify
             * @memberof dcnet.pb.AccountLoginRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AccountLoginRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accounthashencrypt != null && message.hasOwnProperty("accounthashencrypt"))
                    if (!(message.accounthashencrypt && typeof message.accounthashencrypt.length === "number" || $util.isString(message.accounthashencrypt)))
                        return "accounthashencrypt: buffer expected";
                if (message.pubkeyencrypt != null && message.hasOwnProperty("pubkeyencrypt"))
                    if (!(message.pubkeyencrypt && typeof message.pubkeyencrypt.length === "number" || $util.isString(message.pubkeyencrypt)))
                        return "pubkeyencrypt: buffer expected";
                if (message.loginkeyrandencrypt != null && message.hasOwnProperty("loginkeyrandencrypt"))
                    if (!(message.loginkeyrandencrypt && typeof message.loginkeyrandencrypt.length === "number" || $util.isString(message.loginkeyrandencrypt)))
                        return "loginkeyrandencrypt: buffer expected";
                return null;
            };

            /**
             * Creates an AccountLoginRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AccountLoginRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AccountLoginRequest} AccountLoginRequest
             */
            AccountLoginRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AccountLoginRequest)
                    return object;
                let message = new $root.dcnet.pb.AccountLoginRequest();
                if (object.accounthashencrypt != null)
                    if (typeof object.accounthashencrypt === "string")
                        $util.base64.decode(object.accounthashencrypt, message.accounthashencrypt = $util.newBuffer($util.base64.length(object.accounthashencrypt)), 0);
                    else if (object.accounthashencrypt.length >= 0)
                        message.accounthashencrypt = object.accounthashencrypt;
                if (object.pubkeyencrypt != null)
                    if (typeof object.pubkeyencrypt === "string")
                        $util.base64.decode(object.pubkeyencrypt, message.pubkeyencrypt = $util.newBuffer($util.base64.length(object.pubkeyencrypt)), 0);
                    else if (object.pubkeyencrypt.length >= 0)
                        message.pubkeyencrypt = object.pubkeyencrypt;
                if (object.loginkeyrandencrypt != null)
                    if (typeof object.loginkeyrandencrypt === "string")
                        $util.base64.decode(object.loginkeyrandencrypt, message.loginkeyrandencrypt = $util.newBuffer($util.base64.length(object.loginkeyrandencrypt)), 0);
                    else if (object.loginkeyrandencrypt.length >= 0)
                        message.loginkeyrandencrypt = object.loginkeyrandencrypt;
                return message;
            };

            /**
             * Creates a plain object from an AccountLoginRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AccountLoginRequest
             * @static
             * @param {dcnet.pb.AccountLoginRequest} message AccountLoginRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AccountLoginRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.accounthashencrypt = "";
                    else {
                        object.accounthashencrypt = [];
                        if (options.bytes !== Array)
                            object.accounthashencrypt = $util.newBuffer(object.accounthashencrypt);
                    }
                    if (options.bytes === String)
                        object.pubkeyencrypt = "";
                    else {
                        object.pubkeyencrypt = [];
                        if (options.bytes !== Array)
                            object.pubkeyencrypt = $util.newBuffer(object.pubkeyencrypt);
                    }
                    if (options.bytes === String)
                        object.loginkeyrandencrypt = "";
                    else {
                        object.loginkeyrandencrypt = [];
                        if (options.bytes !== Array)
                            object.loginkeyrandencrypt = $util.newBuffer(object.loginkeyrandencrypt);
                    }
                }
                if (message.accounthashencrypt != null && message.hasOwnProperty("accounthashencrypt"))
                    object.accounthashencrypt = options.bytes === String ? $util.base64.encode(message.accounthashencrypt, 0, message.accounthashencrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.accounthashencrypt) : message.accounthashencrypt;
                if (message.pubkeyencrypt != null && message.hasOwnProperty("pubkeyencrypt"))
                    object.pubkeyencrypt = options.bytes === String ? $util.base64.encode(message.pubkeyencrypt, 0, message.pubkeyencrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubkeyencrypt) : message.pubkeyencrypt;
                if (message.loginkeyrandencrypt != null && message.hasOwnProperty("loginkeyrandencrypt"))
                    object.loginkeyrandencrypt = options.bytes === String ? $util.base64.encode(message.loginkeyrandencrypt, 0, message.loginkeyrandencrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.loginkeyrandencrypt) : message.loginkeyrandencrypt;
                return object;
            };

            /**
             * Converts this AccountLoginRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AccountLoginRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AccountLoginRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AccountLoginRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AccountLoginRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountLoginRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AccountLoginRequest";
            };

            return AccountLoginRequest;
        })();

        pb.AccountLoginReply = (function() {

            /**
             * Properties of an AccountLoginReply.
             * @memberof dcnet.pb
             * @interface IAccountLoginReply
             * @property {Uint8Array|null} [prikeyencrypt2] AccountLoginReply prikeyencrypt2
             */

            /**
             * Constructs a new AccountLoginReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AccountLoginReply.
             * @implements IAccountLoginReply
             * @constructor
             * @param {dcnet.pb.IAccountLoginReply=} [properties] Properties to set
             */
            function AccountLoginReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AccountLoginReply prikeyencrypt2.
             * @member {Uint8Array} prikeyencrypt2
             * @memberof dcnet.pb.AccountLoginReply
             * @instance
             */
            AccountLoginReply.prototype.prikeyencrypt2 = $util.newBuffer([]);

            /**
             * Creates a new AccountLoginReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AccountLoginReply
             * @static
             * @param {dcnet.pb.IAccountLoginReply=} [properties] Properties to set
             * @returns {dcnet.pb.AccountLoginReply} AccountLoginReply instance
             */
            AccountLoginReply.create = function create(properties) {
                return new AccountLoginReply(properties);
            };

            /**
             * Encodes the specified AccountLoginReply message. Does not implicitly {@link dcnet.pb.AccountLoginReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AccountLoginReply
             * @static
             * @param {dcnet.pb.IAccountLoginReply} message AccountLoginReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountLoginReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.prikeyencrypt2 != null && Object.hasOwnProperty.call(message, "prikeyencrypt2"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.prikeyencrypt2);
                return writer;
            };

            /**
             * Encodes the specified AccountLoginReply message, length delimited. Does not implicitly {@link dcnet.pb.AccountLoginReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AccountLoginReply
             * @static
             * @param {dcnet.pb.IAccountLoginReply} message AccountLoginReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountLoginReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AccountLoginReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AccountLoginReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AccountLoginReply} AccountLoginReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountLoginReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AccountLoginReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.prikeyencrypt2 = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AccountLoginReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AccountLoginReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AccountLoginReply} AccountLoginReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountLoginReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AccountLoginReply message.
             * @function verify
             * @memberof dcnet.pb.AccountLoginReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AccountLoginReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.prikeyencrypt2 != null && message.hasOwnProperty("prikeyencrypt2"))
                    if (!(message.prikeyencrypt2 && typeof message.prikeyencrypt2.length === "number" || $util.isString(message.prikeyencrypt2)))
                        return "prikeyencrypt2: buffer expected";
                return null;
            };

            /**
             * Creates an AccountLoginReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AccountLoginReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AccountLoginReply} AccountLoginReply
             */
            AccountLoginReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AccountLoginReply)
                    return object;
                let message = new $root.dcnet.pb.AccountLoginReply();
                if (object.prikeyencrypt2 != null)
                    if (typeof object.prikeyencrypt2 === "string")
                        $util.base64.decode(object.prikeyencrypt2, message.prikeyencrypt2 = $util.newBuffer($util.base64.length(object.prikeyencrypt2)), 0);
                    else if (object.prikeyencrypt2.length >= 0)
                        message.prikeyencrypt2 = object.prikeyencrypt2;
                return message;
            };

            /**
             * Creates a plain object from an AccountLoginReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AccountLoginReply
             * @static
             * @param {dcnet.pb.AccountLoginReply} message AccountLoginReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AccountLoginReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.prikeyencrypt2 = "";
                    else {
                        object.prikeyencrypt2 = [];
                        if (options.bytes !== Array)
                            object.prikeyencrypt2 = $util.newBuffer(object.prikeyencrypt2);
                    }
                if (message.prikeyencrypt2 != null && message.hasOwnProperty("prikeyencrypt2"))
                    object.prikeyencrypt2 = options.bytes === String ? $util.base64.encode(message.prikeyencrypt2, 0, message.prikeyencrypt2.length) : options.bytes === Array ? Array.prototype.slice.call(message.prikeyencrypt2) : message.prikeyencrypt2;
                return object;
            };

            /**
             * Converts this AccountLoginReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AccountLoginReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AccountLoginReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AccountLoginReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AccountLoginReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AccountLoginReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AccountLoginReply";
            };

            return AccountLoginReply;
        })();

        pb.TransferAccountRequest = (function() {

            /**
             * Properties of a TransferAccountRequest.
             * @memberof dcnet.pb
             * @interface ITransferAccountRequest
             * @property {Uint8Array|null} [accounthashencrypt] TransferAccountRequest accounthashencrypt
             * @property {Uint8Array|null} [recvpubkey] TransferAccountRequest recvpubkey
             * @property {number|null} [blockheight] TransferAccountRequest blockheight
             * @property {Uint8Array|null} [peerid] TransferAccountRequest peerid
             * @property {Uint8Array|null} [signature] TransferAccountRequest signature
             */

            /**
             * Constructs a new TransferAccountRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a TransferAccountRequest.
             * @implements ITransferAccountRequest
             * @constructor
             * @param {dcnet.pb.ITransferAccountRequest=} [properties] Properties to set
             */
            function TransferAccountRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransferAccountRequest accounthashencrypt.
             * @member {Uint8Array} accounthashencrypt
             * @memberof dcnet.pb.TransferAccountRequest
             * @instance
             */
            TransferAccountRequest.prototype.accounthashencrypt = $util.newBuffer([]);

            /**
             * TransferAccountRequest recvpubkey.
             * @member {Uint8Array} recvpubkey
             * @memberof dcnet.pb.TransferAccountRequest
             * @instance
             */
            TransferAccountRequest.prototype.recvpubkey = $util.newBuffer([]);

            /**
             * TransferAccountRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.TransferAccountRequest
             * @instance
             */
            TransferAccountRequest.prototype.blockheight = 0;

            /**
             * TransferAccountRequest peerid.
             * @member {Uint8Array} peerid
             * @memberof dcnet.pb.TransferAccountRequest
             * @instance
             */
            TransferAccountRequest.prototype.peerid = $util.newBuffer([]);

            /**
             * TransferAccountRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.TransferAccountRequest
             * @instance
             */
            TransferAccountRequest.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new TransferAccountRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.TransferAccountRequest
             * @static
             * @param {dcnet.pb.ITransferAccountRequest=} [properties] Properties to set
             * @returns {dcnet.pb.TransferAccountRequest} TransferAccountRequest instance
             */
            TransferAccountRequest.create = function create(properties) {
                return new TransferAccountRequest(properties);
            };

            /**
             * Encodes the specified TransferAccountRequest message. Does not implicitly {@link dcnet.pb.TransferAccountRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.TransferAccountRequest
             * @static
             * @param {dcnet.pb.ITransferAccountRequest} message TransferAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransferAccountRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accounthashencrypt != null && Object.hasOwnProperty.call(message, "accounthashencrypt"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accounthashencrypt);
                if (message.recvpubkey != null && Object.hasOwnProperty.call(message, "recvpubkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recvpubkey);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.blockheight);
                if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.peerid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified TransferAccountRequest message, length delimited. Does not implicitly {@link dcnet.pb.TransferAccountRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.TransferAccountRequest
             * @static
             * @param {dcnet.pb.ITransferAccountRequest} message TransferAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransferAccountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransferAccountRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.TransferAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.TransferAccountRequest} TransferAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransferAccountRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.TransferAccountRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accounthashencrypt = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.recvpubkey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.peerid = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransferAccountRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.TransferAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.TransferAccountRequest} TransferAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransferAccountRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransferAccountRequest message.
             * @function verify
             * @memberof dcnet.pb.TransferAccountRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransferAccountRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accounthashencrypt != null && message.hasOwnProperty("accounthashencrypt"))
                    if (!(message.accounthashencrypt && typeof message.accounthashencrypt.length === "number" || $util.isString(message.accounthashencrypt)))
                        return "accounthashencrypt: buffer expected";
                if (message.recvpubkey != null && message.hasOwnProperty("recvpubkey"))
                    if (!(message.recvpubkey && typeof message.recvpubkey.length === "number" || $util.isString(message.recvpubkey)))
                        return "recvpubkey: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                        return "peerid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a TransferAccountRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.TransferAccountRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.TransferAccountRequest} TransferAccountRequest
             */
            TransferAccountRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.TransferAccountRequest)
                    return object;
                let message = new $root.dcnet.pb.TransferAccountRequest();
                if (object.accounthashencrypt != null)
                    if (typeof object.accounthashencrypt === "string")
                        $util.base64.decode(object.accounthashencrypt, message.accounthashencrypt = $util.newBuffer($util.base64.length(object.accounthashencrypt)), 0);
                    else if (object.accounthashencrypt.length >= 0)
                        message.accounthashencrypt = object.accounthashencrypt;
                if (object.recvpubkey != null)
                    if (typeof object.recvpubkey === "string")
                        $util.base64.decode(object.recvpubkey, message.recvpubkey = $util.newBuffer($util.base64.length(object.recvpubkey)), 0);
                    else if (object.recvpubkey.length >= 0)
                        message.recvpubkey = object.recvpubkey;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.peerid != null)
                    if (typeof object.peerid === "string")
                        $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                    else if (object.peerid.length >= 0)
                        message.peerid = object.peerid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a TransferAccountRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.TransferAccountRequest
             * @static
             * @param {dcnet.pb.TransferAccountRequest} message TransferAccountRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransferAccountRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.accounthashencrypt = "";
                    else {
                        object.accounthashencrypt = [];
                        if (options.bytes !== Array)
                            object.accounthashencrypt = $util.newBuffer(object.accounthashencrypt);
                    }
                    if (options.bytes === String)
                        object.recvpubkey = "";
                    else {
                        object.recvpubkey = [];
                        if (options.bytes !== Array)
                            object.recvpubkey = $util.newBuffer(object.recvpubkey);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.peerid = "";
                    else {
                        object.peerid = [];
                        if (options.bytes !== Array)
                            object.peerid = $util.newBuffer(object.peerid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.accounthashencrypt != null && message.hasOwnProperty("accounthashencrypt"))
                    object.accounthashencrypt = options.bytes === String ? $util.base64.encode(message.accounthashencrypt, 0, message.accounthashencrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.accounthashencrypt) : message.accounthashencrypt;
                if (message.recvpubkey != null && message.hasOwnProperty("recvpubkey"))
                    object.recvpubkey = options.bytes === String ? $util.base64.encode(message.recvpubkey, 0, message.recvpubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.recvpubkey) : message.recvpubkey;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this TransferAccountRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.TransferAccountRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransferAccountRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TransferAccountRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.TransferAccountRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TransferAccountRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.TransferAccountRequest";
            };

            return TransferAccountRequest;
        })();

        pb.TransferAccountReply = (function() {

            /**
             * Properties of a TransferAccountReply.
             * @memberof dcnet.pb
             * @interface ITransferAccountReply
             */

            /**
             * Constructs a new TransferAccountReply.
             * @memberof dcnet.pb
             * @classdesc Represents a TransferAccountReply.
             * @implements ITransferAccountReply
             * @constructor
             * @param {dcnet.pb.ITransferAccountReply=} [properties] Properties to set
             */
            function TransferAccountReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new TransferAccountReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.TransferAccountReply
             * @static
             * @param {dcnet.pb.ITransferAccountReply=} [properties] Properties to set
             * @returns {dcnet.pb.TransferAccountReply} TransferAccountReply instance
             */
            TransferAccountReply.create = function create(properties) {
                return new TransferAccountReply(properties);
            };

            /**
             * Encodes the specified TransferAccountReply message. Does not implicitly {@link dcnet.pb.TransferAccountReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.TransferAccountReply
             * @static
             * @param {dcnet.pb.ITransferAccountReply} message TransferAccountReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransferAccountReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified TransferAccountReply message, length delimited. Does not implicitly {@link dcnet.pb.TransferAccountReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.TransferAccountReply
             * @static
             * @param {dcnet.pb.ITransferAccountReply} message TransferAccountReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransferAccountReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransferAccountReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.TransferAccountReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.TransferAccountReply} TransferAccountReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransferAccountReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.TransferAccountReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransferAccountReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.TransferAccountReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.TransferAccountReply} TransferAccountReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransferAccountReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransferAccountReply message.
             * @function verify
             * @memberof dcnet.pb.TransferAccountReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransferAccountReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a TransferAccountReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.TransferAccountReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.TransferAccountReply} TransferAccountReply
             */
            TransferAccountReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.TransferAccountReply)
                    return object;
                return new $root.dcnet.pb.TransferAccountReply();
            };

            /**
             * Creates a plain object from a TransferAccountReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.TransferAccountReply
             * @static
             * @param {dcnet.pb.TransferAccountReply} message TransferAccountReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransferAccountReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this TransferAccountReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.TransferAccountReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransferAccountReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TransferAccountReply
             * @function getTypeUrl
             * @memberof dcnet.pb.TransferAccountReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TransferAccountReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.TransferAccountReply";
            };

            return TransferAccountReply;
        })();

        pb.SetUserDefaultDBRequest = (function() {

            /**
             * Properties of a SetUserDefaultDBRequest.
             * @memberof dcnet.pb
             * @interface ISetUserDefaultDBRequest
             * @property {Uint8Array|null} [dbinfocrypt] SetUserDefaultDBRequest dbinfocrypt
             * @property {number|null} [blockheight] SetUserDefaultDBRequest blockheight
             * @property {Uint8Array|null} [peerid] SetUserDefaultDBRequest peerid
             * @property {Uint8Array|null} [signature] SetUserDefaultDBRequest signature
             * @property {Uint8Array|null} [vaccount] SetUserDefaultDBRequest vaccount
             */

            /**
             * Constructs a new SetUserDefaultDBRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a SetUserDefaultDBRequest.
             * @implements ISetUserDefaultDBRequest
             * @constructor
             * @param {dcnet.pb.ISetUserDefaultDBRequest=} [properties] Properties to set
             */
            function SetUserDefaultDBRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetUserDefaultDBRequest dbinfocrypt.
             * @member {Uint8Array} dbinfocrypt
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @instance
             */
            SetUserDefaultDBRequest.prototype.dbinfocrypt = $util.newBuffer([]);

            /**
             * SetUserDefaultDBRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @instance
             */
            SetUserDefaultDBRequest.prototype.blockheight = 0;

            /**
             * SetUserDefaultDBRequest peerid.
             * @member {Uint8Array} peerid
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @instance
             */
            SetUserDefaultDBRequest.prototype.peerid = $util.newBuffer([]);

            /**
             * SetUserDefaultDBRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @instance
             */
            SetUserDefaultDBRequest.prototype.signature = $util.newBuffer([]);

            /**
             * SetUserDefaultDBRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @instance
             */
            SetUserDefaultDBRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new SetUserDefaultDBRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @static
             * @param {dcnet.pb.ISetUserDefaultDBRequest=} [properties] Properties to set
             * @returns {dcnet.pb.SetUserDefaultDBRequest} SetUserDefaultDBRequest instance
             */
            SetUserDefaultDBRequest.create = function create(properties) {
                return new SetUserDefaultDBRequest(properties);
            };

            /**
             * Encodes the specified SetUserDefaultDBRequest message. Does not implicitly {@link dcnet.pb.SetUserDefaultDBRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @static
             * @param {dcnet.pb.ISetUserDefaultDBRequest} message SetUserDefaultDBRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetUserDefaultDBRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dbinfocrypt != null && Object.hasOwnProperty.call(message, "dbinfocrypt"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.dbinfocrypt);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.peerid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified SetUserDefaultDBRequest message, length delimited. Does not implicitly {@link dcnet.pb.SetUserDefaultDBRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @static
             * @param {dcnet.pb.ISetUserDefaultDBRequest} message SetUserDefaultDBRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetUserDefaultDBRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetUserDefaultDBRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SetUserDefaultDBRequest} SetUserDefaultDBRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetUserDefaultDBRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SetUserDefaultDBRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.dbinfocrypt = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.peerid = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetUserDefaultDBRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SetUserDefaultDBRequest} SetUserDefaultDBRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetUserDefaultDBRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetUserDefaultDBRequest message.
             * @function verify
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetUserDefaultDBRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dbinfocrypt != null && message.hasOwnProperty("dbinfocrypt"))
                    if (!(message.dbinfocrypt && typeof message.dbinfocrypt.length === "number" || $util.isString(message.dbinfocrypt)))
                        return "dbinfocrypt: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                        return "peerid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a SetUserDefaultDBRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SetUserDefaultDBRequest} SetUserDefaultDBRequest
             */
            SetUserDefaultDBRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SetUserDefaultDBRequest)
                    return object;
                let message = new $root.dcnet.pb.SetUserDefaultDBRequest();
                if (object.dbinfocrypt != null)
                    if (typeof object.dbinfocrypt === "string")
                        $util.base64.decode(object.dbinfocrypt, message.dbinfocrypt = $util.newBuffer($util.base64.length(object.dbinfocrypt)), 0);
                    else if (object.dbinfocrypt.length >= 0)
                        message.dbinfocrypt = object.dbinfocrypt;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.peerid != null)
                    if (typeof object.peerid === "string")
                        $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                    else if (object.peerid.length >= 0)
                        message.peerid = object.peerid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a SetUserDefaultDBRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @static
             * @param {dcnet.pb.SetUserDefaultDBRequest} message SetUserDefaultDBRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetUserDefaultDBRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.dbinfocrypt = "";
                    else {
                        object.dbinfocrypt = [];
                        if (options.bytes !== Array)
                            object.dbinfocrypt = $util.newBuffer(object.dbinfocrypt);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.peerid = "";
                    else {
                        object.peerid = [];
                        if (options.bytes !== Array)
                            object.peerid = $util.newBuffer(object.peerid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.dbinfocrypt != null && message.hasOwnProperty("dbinfocrypt"))
                    object.dbinfocrypt = options.bytes === String ? $util.base64.encode(message.dbinfocrypt, 0, message.dbinfocrypt.length) : options.bytes === Array ? Array.prototype.slice.call(message.dbinfocrypt) : message.dbinfocrypt;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this SetUserDefaultDBRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetUserDefaultDBRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetUserDefaultDBRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.SetUserDefaultDBRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetUserDefaultDBRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SetUserDefaultDBRequest";
            };

            return SetUserDefaultDBRequest;
        })();

        pb.SetUserDefaultDBReply = (function() {

            /**
             * Properties of a SetUserDefaultDBReply.
             * @memberof dcnet.pb
             * @interface ISetUserDefaultDBReply
             */

            /**
             * Constructs a new SetUserDefaultDBReply.
             * @memberof dcnet.pb
             * @classdesc Represents a SetUserDefaultDBReply.
             * @implements ISetUserDefaultDBReply
             * @constructor
             * @param {dcnet.pb.ISetUserDefaultDBReply=} [properties] Properties to set
             */
            function SetUserDefaultDBReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetUserDefaultDBReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SetUserDefaultDBReply
             * @static
             * @param {dcnet.pb.ISetUserDefaultDBReply=} [properties] Properties to set
             * @returns {dcnet.pb.SetUserDefaultDBReply} SetUserDefaultDBReply instance
             */
            SetUserDefaultDBReply.create = function create(properties) {
                return new SetUserDefaultDBReply(properties);
            };

            /**
             * Encodes the specified SetUserDefaultDBReply message. Does not implicitly {@link dcnet.pb.SetUserDefaultDBReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SetUserDefaultDBReply
             * @static
             * @param {dcnet.pb.ISetUserDefaultDBReply} message SetUserDefaultDBReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetUserDefaultDBReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetUserDefaultDBReply message, length delimited. Does not implicitly {@link dcnet.pb.SetUserDefaultDBReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SetUserDefaultDBReply
             * @static
             * @param {dcnet.pb.ISetUserDefaultDBReply} message SetUserDefaultDBReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetUserDefaultDBReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetUserDefaultDBReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SetUserDefaultDBReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SetUserDefaultDBReply} SetUserDefaultDBReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetUserDefaultDBReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SetUserDefaultDBReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetUserDefaultDBReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SetUserDefaultDBReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SetUserDefaultDBReply} SetUserDefaultDBReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetUserDefaultDBReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetUserDefaultDBReply message.
             * @function verify
             * @memberof dcnet.pb.SetUserDefaultDBReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetUserDefaultDBReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetUserDefaultDBReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SetUserDefaultDBReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SetUserDefaultDBReply} SetUserDefaultDBReply
             */
            SetUserDefaultDBReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SetUserDefaultDBReply)
                    return object;
                return new $root.dcnet.pb.SetUserDefaultDBReply();
            };

            /**
             * Creates a plain object from a SetUserDefaultDBReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SetUserDefaultDBReply
             * @static
             * @param {dcnet.pb.SetUserDefaultDBReply} message SetUserDefaultDBReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetUserDefaultDBReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetUserDefaultDBReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SetUserDefaultDBReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetUserDefaultDBReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetUserDefaultDBReply
             * @function getTypeUrl
             * @memberof dcnet.pb.SetUserDefaultDBReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetUserDefaultDBReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SetUserDefaultDBReply";
            };

            return SetUserDefaultDBReply;
        })();

        pb.AddSubPubkeyRequest = (function() {

            /**
             * Properties of an AddSubPubkeyRequest.
             * @memberof dcnet.pb
             * @interface IAddSubPubkeyRequest
             * @property {Uint8Array|null} [subpubkey] AddSubPubkeyRequest subpubkey
             * @property {number|null} [blockheight] AddSubPubkeyRequest blockheight
             * @property {Uint8Array|null} [peerid] AddSubPubkeyRequest peerid
             * @property {Uint8Array|null} [signature] AddSubPubkeyRequest signature
             * @property {Uint8Array|null} [vaccount] AddSubPubkeyRequest vaccount
             */

            /**
             * Constructs a new AddSubPubkeyRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AddSubPubkeyRequest.
             * @implements IAddSubPubkeyRequest
             * @constructor
             * @param {dcnet.pb.IAddSubPubkeyRequest=} [properties] Properties to set
             */
            function AddSubPubkeyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddSubPubkeyRequest subpubkey.
             * @member {Uint8Array} subpubkey
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @instance
             */
            AddSubPubkeyRequest.prototype.subpubkey = $util.newBuffer([]);

            /**
             * AddSubPubkeyRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @instance
             */
            AddSubPubkeyRequest.prototype.blockheight = 0;

            /**
             * AddSubPubkeyRequest peerid.
             * @member {Uint8Array} peerid
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @instance
             */
            AddSubPubkeyRequest.prototype.peerid = $util.newBuffer([]);

            /**
             * AddSubPubkeyRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @instance
             */
            AddSubPubkeyRequest.prototype.signature = $util.newBuffer([]);

            /**
             * AddSubPubkeyRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @instance
             */
            AddSubPubkeyRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new AddSubPubkeyRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @static
             * @param {dcnet.pb.IAddSubPubkeyRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AddSubPubkeyRequest} AddSubPubkeyRequest instance
             */
            AddSubPubkeyRequest.create = function create(properties) {
                return new AddSubPubkeyRequest(properties);
            };

            /**
             * Encodes the specified AddSubPubkeyRequest message. Does not implicitly {@link dcnet.pb.AddSubPubkeyRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @static
             * @param {dcnet.pb.IAddSubPubkeyRequest} message AddSubPubkeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddSubPubkeyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subpubkey != null && Object.hasOwnProperty.call(message, "subpubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.subpubkey);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.peerid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified AddSubPubkeyRequest message, length delimited. Does not implicitly {@link dcnet.pb.AddSubPubkeyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @static
             * @param {dcnet.pb.IAddSubPubkeyRequest} message AddSubPubkeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddSubPubkeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddSubPubkeyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddSubPubkeyRequest} AddSubPubkeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddSubPubkeyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddSubPubkeyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.subpubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.peerid = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddSubPubkeyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddSubPubkeyRequest} AddSubPubkeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddSubPubkeyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddSubPubkeyRequest message.
             * @function verify
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddSubPubkeyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subpubkey != null && message.hasOwnProperty("subpubkey"))
                    if (!(message.subpubkey && typeof message.subpubkey.length === "number" || $util.isString(message.subpubkey)))
                        return "subpubkey: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                        return "peerid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates an AddSubPubkeyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddSubPubkeyRequest} AddSubPubkeyRequest
             */
            AddSubPubkeyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddSubPubkeyRequest)
                    return object;
                let message = new $root.dcnet.pb.AddSubPubkeyRequest();
                if (object.subpubkey != null)
                    if (typeof object.subpubkey === "string")
                        $util.base64.decode(object.subpubkey, message.subpubkey = $util.newBuffer($util.base64.length(object.subpubkey)), 0);
                    else if (object.subpubkey.length >= 0)
                        message.subpubkey = object.subpubkey;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.peerid != null)
                    if (typeof object.peerid === "string")
                        $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                    else if (object.peerid.length >= 0)
                        message.peerid = object.peerid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from an AddSubPubkeyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @static
             * @param {dcnet.pb.AddSubPubkeyRequest} message AddSubPubkeyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddSubPubkeyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.subpubkey = "";
                    else {
                        object.subpubkey = [];
                        if (options.bytes !== Array)
                            object.subpubkey = $util.newBuffer(object.subpubkey);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.peerid = "";
                    else {
                        object.peerid = [];
                        if (options.bytes !== Array)
                            object.peerid = $util.newBuffer(object.peerid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.subpubkey != null && message.hasOwnProperty("subpubkey"))
                    object.subpubkey = options.bytes === String ? $util.base64.encode(message.subpubkey, 0, message.subpubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.subpubkey) : message.subpubkey;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this AddSubPubkeyRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddSubPubkeyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddSubPubkeyRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AddSubPubkeyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddSubPubkeyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddSubPubkeyRequest";
            };

            return AddSubPubkeyRequest;
        })();

        pb.AddSubPubkeyReply = (function() {

            /**
             * Properties of an AddSubPubkeyReply.
             * @memberof dcnet.pb
             * @interface IAddSubPubkeyReply
             */

            /**
             * Constructs a new AddSubPubkeyReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AddSubPubkeyReply.
             * @implements IAddSubPubkeyReply
             * @constructor
             * @param {dcnet.pb.IAddSubPubkeyReply=} [properties] Properties to set
             */
            function AddSubPubkeyReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AddSubPubkeyReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddSubPubkeyReply
             * @static
             * @param {dcnet.pb.IAddSubPubkeyReply=} [properties] Properties to set
             * @returns {dcnet.pb.AddSubPubkeyReply} AddSubPubkeyReply instance
             */
            AddSubPubkeyReply.create = function create(properties) {
                return new AddSubPubkeyReply(properties);
            };

            /**
             * Encodes the specified AddSubPubkeyReply message. Does not implicitly {@link dcnet.pb.AddSubPubkeyReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddSubPubkeyReply
             * @static
             * @param {dcnet.pb.IAddSubPubkeyReply} message AddSubPubkeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddSubPubkeyReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AddSubPubkeyReply message, length delimited. Does not implicitly {@link dcnet.pb.AddSubPubkeyReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddSubPubkeyReply
             * @static
             * @param {dcnet.pb.IAddSubPubkeyReply} message AddSubPubkeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddSubPubkeyReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddSubPubkeyReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddSubPubkeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddSubPubkeyReply} AddSubPubkeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddSubPubkeyReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddSubPubkeyReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddSubPubkeyReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddSubPubkeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddSubPubkeyReply} AddSubPubkeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddSubPubkeyReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddSubPubkeyReply message.
             * @function verify
             * @memberof dcnet.pb.AddSubPubkeyReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddSubPubkeyReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AddSubPubkeyReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddSubPubkeyReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddSubPubkeyReply} AddSubPubkeyReply
             */
            AddSubPubkeyReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddSubPubkeyReply)
                    return object;
                return new $root.dcnet.pb.AddSubPubkeyReply();
            };

            /**
             * Creates a plain object from an AddSubPubkeyReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddSubPubkeyReply
             * @static
             * @param {dcnet.pb.AddSubPubkeyReply} message AddSubPubkeyReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddSubPubkeyReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AddSubPubkeyReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddSubPubkeyReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddSubPubkeyReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddSubPubkeyReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AddSubPubkeyReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddSubPubkeyReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddSubPubkeyReply";
            };

            return AddSubPubkeyReply;
        })();

        pb.DeleteSubPubkeyRequest = (function() {

            /**
             * Properties of a DeleteSubPubkeyRequest.
             * @memberof dcnet.pb
             * @interface IDeleteSubPubkeyRequest
             * @property {Uint8Array|null} [subpubkey] DeleteSubPubkeyRequest subpubkey
             * @property {number|null} [blockheight] DeleteSubPubkeyRequest blockheight
             * @property {Uint8Array|null} [peerid] DeleteSubPubkeyRequest peerid
             * @property {Uint8Array|null} [signature] DeleteSubPubkeyRequest signature
             * @property {Uint8Array|null} [vaccount] DeleteSubPubkeyRequest vaccount
             */

            /**
             * Constructs a new DeleteSubPubkeyRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteSubPubkeyRequest.
             * @implements IDeleteSubPubkeyRequest
             * @constructor
             * @param {dcnet.pb.IDeleteSubPubkeyRequest=} [properties] Properties to set
             */
            function DeleteSubPubkeyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteSubPubkeyRequest subpubkey.
             * @member {Uint8Array} subpubkey
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @instance
             */
            DeleteSubPubkeyRequest.prototype.subpubkey = $util.newBuffer([]);

            /**
             * DeleteSubPubkeyRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @instance
             */
            DeleteSubPubkeyRequest.prototype.blockheight = 0;

            /**
             * DeleteSubPubkeyRequest peerid.
             * @member {Uint8Array} peerid
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @instance
             */
            DeleteSubPubkeyRequest.prototype.peerid = $util.newBuffer([]);

            /**
             * DeleteSubPubkeyRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @instance
             */
            DeleteSubPubkeyRequest.prototype.signature = $util.newBuffer([]);

            /**
             * DeleteSubPubkeyRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @instance
             */
            DeleteSubPubkeyRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new DeleteSubPubkeyRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @static
             * @param {dcnet.pb.IDeleteSubPubkeyRequest=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteSubPubkeyRequest} DeleteSubPubkeyRequest instance
             */
            DeleteSubPubkeyRequest.create = function create(properties) {
                return new DeleteSubPubkeyRequest(properties);
            };

            /**
             * Encodes the specified DeleteSubPubkeyRequest message. Does not implicitly {@link dcnet.pb.DeleteSubPubkeyRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @static
             * @param {dcnet.pb.IDeleteSubPubkeyRequest} message DeleteSubPubkeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSubPubkeyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subpubkey != null && Object.hasOwnProperty.call(message, "subpubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.subpubkey);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.peerid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified DeleteSubPubkeyRequest message, length delimited. Does not implicitly {@link dcnet.pb.DeleteSubPubkeyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @static
             * @param {dcnet.pb.IDeleteSubPubkeyRequest} message DeleteSubPubkeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSubPubkeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteSubPubkeyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteSubPubkeyRequest} DeleteSubPubkeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSubPubkeyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteSubPubkeyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.subpubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.peerid = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteSubPubkeyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteSubPubkeyRequest} DeleteSubPubkeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSubPubkeyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteSubPubkeyRequest message.
             * @function verify
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteSubPubkeyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subpubkey != null && message.hasOwnProperty("subpubkey"))
                    if (!(message.subpubkey && typeof message.subpubkey.length === "number" || $util.isString(message.subpubkey)))
                        return "subpubkey: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                        return "peerid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a DeleteSubPubkeyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteSubPubkeyRequest} DeleteSubPubkeyRequest
             */
            DeleteSubPubkeyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteSubPubkeyRequest)
                    return object;
                let message = new $root.dcnet.pb.DeleteSubPubkeyRequest();
                if (object.subpubkey != null)
                    if (typeof object.subpubkey === "string")
                        $util.base64.decode(object.subpubkey, message.subpubkey = $util.newBuffer($util.base64.length(object.subpubkey)), 0);
                    else if (object.subpubkey.length >= 0)
                        message.subpubkey = object.subpubkey;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.peerid != null)
                    if (typeof object.peerid === "string")
                        $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                    else if (object.peerid.length >= 0)
                        message.peerid = object.peerid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a DeleteSubPubkeyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @static
             * @param {dcnet.pb.DeleteSubPubkeyRequest} message DeleteSubPubkeyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteSubPubkeyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.subpubkey = "";
                    else {
                        object.subpubkey = [];
                        if (options.bytes !== Array)
                            object.subpubkey = $util.newBuffer(object.subpubkey);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.peerid = "";
                    else {
                        object.peerid = [];
                        if (options.bytes !== Array)
                            object.peerid = $util.newBuffer(object.peerid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.subpubkey != null && message.hasOwnProperty("subpubkey"))
                    object.subpubkey = options.bytes === String ? $util.base64.encode(message.subpubkey, 0, message.subpubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.subpubkey) : message.subpubkey;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this DeleteSubPubkeyRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteSubPubkeyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteSubPubkeyRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteSubPubkeyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteSubPubkeyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteSubPubkeyRequest";
            };

            return DeleteSubPubkeyRequest;
        })();

        pb.DeleteSubPubkeyReply = (function() {

            /**
             * Properties of a DeleteSubPubkeyReply.
             * @memberof dcnet.pb
             * @interface IDeleteSubPubkeyReply
             */

            /**
             * Constructs a new DeleteSubPubkeyReply.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteSubPubkeyReply.
             * @implements IDeleteSubPubkeyReply
             * @constructor
             * @param {dcnet.pb.IDeleteSubPubkeyReply=} [properties] Properties to set
             */
            function DeleteSubPubkeyReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteSubPubkeyReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteSubPubkeyReply
             * @static
             * @param {dcnet.pb.IDeleteSubPubkeyReply=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteSubPubkeyReply} DeleteSubPubkeyReply instance
             */
            DeleteSubPubkeyReply.create = function create(properties) {
                return new DeleteSubPubkeyReply(properties);
            };

            /**
             * Encodes the specified DeleteSubPubkeyReply message. Does not implicitly {@link dcnet.pb.DeleteSubPubkeyReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteSubPubkeyReply
             * @static
             * @param {dcnet.pb.IDeleteSubPubkeyReply} message DeleteSubPubkeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSubPubkeyReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteSubPubkeyReply message, length delimited. Does not implicitly {@link dcnet.pb.DeleteSubPubkeyReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteSubPubkeyReply
             * @static
             * @param {dcnet.pb.IDeleteSubPubkeyReply} message DeleteSubPubkeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSubPubkeyReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteSubPubkeyReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteSubPubkeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteSubPubkeyReply} DeleteSubPubkeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSubPubkeyReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteSubPubkeyReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteSubPubkeyReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteSubPubkeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteSubPubkeyReply} DeleteSubPubkeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSubPubkeyReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteSubPubkeyReply message.
             * @function verify
             * @memberof dcnet.pb.DeleteSubPubkeyReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteSubPubkeyReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteSubPubkeyReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteSubPubkeyReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteSubPubkeyReply} DeleteSubPubkeyReply
             */
            DeleteSubPubkeyReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteSubPubkeyReply)
                    return object;
                return new $root.dcnet.pb.DeleteSubPubkeyReply();
            };

            /**
             * Creates a plain object from a DeleteSubPubkeyReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteSubPubkeyReply
             * @static
             * @param {dcnet.pb.DeleteSubPubkeyReply} message DeleteSubPubkeyReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteSubPubkeyReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteSubPubkeyReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteSubPubkeyReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteSubPubkeyReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteSubPubkeyReply
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteSubPubkeyReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteSubPubkeyReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteSubPubkeyReply";
            };

            return DeleteSubPubkeyReply;
        })();

        pb.BindAccessPeerToUserRequest = (function() {

            /**
             * Properties of a BindAccessPeerToUserRequest.
             * @memberof dcnet.pb
             * @interface IBindAccessPeerToUserRequest
             * @property {number|null} [blockheight] BindAccessPeerToUserRequest blockheight
             * @property {Uint8Array|null} [signature] BindAccessPeerToUserRequest signature
             */

            /**
             * Constructs a new BindAccessPeerToUserRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a BindAccessPeerToUserRequest.
             * @implements IBindAccessPeerToUserRequest
             * @constructor
             * @param {dcnet.pb.IBindAccessPeerToUserRequest=} [properties] Properties to set
             */
            function BindAccessPeerToUserRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BindAccessPeerToUserRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @instance
             */
            BindAccessPeerToUserRequest.prototype.blockheight = 0;

            /**
             * BindAccessPeerToUserRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @instance
             */
            BindAccessPeerToUserRequest.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new BindAccessPeerToUserRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @static
             * @param {dcnet.pb.IBindAccessPeerToUserRequest=} [properties] Properties to set
             * @returns {dcnet.pb.BindAccessPeerToUserRequest} BindAccessPeerToUserRequest instance
             */
            BindAccessPeerToUserRequest.create = function create(properties) {
                return new BindAccessPeerToUserRequest(properties);
            };

            /**
             * Encodes the specified BindAccessPeerToUserRequest message. Does not implicitly {@link dcnet.pb.BindAccessPeerToUserRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @static
             * @param {dcnet.pb.IBindAccessPeerToUserRequest} message BindAccessPeerToUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BindAccessPeerToUserRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.blockheight);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified BindAccessPeerToUserRequest message, length delimited. Does not implicitly {@link dcnet.pb.BindAccessPeerToUserRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @static
             * @param {dcnet.pb.IBindAccessPeerToUserRequest} message BindAccessPeerToUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BindAccessPeerToUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BindAccessPeerToUserRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.BindAccessPeerToUserRequest} BindAccessPeerToUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BindAccessPeerToUserRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.BindAccessPeerToUserRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BindAccessPeerToUserRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.BindAccessPeerToUserRequest} BindAccessPeerToUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BindAccessPeerToUserRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BindAccessPeerToUserRequest message.
             * @function verify
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BindAccessPeerToUserRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a BindAccessPeerToUserRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.BindAccessPeerToUserRequest} BindAccessPeerToUserRequest
             */
            BindAccessPeerToUserRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.BindAccessPeerToUserRequest)
                    return object;
                let message = new $root.dcnet.pb.BindAccessPeerToUserRequest();
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a BindAccessPeerToUserRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @static
             * @param {dcnet.pb.BindAccessPeerToUserRequest} message BindAccessPeerToUserRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BindAccessPeerToUserRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this BindAccessPeerToUserRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BindAccessPeerToUserRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BindAccessPeerToUserRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.BindAccessPeerToUserRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BindAccessPeerToUserRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.BindAccessPeerToUserRequest";
            };

            return BindAccessPeerToUserRequest;
        })();

        pb.BindAccessPeerToUserReply = (function() {

            /**
             * Properties of a BindAccessPeerToUserReply.
             * @memberof dcnet.pb
             * @interface IBindAccessPeerToUserReply
             */

            /**
             * Constructs a new BindAccessPeerToUserReply.
             * @memberof dcnet.pb
             * @classdesc Represents a BindAccessPeerToUserReply.
             * @implements IBindAccessPeerToUserReply
             * @constructor
             * @param {dcnet.pb.IBindAccessPeerToUserReply=} [properties] Properties to set
             */
            function BindAccessPeerToUserReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BindAccessPeerToUserReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.BindAccessPeerToUserReply
             * @static
             * @param {dcnet.pb.IBindAccessPeerToUserReply=} [properties] Properties to set
             * @returns {dcnet.pb.BindAccessPeerToUserReply} BindAccessPeerToUserReply instance
             */
            BindAccessPeerToUserReply.create = function create(properties) {
                return new BindAccessPeerToUserReply(properties);
            };

            /**
             * Encodes the specified BindAccessPeerToUserReply message. Does not implicitly {@link dcnet.pb.BindAccessPeerToUserReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.BindAccessPeerToUserReply
             * @static
             * @param {dcnet.pb.IBindAccessPeerToUserReply} message BindAccessPeerToUserReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BindAccessPeerToUserReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BindAccessPeerToUserReply message, length delimited. Does not implicitly {@link dcnet.pb.BindAccessPeerToUserReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.BindAccessPeerToUserReply
             * @static
             * @param {dcnet.pb.IBindAccessPeerToUserReply} message BindAccessPeerToUserReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BindAccessPeerToUserReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BindAccessPeerToUserReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.BindAccessPeerToUserReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.BindAccessPeerToUserReply} BindAccessPeerToUserReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BindAccessPeerToUserReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.BindAccessPeerToUserReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BindAccessPeerToUserReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.BindAccessPeerToUserReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.BindAccessPeerToUserReply} BindAccessPeerToUserReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BindAccessPeerToUserReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BindAccessPeerToUserReply message.
             * @function verify
             * @memberof dcnet.pb.BindAccessPeerToUserReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BindAccessPeerToUserReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BindAccessPeerToUserReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.BindAccessPeerToUserReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.BindAccessPeerToUserReply} BindAccessPeerToUserReply
             */
            BindAccessPeerToUserReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.BindAccessPeerToUserReply)
                    return object;
                return new $root.dcnet.pb.BindAccessPeerToUserReply();
            };

            /**
             * Creates a plain object from a BindAccessPeerToUserReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.BindAccessPeerToUserReply
             * @static
             * @param {dcnet.pb.BindAccessPeerToUserReply} message BindAccessPeerToUserReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BindAccessPeerToUserReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BindAccessPeerToUserReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.BindAccessPeerToUserReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BindAccessPeerToUserReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BindAccessPeerToUserReply
             * @function getTypeUrl
             * @memberof dcnet.pb.BindAccessPeerToUserReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BindAccessPeerToUserReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.BindAccessPeerToUserReply";
            };

            return BindAccessPeerToUserReply;
        })();

        pb.ValidTokenRequest = (function() {

            /**
             * Properties of a ValidTokenRequest.
             * @memberof dcnet.pb
             * @interface IValidTokenRequest
             */

            /**
             * Constructs a new ValidTokenRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a ValidTokenRequest.
             * @implements IValidTokenRequest
             * @constructor
             * @param {dcnet.pb.IValidTokenRequest=} [properties] Properties to set
             */
            function ValidTokenRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ValidTokenRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ValidTokenRequest
             * @static
             * @param {dcnet.pb.IValidTokenRequest=} [properties] Properties to set
             * @returns {dcnet.pb.ValidTokenRequest} ValidTokenRequest instance
             */
            ValidTokenRequest.create = function create(properties) {
                return new ValidTokenRequest(properties);
            };

            /**
             * Encodes the specified ValidTokenRequest message. Does not implicitly {@link dcnet.pb.ValidTokenRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ValidTokenRequest
             * @static
             * @param {dcnet.pb.IValidTokenRequest} message ValidTokenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValidTokenRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ValidTokenRequest message, length delimited. Does not implicitly {@link dcnet.pb.ValidTokenRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ValidTokenRequest
             * @static
             * @param {dcnet.pb.IValidTokenRequest} message ValidTokenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValidTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ValidTokenRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ValidTokenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ValidTokenRequest} ValidTokenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValidTokenRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ValidTokenRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ValidTokenRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ValidTokenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ValidTokenRequest} ValidTokenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValidTokenRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ValidTokenRequest message.
             * @function verify
             * @memberof dcnet.pb.ValidTokenRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ValidTokenRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ValidTokenRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ValidTokenRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ValidTokenRequest} ValidTokenRequest
             */
            ValidTokenRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ValidTokenRequest)
                    return object;
                return new $root.dcnet.pb.ValidTokenRequest();
            };

            /**
             * Creates a plain object from a ValidTokenRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ValidTokenRequest
             * @static
             * @param {dcnet.pb.ValidTokenRequest} message ValidTokenRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ValidTokenRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ValidTokenRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ValidTokenRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ValidTokenRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ValidTokenRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.ValidTokenRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ValidTokenRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ValidTokenRequest";
            };

            return ValidTokenRequest;
        })();

        pb.ValidTokenReply = (function() {

            /**
             * Properties of a ValidTokenReply.
             * @memberof dcnet.pb
             * @interface IValidTokenReply
             */

            /**
             * Constructs a new ValidTokenReply.
             * @memberof dcnet.pb
             * @classdesc Represents a ValidTokenReply.
             * @implements IValidTokenReply
             * @constructor
             * @param {dcnet.pb.IValidTokenReply=} [properties] Properties to set
             */
            function ValidTokenReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ValidTokenReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ValidTokenReply
             * @static
             * @param {dcnet.pb.IValidTokenReply=} [properties] Properties to set
             * @returns {dcnet.pb.ValidTokenReply} ValidTokenReply instance
             */
            ValidTokenReply.create = function create(properties) {
                return new ValidTokenReply(properties);
            };

            /**
             * Encodes the specified ValidTokenReply message. Does not implicitly {@link dcnet.pb.ValidTokenReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ValidTokenReply
             * @static
             * @param {dcnet.pb.IValidTokenReply} message ValidTokenReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValidTokenReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ValidTokenReply message, length delimited. Does not implicitly {@link dcnet.pb.ValidTokenReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ValidTokenReply
             * @static
             * @param {dcnet.pb.IValidTokenReply} message ValidTokenReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValidTokenReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ValidTokenReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ValidTokenReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ValidTokenReply} ValidTokenReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValidTokenReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ValidTokenReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ValidTokenReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ValidTokenReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ValidTokenReply} ValidTokenReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValidTokenReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ValidTokenReply message.
             * @function verify
             * @memberof dcnet.pb.ValidTokenReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ValidTokenReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ValidTokenReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ValidTokenReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ValidTokenReply} ValidTokenReply
             */
            ValidTokenReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ValidTokenReply)
                    return object;
                return new $root.dcnet.pb.ValidTokenReply();
            };

            /**
             * Creates a plain object from a ValidTokenReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ValidTokenReply
             * @static
             * @param {dcnet.pb.ValidTokenReply} message ValidTokenReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ValidTokenReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ValidTokenReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ValidTokenReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ValidTokenReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ValidTokenReply
             * @function getTypeUrl
             * @memberof dcnet.pb.ValidTokenReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ValidTokenReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ValidTokenReply";
            };

            return ValidTokenReply;
        })();

        pb.AddLogToThreadRequest = (function() {

            /**
             * Properties of an AddLogToThreadRequest.
             * @memberof dcnet.pb
             * @interface IAddLogToThreadRequest
             * @property {Uint8Array|null} [threadID] AddLogToThreadRequest threadID
             * @property {Uint8Array|null} [logID] AddLogToThreadRequest logID
             * @property {number|null} [blockheight] AddLogToThreadRequest blockheight
             * @property {Uint8Array|null} [peerid] AddLogToThreadRequest peerid
             * @property {Uint8Array|null} [signature] AddLogToThreadRequest signature
             * @property {Uint8Array|null} [vaccount] AddLogToThreadRequest vaccount
             */

            /**
             * Constructs a new AddLogToThreadRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AddLogToThreadRequest.
             * @implements IAddLogToThreadRequest
             * @constructor
             * @param {dcnet.pb.IAddLogToThreadRequest=} [properties] Properties to set
             */
            function AddLogToThreadRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddLogToThreadRequest threadID.
             * @member {Uint8Array} threadID
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @instance
             */
            AddLogToThreadRequest.prototype.threadID = $util.newBuffer([]);

            /**
             * AddLogToThreadRequest logID.
             * @member {Uint8Array} logID
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @instance
             */
            AddLogToThreadRequest.prototype.logID = $util.newBuffer([]);

            /**
             * AddLogToThreadRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @instance
             */
            AddLogToThreadRequest.prototype.blockheight = 0;

            /**
             * AddLogToThreadRequest peerid.
             * @member {Uint8Array} peerid
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @instance
             */
            AddLogToThreadRequest.prototype.peerid = $util.newBuffer([]);

            /**
             * AddLogToThreadRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @instance
             */
            AddLogToThreadRequest.prototype.signature = $util.newBuffer([]);

            /**
             * AddLogToThreadRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @instance
             */
            AddLogToThreadRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new AddLogToThreadRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @static
             * @param {dcnet.pb.IAddLogToThreadRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AddLogToThreadRequest} AddLogToThreadRequest instance
             */
            AddLogToThreadRequest.create = function create(properties) {
                return new AddLogToThreadRequest(properties);
            };

            /**
             * Encodes the specified AddLogToThreadRequest message. Does not implicitly {@link dcnet.pb.AddLogToThreadRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @static
             * @param {dcnet.pb.IAddLogToThreadRequest} message AddLogToThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddLogToThreadRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadID != null && Object.hasOwnProperty.call(message, "threadID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.threadID);
                if (message.logID != null && Object.hasOwnProperty.call(message, "logID"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.logID);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.blockheight);
                if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.peerid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified AddLogToThreadRequest message, length delimited. Does not implicitly {@link dcnet.pb.AddLogToThreadRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @static
             * @param {dcnet.pb.IAddLogToThreadRequest} message AddLogToThreadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddLogToThreadRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddLogToThreadRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddLogToThreadRequest} AddLogToThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddLogToThreadRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddLogToThreadRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadID = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.logID = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.peerid = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddLogToThreadRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddLogToThreadRequest} AddLogToThreadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddLogToThreadRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddLogToThreadRequest message.
             * @function verify
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddLogToThreadRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    if (!(message.threadID && typeof message.threadID.length === "number" || $util.isString(message.threadID)))
                        return "threadID: buffer expected";
                if (message.logID != null && message.hasOwnProperty("logID"))
                    if (!(message.logID && typeof message.logID.length === "number" || $util.isString(message.logID)))
                        return "logID: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                        return "peerid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates an AddLogToThreadRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddLogToThreadRequest} AddLogToThreadRequest
             */
            AddLogToThreadRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddLogToThreadRequest)
                    return object;
                let message = new $root.dcnet.pb.AddLogToThreadRequest();
                if (object.threadID != null)
                    if (typeof object.threadID === "string")
                        $util.base64.decode(object.threadID, message.threadID = $util.newBuffer($util.base64.length(object.threadID)), 0);
                    else if (object.threadID.length >= 0)
                        message.threadID = object.threadID;
                if (object.logID != null)
                    if (typeof object.logID === "string")
                        $util.base64.decode(object.logID, message.logID = $util.newBuffer($util.base64.length(object.logID)), 0);
                    else if (object.logID.length >= 0)
                        message.logID = object.logID;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.peerid != null)
                    if (typeof object.peerid === "string")
                        $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                    else if (object.peerid.length >= 0)
                        message.peerid = object.peerid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from an AddLogToThreadRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @static
             * @param {dcnet.pb.AddLogToThreadRequest} message AddLogToThreadRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddLogToThreadRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.threadID = "";
                    else {
                        object.threadID = [];
                        if (options.bytes !== Array)
                            object.threadID = $util.newBuffer(object.threadID);
                    }
                    if (options.bytes === String)
                        object.logID = "";
                    else {
                        object.logID = [];
                        if (options.bytes !== Array)
                            object.logID = $util.newBuffer(object.logID);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.peerid = "";
                    else {
                        object.peerid = [];
                        if (options.bytes !== Array)
                            object.peerid = $util.newBuffer(object.peerid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    object.threadID = options.bytes === String ? $util.base64.encode(message.threadID, 0, message.threadID.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadID) : message.threadID;
                if (message.logID != null && message.hasOwnProperty("logID"))
                    object.logID = options.bytes === String ? $util.base64.encode(message.logID, 0, message.logID.length) : options.bytes === Array ? Array.prototype.slice.call(message.logID) : message.logID;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this AddLogToThreadRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddLogToThreadRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddLogToThreadRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AddLogToThreadRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddLogToThreadRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddLogToThreadRequest";
            };

            return AddLogToThreadRequest;
        })();

        pb.AddLogToThreadReply = (function() {

            /**
             * Properties of an AddLogToThreadReply.
             * @memberof dcnet.pb
             * @interface IAddLogToThreadReply
             */

            /**
             * Constructs a new AddLogToThreadReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AddLogToThreadReply.
             * @implements IAddLogToThreadReply
             * @constructor
             * @param {dcnet.pb.IAddLogToThreadReply=} [properties] Properties to set
             */
            function AddLogToThreadReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AddLogToThreadReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddLogToThreadReply
             * @static
             * @param {dcnet.pb.IAddLogToThreadReply=} [properties] Properties to set
             * @returns {dcnet.pb.AddLogToThreadReply} AddLogToThreadReply instance
             */
            AddLogToThreadReply.create = function create(properties) {
                return new AddLogToThreadReply(properties);
            };

            /**
             * Encodes the specified AddLogToThreadReply message. Does not implicitly {@link dcnet.pb.AddLogToThreadReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddLogToThreadReply
             * @static
             * @param {dcnet.pb.IAddLogToThreadReply} message AddLogToThreadReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddLogToThreadReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AddLogToThreadReply message, length delimited. Does not implicitly {@link dcnet.pb.AddLogToThreadReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddLogToThreadReply
             * @static
             * @param {dcnet.pb.IAddLogToThreadReply} message AddLogToThreadReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddLogToThreadReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddLogToThreadReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddLogToThreadReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddLogToThreadReply} AddLogToThreadReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddLogToThreadReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddLogToThreadReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddLogToThreadReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddLogToThreadReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddLogToThreadReply} AddLogToThreadReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddLogToThreadReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddLogToThreadReply message.
             * @function verify
             * @memberof dcnet.pb.AddLogToThreadReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddLogToThreadReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AddLogToThreadReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddLogToThreadReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddLogToThreadReply} AddLogToThreadReply
             */
            AddLogToThreadReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddLogToThreadReply)
                    return object;
                return new $root.dcnet.pb.AddLogToThreadReply();
            };

            /**
             * Creates a plain object from an AddLogToThreadReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddLogToThreadReply
             * @static
             * @param {dcnet.pb.AddLogToThreadReply} message AddLogToThreadReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddLogToThreadReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AddLogToThreadReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddLogToThreadReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddLogToThreadReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddLogToThreadReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AddLogToThreadReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddLogToThreadReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddLogToThreadReply";
            };

            return AddLogToThreadReply;
        })();

        pb.AddThreadSpaceRequest = (function() {

            /**
             * Properties of an AddThreadSpaceRequest.
             * @memberof dcnet.pb
             * @interface IAddThreadSpaceRequest
             * @property {Uint8Array|null} [threadID] AddThreadSpaceRequest threadID
             * @property {number|null} [blockheight] AddThreadSpaceRequest blockheight
             * @property {number|null} [space] AddThreadSpaceRequest space
             * @property {Uint8Array|null} [signature] AddThreadSpaceRequest signature
             * @property {Uint8Array|null} [vaccount] AddThreadSpaceRequest vaccount
             */

            /**
             * Constructs a new AddThreadSpaceRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AddThreadSpaceRequest.
             * @implements IAddThreadSpaceRequest
             * @constructor
             * @param {dcnet.pb.IAddThreadSpaceRequest=} [properties] Properties to set
             */
            function AddThreadSpaceRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddThreadSpaceRequest threadID.
             * @member {Uint8Array} threadID
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @instance
             */
            AddThreadSpaceRequest.prototype.threadID = $util.newBuffer([]);

            /**
             * AddThreadSpaceRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @instance
             */
            AddThreadSpaceRequest.prototype.blockheight = 0;

            /**
             * AddThreadSpaceRequest space.
             * @member {number} space
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @instance
             */
            AddThreadSpaceRequest.prototype.space = 0;

            /**
             * AddThreadSpaceRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @instance
             */
            AddThreadSpaceRequest.prototype.signature = $util.newBuffer([]);

            /**
             * AddThreadSpaceRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @instance
             */
            AddThreadSpaceRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new AddThreadSpaceRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @static
             * @param {dcnet.pb.IAddThreadSpaceRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AddThreadSpaceRequest} AddThreadSpaceRequest instance
             */
            AddThreadSpaceRequest.create = function create(properties) {
                return new AddThreadSpaceRequest(properties);
            };

            /**
             * Encodes the specified AddThreadSpaceRequest message. Does not implicitly {@link dcnet.pb.AddThreadSpaceRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @static
             * @param {dcnet.pb.IAddThreadSpaceRequest} message AddThreadSpaceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThreadSpaceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadID != null && Object.hasOwnProperty.call(message, "threadID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.threadID);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.space != null && Object.hasOwnProperty.call(message, "space"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.space);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified AddThreadSpaceRequest message, length delimited. Does not implicitly {@link dcnet.pb.AddThreadSpaceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @static
             * @param {dcnet.pb.IAddThreadSpaceRequest} message AddThreadSpaceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThreadSpaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddThreadSpaceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddThreadSpaceRequest} AddThreadSpaceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThreadSpaceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddThreadSpaceRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadID = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.space = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddThreadSpaceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddThreadSpaceRequest} AddThreadSpaceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThreadSpaceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddThreadSpaceRequest message.
             * @function verify
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddThreadSpaceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    if (!(message.threadID && typeof message.threadID.length === "number" || $util.isString(message.threadID)))
                        return "threadID: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.space != null && message.hasOwnProperty("space"))
                    if (!$util.isInteger(message.space))
                        return "space: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates an AddThreadSpaceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddThreadSpaceRequest} AddThreadSpaceRequest
             */
            AddThreadSpaceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddThreadSpaceRequest)
                    return object;
                let message = new $root.dcnet.pb.AddThreadSpaceRequest();
                if (object.threadID != null)
                    if (typeof object.threadID === "string")
                        $util.base64.decode(object.threadID, message.threadID = $util.newBuffer($util.base64.length(object.threadID)), 0);
                    else if (object.threadID.length >= 0)
                        message.threadID = object.threadID;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.space != null)
                    message.space = object.space >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from an AddThreadSpaceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @static
             * @param {dcnet.pb.AddThreadSpaceRequest} message AddThreadSpaceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddThreadSpaceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.threadID = "";
                    else {
                        object.threadID = [];
                        if (options.bytes !== Array)
                            object.threadID = $util.newBuffer(object.threadID);
                    }
                    object.blockheight = 0;
                    object.space = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    object.threadID = options.bytes === String ? $util.base64.encode(message.threadID, 0, message.threadID.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadID) : message.threadID;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.space != null && message.hasOwnProperty("space"))
                    object.space = message.space;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this AddThreadSpaceRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddThreadSpaceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddThreadSpaceRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AddThreadSpaceRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddThreadSpaceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddThreadSpaceRequest";
            };

            return AddThreadSpaceRequest;
        })();

        pb.AddThreadSpaceReply = (function() {

            /**
             * Properties of an AddThreadSpaceReply.
             * @memberof dcnet.pb
             * @interface IAddThreadSpaceReply
             */

            /**
             * Constructs a new AddThreadSpaceReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AddThreadSpaceReply.
             * @implements IAddThreadSpaceReply
             * @constructor
             * @param {dcnet.pb.IAddThreadSpaceReply=} [properties] Properties to set
             */
            function AddThreadSpaceReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AddThreadSpaceReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddThreadSpaceReply
             * @static
             * @param {dcnet.pb.IAddThreadSpaceReply=} [properties] Properties to set
             * @returns {dcnet.pb.AddThreadSpaceReply} AddThreadSpaceReply instance
             */
            AddThreadSpaceReply.create = function create(properties) {
                return new AddThreadSpaceReply(properties);
            };

            /**
             * Encodes the specified AddThreadSpaceReply message. Does not implicitly {@link dcnet.pb.AddThreadSpaceReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddThreadSpaceReply
             * @static
             * @param {dcnet.pb.IAddThreadSpaceReply} message AddThreadSpaceReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThreadSpaceReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AddThreadSpaceReply message, length delimited. Does not implicitly {@link dcnet.pb.AddThreadSpaceReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddThreadSpaceReply
             * @static
             * @param {dcnet.pb.IAddThreadSpaceReply} message AddThreadSpaceReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThreadSpaceReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddThreadSpaceReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddThreadSpaceReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddThreadSpaceReply} AddThreadSpaceReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThreadSpaceReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddThreadSpaceReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddThreadSpaceReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddThreadSpaceReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddThreadSpaceReply} AddThreadSpaceReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThreadSpaceReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddThreadSpaceReply message.
             * @function verify
             * @memberof dcnet.pb.AddThreadSpaceReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddThreadSpaceReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AddThreadSpaceReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddThreadSpaceReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddThreadSpaceReply} AddThreadSpaceReply
             */
            AddThreadSpaceReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddThreadSpaceReply)
                    return object;
                return new $root.dcnet.pb.AddThreadSpaceReply();
            };

            /**
             * Creates a plain object from an AddThreadSpaceReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddThreadSpaceReply
             * @static
             * @param {dcnet.pb.AddThreadSpaceReply} message AddThreadSpaceReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddThreadSpaceReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AddThreadSpaceReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddThreadSpaceReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddThreadSpaceReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddThreadSpaceReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AddThreadSpaceReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddThreadSpaceReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddThreadSpaceReply";
            };

            return AddThreadSpaceReply;
        })();

        pb.GetThreadUsedSpaceRequest = (function() {

            /**
             * Properties of a GetThreadUsedSpaceRequest.
             * @memberof dcnet.pb
             * @interface IGetThreadUsedSpaceRequest
             * @property {Uint8Array|null} [threadID] GetThreadUsedSpaceRequest threadID
             * @property {number|Long|null} [randnum] GetThreadUsedSpaceRequest randnum
             */

            /**
             * Constructs a new GetThreadUsedSpaceRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThreadUsedSpaceRequest.
             * @implements IGetThreadUsedSpaceRequest
             * @constructor
             * @param {dcnet.pb.IGetThreadUsedSpaceRequest=} [properties] Properties to set
             */
            function GetThreadUsedSpaceRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThreadUsedSpaceRequest threadID.
             * @member {Uint8Array} threadID
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @instance
             */
            GetThreadUsedSpaceRequest.prototype.threadID = $util.newBuffer([]);

            /**
             * GetThreadUsedSpaceRequest randnum.
             * @member {number|Long} randnum
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @instance
             */
            GetThreadUsedSpaceRequest.prototype.randnum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new GetThreadUsedSpaceRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @static
             * @param {dcnet.pb.IGetThreadUsedSpaceRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetThreadUsedSpaceRequest} GetThreadUsedSpaceRequest instance
             */
            GetThreadUsedSpaceRequest.create = function create(properties) {
                return new GetThreadUsedSpaceRequest(properties);
            };

            /**
             * Encodes the specified GetThreadUsedSpaceRequest message. Does not implicitly {@link dcnet.pb.GetThreadUsedSpaceRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @static
             * @param {dcnet.pb.IGetThreadUsedSpaceRequest} message GetThreadUsedSpaceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThreadUsedSpaceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadID != null && Object.hasOwnProperty.call(message, "threadID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.threadID);
                if (message.randnum != null && Object.hasOwnProperty.call(message, "randnum"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.randnum);
                return writer;
            };

            /**
             * Encodes the specified GetThreadUsedSpaceRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetThreadUsedSpaceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @static
             * @param {dcnet.pb.IGetThreadUsedSpaceRequest} message GetThreadUsedSpaceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThreadUsedSpaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThreadUsedSpaceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThreadUsedSpaceRequest} GetThreadUsedSpaceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThreadUsedSpaceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThreadUsedSpaceRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threadID = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.randnum = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThreadUsedSpaceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThreadUsedSpaceRequest} GetThreadUsedSpaceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThreadUsedSpaceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThreadUsedSpaceRequest message.
             * @function verify
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThreadUsedSpaceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    if (!(message.threadID && typeof message.threadID.length === "number" || $util.isString(message.threadID)))
                        return "threadID: buffer expected";
                if (message.randnum != null && message.hasOwnProperty("randnum"))
                    if (!$util.isInteger(message.randnum) && !(message.randnum && $util.isInteger(message.randnum.low) && $util.isInteger(message.randnum.high)))
                        return "randnum: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetThreadUsedSpaceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThreadUsedSpaceRequest} GetThreadUsedSpaceRequest
             */
            GetThreadUsedSpaceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThreadUsedSpaceRequest)
                    return object;
                let message = new $root.dcnet.pb.GetThreadUsedSpaceRequest();
                if (object.threadID != null)
                    if (typeof object.threadID === "string")
                        $util.base64.decode(object.threadID, message.threadID = $util.newBuffer($util.base64.length(object.threadID)), 0);
                    else if (object.threadID.length >= 0)
                        message.threadID = object.threadID;
                if (object.randnum != null)
                    if ($util.Long)
                        (message.randnum = $util.Long.fromValue(object.randnum)).unsigned = false;
                    else if (typeof object.randnum === "string")
                        message.randnum = parseInt(object.randnum, 10);
                    else if (typeof object.randnum === "number")
                        message.randnum = object.randnum;
                    else if (typeof object.randnum === "object")
                        message.randnum = new $util.LongBits(object.randnum.low >>> 0, object.randnum.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a GetThreadUsedSpaceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @static
             * @param {dcnet.pb.GetThreadUsedSpaceRequest} message GetThreadUsedSpaceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThreadUsedSpaceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.threadID = "";
                    else {
                        object.threadID = [];
                        if (options.bytes !== Array)
                            object.threadID = $util.newBuffer(object.threadID);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.randnum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.randnum = options.longs === String ? "0" : 0;
                }
                if (message.threadID != null && message.hasOwnProperty("threadID"))
                    object.threadID = options.bytes === String ? $util.base64.encode(message.threadID, 0, message.threadID.length) : options.bytes === Array ? Array.prototype.slice.call(message.threadID) : message.threadID;
                if (message.randnum != null && message.hasOwnProperty("randnum"))
                    if (typeof message.randnum === "number")
                        object.randnum = options.longs === String ? String(message.randnum) : message.randnum;
                    else
                        object.randnum = options.longs === String ? $util.Long.prototype.toString.call(message.randnum) : options.longs === Number ? new $util.LongBits(message.randnum.low >>> 0, message.randnum.high >>> 0).toNumber() : message.randnum;
                return object;
            };

            /**
             * Converts this GetThreadUsedSpaceRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThreadUsedSpaceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThreadUsedSpaceRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThreadUsedSpaceRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThreadUsedSpaceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThreadUsedSpaceRequest";
            };

            return GetThreadUsedSpaceRequest;
        })();

        pb.GetThreadUsedSpaceReply = (function() {

            /**
             * Properties of a GetThreadUsedSpaceReply.
             * @memberof dcnet.pb
             * @interface IGetThreadUsedSpaceReply
             * @property {number|Long|null} [usedsize] GetThreadUsedSpaceReply usedsize
             * @property {Uint8Array|null} [signature] GetThreadUsedSpaceReply signature
             */

            /**
             * Constructs a new GetThreadUsedSpaceReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThreadUsedSpaceReply.
             * @implements IGetThreadUsedSpaceReply
             * @constructor
             * @param {dcnet.pb.IGetThreadUsedSpaceReply=} [properties] Properties to set
             */
            function GetThreadUsedSpaceReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThreadUsedSpaceReply usedsize.
             * @member {number|Long} usedsize
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @instance
             */
            GetThreadUsedSpaceReply.prototype.usedsize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetThreadUsedSpaceReply signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @instance
             */
            GetThreadUsedSpaceReply.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new GetThreadUsedSpaceReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @static
             * @param {dcnet.pb.IGetThreadUsedSpaceReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetThreadUsedSpaceReply} GetThreadUsedSpaceReply instance
             */
            GetThreadUsedSpaceReply.create = function create(properties) {
                return new GetThreadUsedSpaceReply(properties);
            };

            /**
             * Encodes the specified GetThreadUsedSpaceReply message. Does not implicitly {@link dcnet.pb.GetThreadUsedSpaceReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @static
             * @param {dcnet.pb.IGetThreadUsedSpaceReply} message GetThreadUsedSpaceReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThreadUsedSpaceReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.usedsize != null && Object.hasOwnProperty.call(message, "usedsize"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.usedsize);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified GetThreadUsedSpaceReply message, length delimited. Does not implicitly {@link dcnet.pb.GetThreadUsedSpaceReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @static
             * @param {dcnet.pb.IGetThreadUsedSpaceReply} message GetThreadUsedSpaceReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThreadUsedSpaceReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThreadUsedSpaceReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThreadUsedSpaceReply} GetThreadUsedSpaceReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThreadUsedSpaceReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThreadUsedSpaceReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.usedsize = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThreadUsedSpaceReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThreadUsedSpaceReply} GetThreadUsedSpaceReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThreadUsedSpaceReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThreadUsedSpaceReply message.
             * @function verify
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThreadUsedSpaceReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.usedsize != null && message.hasOwnProperty("usedsize"))
                    if (!$util.isInteger(message.usedsize) && !(message.usedsize && $util.isInteger(message.usedsize.low) && $util.isInteger(message.usedsize.high)))
                        return "usedsize: integer|Long expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a GetThreadUsedSpaceReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThreadUsedSpaceReply} GetThreadUsedSpaceReply
             */
            GetThreadUsedSpaceReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThreadUsedSpaceReply)
                    return object;
                let message = new $root.dcnet.pb.GetThreadUsedSpaceReply();
                if (object.usedsize != null)
                    if ($util.Long)
                        (message.usedsize = $util.Long.fromValue(object.usedsize)).unsigned = true;
                    else if (typeof object.usedsize === "string")
                        message.usedsize = parseInt(object.usedsize, 10);
                    else if (typeof object.usedsize === "number")
                        message.usedsize = object.usedsize;
                    else if (typeof object.usedsize === "object")
                        message.usedsize = new $util.LongBits(object.usedsize.low >>> 0, object.usedsize.high >>> 0).toNumber(true);
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a GetThreadUsedSpaceReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @static
             * @param {dcnet.pb.GetThreadUsedSpaceReply} message GetThreadUsedSpaceReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThreadUsedSpaceReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.usedsize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.usedsize = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.usedsize != null && message.hasOwnProperty("usedsize"))
                    if (typeof message.usedsize === "number")
                        object.usedsize = options.longs === String ? String(message.usedsize) : message.usedsize;
                    else
                        object.usedsize = options.longs === String ? $util.Long.prototype.toString.call(message.usedsize) : options.longs === Number ? new $util.LongBits(message.usedsize.low >>> 0, message.usedsize.high >>> 0).toNumber(true) : message.usedsize;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this GetThreadUsedSpaceReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThreadUsedSpaceReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThreadUsedSpaceReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThreadUsedSpaceReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThreadUsedSpaceReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThreadUsedSpaceReply";
            };

            return GetThreadUsedSpaceReply;
        })();

        pb.TeeReportVerifyRequest = (function() {

            /**
             * Properties of a TeeReportVerifyRequest.
             * @memberof dcnet.pb
             * @interface ITeeReportVerifyRequest
             * @property {Uint8Array|null} [teereport] TeeReportVerifyRequest teereport
             */

            /**
             * Constructs a new TeeReportVerifyRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a TeeReportVerifyRequest.
             * @implements ITeeReportVerifyRequest
             * @constructor
             * @param {dcnet.pb.ITeeReportVerifyRequest=} [properties] Properties to set
             */
            function TeeReportVerifyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TeeReportVerifyRequest teereport.
             * @member {Uint8Array} teereport
             * @memberof dcnet.pb.TeeReportVerifyRequest
             * @instance
             */
            TeeReportVerifyRequest.prototype.teereport = $util.newBuffer([]);

            /**
             * Creates a new TeeReportVerifyRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.TeeReportVerifyRequest
             * @static
             * @param {dcnet.pb.ITeeReportVerifyRequest=} [properties] Properties to set
             * @returns {dcnet.pb.TeeReportVerifyRequest} TeeReportVerifyRequest instance
             */
            TeeReportVerifyRequest.create = function create(properties) {
                return new TeeReportVerifyRequest(properties);
            };

            /**
             * Encodes the specified TeeReportVerifyRequest message. Does not implicitly {@link dcnet.pb.TeeReportVerifyRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.TeeReportVerifyRequest
             * @static
             * @param {dcnet.pb.ITeeReportVerifyRequest} message TeeReportVerifyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TeeReportVerifyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.teereport != null && Object.hasOwnProperty.call(message, "teereport"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.teereport);
                return writer;
            };

            /**
             * Encodes the specified TeeReportVerifyRequest message, length delimited. Does not implicitly {@link dcnet.pb.TeeReportVerifyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.TeeReportVerifyRequest
             * @static
             * @param {dcnet.pb.ITeeReportVerifyRequest} message TeeReportVerifyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TeeReportVerifyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TeeReportVerifyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.TeeReportVerifyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.TeeReportVerifyRequest} TeeReportVerifyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TeeReportVerifyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.TeeReportVerifyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.teereport = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TeeReportVerifyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.TeeReportVerifyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.TeeReportVerifyRequest} TeeReportVerifyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TeeReportVerifyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TeeReportVerifyRequest message.
             * @function verify
             * @memberof dcnet.pb.TeeReportVerifyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TeeReportVerifyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    if (!(message.teereport && typeof message.teereport.length === "number" || $util.isString(message.teereport)))
                        return "teereport: buffer expected";
                return null;
            };

            /**
             * Creates a TeeReportVerifyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.TeeReportVerifyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.TeeReportVerifyRequest} TeeReportVerifyRequest
             */
            TeeReportVerifyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.TeeReportVerifyRequest)
                    return object;
                let message = new $root.dcnet.pb.TeeReportVerifyRequest();
                if (object.teereport != null)
                    if (typeof object.teereport === "string")
                        $util.base64.decode(object.teereport, message.teereport = $util.newBuffer($util.base64.length(object.teereport)), 0);
                    else if (object.teereport.length >= 0)
                        message.teereport = object.teereport;
                return message;
            };

            /**
             * Creates a plain object from a TeeReportVerifyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.TeeReportVerifyRequest
             * @static
             * @param {dcnet.pb.TeeReportVerifyRequest} message TeeReportVerifyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TeeReportVerifyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.teereport = "";
                    else {
                        object.teereport = [];
                        if (options.bytes !== Array)
                            object.teereport = $util.newBuffer(object.teereport);
                    }
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    object.teereport = options.bytes === String ? $util.base64.encode(message.teereport, 0, message.teereport.length) : options.bytes === Array ? Array.prototype.slice.call(message.teereport) : message.teereport;
                return object;
            };

            /**
             * Converts this TeeReportVerifyRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.TeeReportVerifyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TeeReportVerifyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TeeReportVerifyRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.TeeReportVerifyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TeeReportVerifyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.TeeReportVerifyRequest";
            };

            return TeeReportVerifyRequest;
        })();

        pb.TeeReportVerifyReply = (function() {

            /**
             * Properties of a TeeReportVerifyReply.
             * @memberof dcnet.pb
             * @interface ITeeReportVerifyReply
             * @property {Uint8Array|null} [report] TeeReportVerifyReply report
             * @property {Uint8Array|null} [signature] TeeReportVerifyReply signature
             */

            /**
             * Constructs a new TeeReportVerifyReply.
             * @memberof dcnet.pb
             * @classdesc Represents a TeeReportVerifyReply.
             * @implements ITeeReportVerifyReply
             * @constructor
             * @param {dcnet.pb.ITeeReportVerifyReply=} [properties] Properties to set
             */
            function TeeReportVerifyReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TeeReportVerifyReply report.
             * @member {Uint8Array} report
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @instance
             */
            TeeReportVerifyReply.prototype.report = $util.newBuffer([]);

            /**
             * TeeReportVerifyReply signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @instance
             */
            TeeReportVerifyReply.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new TeeReportVerifyReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @static
             * @param {dcnet.pb.ITeeReportVerifyReply=} [properties] Properties to set
             * @returns {dcnet.pb.TeeReportVerifyReply} TeeReportVerifyReply instance
             */
            TeeReportVerifyReply.create = function create(properties) {
                return new TeeReportVerifyReply(properties);
            };

            /**
             * Encodes the specified TeeReportVerifyReply message. Does not implicitly {@link dcnet.pb.TeeReportVerifyReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @static
             * @param {dcnet.pb.ITeeReportVerifyReply} message TeeReportVerifyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TeeReportVerifyReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.report != null && Object.hasOwnProperty.call(message, "report"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.report);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified TeeReportVerifyReply message, length delimited. Does not implicitly {@link dcnet.pb.TeeReportVerifyReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @static
             * @param {dcnet.pb.ITeeReportVerifyReply} message TeeReportVerifyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TeeReportVerifyReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TeeReportVerifyReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.TeeReportVerifyReply} TeeReportVerifyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TeeReportVerifyReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.TeeReportVerifyReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.report = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TeeReportVerifyReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.TeeReportVerifyReply} TeeReportVerifyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TeeReportVerifyReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TeeReportVerifyReply message.
             * @function verify
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TeeReportVerifyReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.report != null && message.hasOwnProperty("report"))
                    if (!(message.report && typeof message.report.length === "number" || $util.isString(message.report)))
                        return "report: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a TeeReportVerifyReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.TeeReportVerifyReply} TeeReportVerifyReply
             */
            TeeReportVerifyReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.TeeReportVerifyReply)
                    return object;
                let message = new $root.dcnet.pb.TeeReportVerifyReply();
                if (object.report != null)
                    if (typeof object.report === "string")
                        $util.base64.decode(object.report, message.report = $util.newBuffer($util.base64.length(object.report)), 0);
                    else if (object.report.length >= 0)
                        message.report = object.report;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a TeeReportVerifyReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @static
             * @param {dcnet.pb.TeeReportVerifyReply} message TeeReportVerifyReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TeeReportVerifyReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.report = "";
                    else {
                        object.report = [];
                        if (options.bytes !== Array)
                            object.report = $util.newBuffer(object.report);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.report != null && message.hasOwnProperty("report"))
                    object.report = options.bytes === String ? $util.base64.encode(message.report, 0, message.report.length) : options.bytes === Array ? Array.prototype.slice.call(message.report) : message.report;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this TeeReportVerifyReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TeeReportVerifyReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TeeReportVerifyReply
             * @function getTypeUrl
             * @memberof dcnet.pb.TeeReportVerifyReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TeeReportVerifyReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.TeeReportVerifyReply";
            };

            return TeeReportVerifyReply;
        })();

        pb.SendMsgToUserBoxRequest = (function() {

            /**
             * Properties of a SendMsgToUserBoxRequest.
             * @memberof dcnet.pb
             * @interface ISendMsgToUserBoxRequest
             * @property {dcnet.pb.IUserMsg|null} [msg] SendMsgToUserBoxRequest msg
             * @property {Uint8Array|null} [AuthSignature] SendMsgToUserBoxRequest AuthSignature
             * @property {Uint8Array|null} [PeerId] SendMsgToUserBoxRequest PeerId
             */

            /**
             * Constructs a new SendMsgToUserBoxRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a SendMsgToUserBoxRequest.
             * @implements ISendMsgToUserBoxRequest
             * @constructor
             * @param {dcnet.pb.ISendMsgToUserBoxRequest=} [properties] Properties to set
             */
            function SendMsgToUserBoxRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMsgToUserBoxRequest msg.
             * @member {dcnet.pb.IUserMsg|null|undefined} msg
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @instance
             */
            SendMsgToUserBoxRequest.prototype.msg = null;

            /**
             * SendMsgToUserBoxRequest AuthSignature.
             * @member {Uint8Array} AuthSignature
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @instance
             */
            SendMsgToUserBoxRequest.prototype.AuthSignature = $util.newBuffer([]);

            /**
             * SendMsgToUserBoxRequest PeerId.
             * @member {Uint8Array} PeerId
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @instance
             */
            SendMsgToUserBoxRequest.prototype.PeerId = $util.newBuffer([]);

            /**
             * Creates a new SendMsgToUserBoxRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @static
             * @param {dcnet.pb.ISendMsgToUserBoxRequest=} [properties] Properties to set
             * @returns {dcnet.pb.SendMsgToUserBoxRequest} SendMsgToUserBoxRequest instance
             */
            SendMsgToUserBoxRequest.create = function create(properties) {
                return new SendMsgToUserBoxRequest(properties);
            };

            /**
             * Encodes the specified SendMsgToUserBoxRequest message. Does not implicitly {@link dcnet.pb.SendMsgToUserBoxRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @static
             * @param {dcnet.pb.ISendMsgToUserBoxRequest} message SendMsgToUserBoxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMsgToUserBoxRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    $root.dcnet.pb.UserMsg.encode(message.msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.AuthSignature != null && Object.hasOwnProperty.call(message, "AuthSignature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.AuthSignature);
                if (message.PeerId != null && Object.hasOwnProperty.call(message, "PeerId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.PeerId);
                return writer;
            };

            /**
             * Encodes the specified SendMsgToUserBoxRequest message, length delimited. Does not implicitly {@link dcnet.pb.SendMsgToUserBoxRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @static
             * @param {dcnet.pb.ISendMsgToUserBoxRequest} message SendMsgToUserBoxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMsgToUserBoxRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMsgToUserBoxRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SendMsgToUserBoxRequest} SendMsgToUserBoxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMsgToUserBoxRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SendMsgToUserBoxRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.msg = $root.dcnet.pb.UserMsg.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.AuthSignature = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.PeerId = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMsgToUserBoxRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SendMsgToUserBoxRequest} SendMsgToUserBoxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMsgToUserBoxRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMsgToUserBoxRequest message.
             * @function verify
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMsgToUserBoxRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.msg != null && message.hasOwnProperty("msg")) {
                    let error = $root.dcnet.pb.UserMsg.verify(message.msg);
                    if (error)
                        return "msg." + error;
                }
                if (message.AuthSignature != null && message.hasOwnProperty("AuthSignature"))
                    if (!(message.AuthSignature && typeof message.AuthSignature.length === "number" || $util.isString(message.AuthSignature)))
                        return "AuthSignature: buffer expected";
                if (message.PeerId != null && message.hasOwnProperty("PeerId"))
                    if (!(message.PeerId && typeof message.PeerId.length === "number" || $util.isString(message.PeerId)))
                        return "PeerId: buffer expected";
                return null;
            };

            /**
             * Creates a SendMsgToUserBoxRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SendMsgToUserBoxRequest} SendMsgToUserBoxRequest
             */
            SendMsgToUserBoxRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SendMsgToUserBoxRequest)
                    return object;
                let message = new $root.dcnet.pb.SendMsgToUserBoxRequest();
                if (object.msg != null) {
                    if (typeof object.msg !== "object")
                        throw TypeError(".dcnet.pb.SendMsgToUserBoxRequest.msg: object expected");
                    message.msg = $root.dcnet.pb.UserMsg.fromObject(object.msg);
                }
                if (object.AuthSignature != null)
                    if (typeof object.AuthSignature === "string")
                        $util.base64.decode(object.AuthSignature, message.AuthSignature = $util.newBuffer($util.base64.length(object.AuthSignature)), 0);
                    else if (object.AuthSignature.length >= 0)
                        message.AuthSignature = object.AuthSignature;
                if (object.PeerId != null)
                    if (typeof object.PeerId === "string")
                        $util.base64.decode(object.PeerId, message.PeerId = $util.newBuffer($util.base64.length(object.PeerId)), 0);
                    else if (object.PeerId.length >= 0)
                        message.PeerId = object.PeerId;
                return message;
            };

            /**
             * Creates a plain object from a SendMsgToUserBoxRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @static
             * @param {dcnet.pb.SendMsgToUserBoxRequest} message SendMsgToUserBoxRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMsgToUserBoxRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.msg = null;
                    if (options.bytes === String)
                        object.AuthSignature = "";
                    else {
                        object.AuthSignature = [];
                        if (options.bytes !== Array)
                            object.AuthSignature = $util.newBuffer(object.AuthSignature);
                    }
                    if (options.bytes === String)
                        object.PeerId = "";
                    else {
                        object.PeerId = [];
                        if (options.bytes !== Array)
                            object.PeerId = $util.newBuffer(object.PeerId);
                    }
                }
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = $root.dcnet.pb.UserMsg.toObject(message.msg, options);
                if (message.AuthSignature != null && message.hasOwnProperty("AuthSignature"))
                    object.AuthSignature = options.bytes === String ? $util.base64.encode(message.AuthSignature, 0, message.AuthSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.AuthSignature) : message.AuthSignature;
                if (message.PeerId != null && message.hasOwnProperty("PeerId"))
                    object.PeerId = options.bytes === String ? $util.base64.encode(message.PeerId, 0, message.PeerId.length) : options.bytes === Array ? Array.prototype.slice.call(message.PeerId) : message.PeerId;
                return object;
            };

            /**
             * Converts this SendMsgToUserBoxRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMsgToUserBoxRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMsgToUserBoxRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.SendMsgToUserBoxRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMsgToUserBoxRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SendMsgToUserBoxRequest";
            };

            return SendMsgToUserBoxRequest;
        })();

        pb.SendMsgToUserBoxReply = (function() {

            /**
             * Properties of a SendMsgToUserBoxReply.
             * @memberof dcnet.pb
             * @interface ISendMsgToUserBoxReply
             * @property {number|null} [flag] SendMsgToUserBoxReply flag
             */

            /**
             * Constructs a new SendMsgToUserBoxReply.
             * @memberof dcnet.pb
             * @classdesc Represents a SendMsgToUserBoxReply.
             * @implements ISendMsgToUserBoxReply
             * @constructor
             * @param {dcnet.pb.ISendMsgToUserBoxReply=} [properties] Properties to set
             */
            function SendMsgToUserBoxReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMsgToUserBoxReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.SendMsgToUserBoxReply
             * @instance
             */
            SendMsgToUserBoxReply.prototype.flag = 0;

            /**
             * Creates a new SendMsgToUserBoxReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SendMsgToUserBoxReply
             * @static
             * @param {dcnet.pb.ISendMsgToUserBoxReply=} [properties] Properties to set
             * @returns {dcnet.pb.SendMsgToUserBoxReply} SendMsgToUserBoxReply instance
             */
            SendMsgToUserBoxReply.create = function create(properties) {
                return new SendMsgToUserBoxReply(properties);
            };

            /**
             * Encodes the specified SendMsgToUserBoxReply message. Does not implicitly {@link dcnet.pb.SendMsgToUserBoxReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SendMsgToUserBoxReply
             * @static
             * @param {dcnet.pb.ISendMsgToUserBoxReply} message SendMsgToUserBoxReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMsgToUserBoxReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified SendMsgToUserBoxReply message, length delimited. Does not implicitly {@link dcnet.pb.SendMsgToUserBoxReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SendMsgToUserBoxReply
             * @static
             * @param {dcnet.pb.ISendMsgToUserBoxReply} message SendMsgToUserBoxReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMsgToUserBoxReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMsgToUserBoxReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SendMsgToUserBoxReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SendMsgToUserBoxReply} SendMsgToUserBoxReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMsgToUserBoxReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SendMsgToUserBoxReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMsgToUserBoxReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SendMsgToUserBoxReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SendMsgToUserBoxReply} SendMsgToUserBoxReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMsgToUserBoxReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMsgToUserBoxReply message.
             * @function verify
             * @memberof dcnet.pb.SendMsgToUserBoxReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMsgToUserBoxReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a SendMsgToUserBoxReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SendMsgToUserBoxReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SendMsgToUserBoxReply} SendMsgToUserBoxReply
             */
            SendMsgToUserBoxReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SendMsgToUserBoxReply)
                    return object;
                let message = new $root.dcnet.pb.SendMsgToUserBoxReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMsgToUserBoxReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SendMsgToUserBoxReply
             * @static
             * @param {dcnet.pb.SendMsgToUserBoxReply} message SendMsgToUserBoxReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMsgToUserBoxReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this SendMsgToUserBoxReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SendMsgToUserBoxReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMsgToUserBoxReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMsgToUserBoxReply
             * @function getTypeUrl
             * @memberof dcnet.pb.SendMsgToUserBoxReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMsgToUserBoxReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SendMsgToUserBoxReply";
            };

            return SendMsgToUserBoxReply;
        })();

        pb.GetToUserBoxAuthRequest = (function() {

            /**
             * Properties of a GetToUserBoxAuthRequest.
             * @memberof dcnet.pb
             * @interface IGetToUserBoxAuthRequest
             * @property {Uint8Array|null} [msgSignature] GetToUserBoxAuthRequest msgSignature
             */

            /**
             * Constructs a new GetToUserBoxAuthRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetToUserBoxAuthRequest.
             * @implements IGetToUserBoxAuthRequest
             * @constructor
             * @param {dcnet.pb.IGetToUserBoxAuthRequest=} [properties] Properties to set
             */
            function GetToUserBoxAuthRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetToUserBoxAuthRequest msgSignature.
             * @member {Uint8Array} msgSignature
             * @memberof dcnet.pb.GetToUserBoxAuthRequest
             * @instance
             */
            GetToUserBoxAuthRequest.prototype.msgSignature = $util.newBuffer([]);

            /**
             * Creates a new GetToUserBoxAuthRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetToUserBoxAuthRequest
             * @static
             * @param {dcnet.pb.IGetToUserBoxAuthRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetToUserBoxAuthRequest} GetToUserBoxAuthRequest instance
             */
            GetToUserBoxAuthRequest.create = function create(properties) {
                return new GetToUserBoxAuthRequest(properties);
            };

            /**
             * Encodes the specified GetToUserBoxAuthRequest message. Does not implicitly {@link dcnet.pb.GetToUserBoxAuthRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetToUserBoxAuthRequest
             * @static
             * @param {dcnet.pb.IGetToUserBoxAuthRequest} message GetToUserBoxAuthRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetToUserBoxAuthRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.msgSignature != null && Object.hasOwnProperty.call(message, "msgSignature"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.msgSignature);
                return writer;
            };

            /**
             * Encodes the specified GetToUserBoxAuthRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetToUserBoxAuthRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetToUserBoxAuthRequest
             * @static
             * @param {dcnet.pb.IGetToUserBoxAuthRequest} message GetToUserBoxAuthRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetToUserBoxAuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetToUserBoxAuthRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetToUserBoxAuthRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetToUserBoxAuthRequest} GetToUserBoxAuthRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetToUserBoxAuthRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetToUserBoxAuthRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.msgSignature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetToUserBoxAuthRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetToUserBoxAuthRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetToUserBoxAuthRequest} GetToUserBoxAuthRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetToUserBoxAuthRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetToUserBoxAuthRequest message.
             * @function verify
             * @memberof dcnet.pb.GetToUserBoxAuthRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetToUserBoxAuthRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.msgSignature != null && message.hasOwnProperty("msgSignature"))
                    if (!(message.msgSignature && typeof message.msgSignature.length === "number" || $util.isString(message.msgSignature)))
                        return "msgSignature: buffer expected";
                return null;
            };

            /**
             * Creates a GetToUserBoxAuthRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetToUserBoxAuthRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetToUserBoxAuthRequest} GetToUserBoxAuthRequest
             */
            GetToUserBoxAuthRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetToUserBoxAuthRequest)
                    return object;
                let message = new $root.dcnet.pb.GetToUserBoxAuthRequest();
                if (object.msgSignature != null)
                    if (typeof object.msgSignature === "string")
                        $util.base64.decode(object.msgSignature, message.msgSignature = $util.newBuffer($util.base64.length(object.msgSignature)), 0);
                    else if (object.msgSignature.length >= 0)
                        message.msgSignature = object.msgSignature;
                return message;
            };

            /**
             * Creates a plain object from a GetToUserBoxAuthRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetToUserBoxAuthRequest
             * @static
             * @param {dcnet.pb.GetToUserBoxAuthRequest} message GetToUserBoxAuthRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetToUserBoxAuthRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.msgSignature = "";
                    else {
                        object.msgSignature = [];
                        if (options.bytes !== Array)
                            object.msgSignature = $util.newBuffer(object.msgSignature);
                    }
                if (message.msgSignature != null && message.hasOwnProperty("msgSignature"))
                    object.msgSignature = options.bytes === String ? $util.base64.encode(message.msgSignature, 0, message.msgSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.msgSignature) : message.msgSignature;
                return object;
            };

            /**
             * Converts this GetToUserBoxAuthRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetToUserBoxAuthRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetToUserBoxAuthRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetToUserBoxAuthRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetToUserBoxAuthRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetToUserBoxAuthRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetToUserBoxAuthRequest";
            };

            return GetToUserBoxAuthRequest;
        })();

        pb.GetToUserBoxAuthReply = (function() {

            /**
             * Properties of a GetToUserBoxAuthReply.
             * @memberof dcnet.pb
             * @interface IGetToUserBoxAuthReply
             * @property {Uint8Array|null} [signature] GetToUserBoxAuthReply signature
             */

            /**
             * Constructs a new GetToUserBoxAuthReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetToUserBoxAuthReply.
             * @implements IGetToUserBoxAuthReply
             * @constructor
             * @param {dcnet.pb.IGetToUserBoxAuthReply=} [properties] Properties to set
             */
            function GetToUserBoxAuthReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetToUserBoxAuthReply signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.GetToUserBoxAuthReply
             * @instance
             */
            GetToUserBoxAuthReply.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new GetToUserBoxAuthReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetToUserBoxAuthReply
             * @static
             * @param {dcnet.pb.IGetToUserBoxAuthReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetToUserBoxAuthReply} GetToUserBoxAuthReply instance
             */
            GetToUserBoxAuthReply.create = function create(properties) {
                return new GetToUserBoxAuthReply(properties);
            };

            /**
             * Encodes the specified GetToUserBoxAuthReply message. Does not implicitly {@link dcnet.pb.GetToUserBoxAuthReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetToUserBoxAuthReply
             * @static
             * @param {dcnet.pb.IGetToUserBoxAuthReply} message GetToUserBoxAuthReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetToUserBoxAuthReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified GetToUserBoxAuthReply message, length delimited. Does not implicitly {@link dcnet.pb.GetToUserBoxAuthReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetToUserBoxAuthReply
             * @static
             * @param {dcnet.pb.IGetToUserBoxAuthReply} message GetToUserBoxAuthReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetToUserBoxAuthReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetToUserBoxAuthReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetToUserBoxAuthReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetToUserBoxAuthReply} GetToUserBoxAuthReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetToUserBoxAuthReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetToUserBoxAuthReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetToUserBoxAuthReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetToUserBoxAuthReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetToUserBoxAuthReply} GetToUserBoxAuthReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetToUserBoxAuthReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetToUserBoxAuthReply message.
             * @function verify
             * @memberof dcnet.pb.GetToUserBoxAuthReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetToUserBoxAuthReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a GetToUserBoxAuthReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetToUserBoxAuthReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetToUserBoxAuthReply} GetToUserBoxAuthReply
             */
            GetToUserBoxAuthReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetToUserBoxAuthReply)
                    return object;
                let message = new $root.dcnet.pb.GetToUserBoxAuthReply();
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a GetToUserBoxAuthReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetToUserBoxAuthReply
             * @static
             * @param {dcnet.pb.GetToUserBoxAuthReply} message GetToUserBoxAuthReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetToUserBoxAuthReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this GetToUserBoxAuthReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetToUserBoxAuthReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetToUserBoxAuthReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetToUserBoxAuthReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetToUserBoxAuthReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetToUserBoxAuthReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetToUserBoxAuthReply";
            };

            return GetToUserBoxAuthReply;
        })();

        pb.GetMaxKeyFromUserBoxRequest = (function() {

            /**
             * Properties of a GetMaxKeyFromUserBoxRequest.
             * @memberof dcnet.pb
             * @interface IGetMaxKeyFromUserBoxRequest
             * @property {Uint8Array|null} [appId] GetMaxKeyFromUserBoxRequest appId
             */

            /**
             * Constructs a new GetMaxKeyFromUserBoxRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetMaxKeyFromUserBoxRequest.
             * @implements IGetMaxKeyFromUserBoxRequest
             * @constructor
             * @param {dcnet.pb.IGetMaxKeyFromUserBoxRequest=} [properties] Properties to set
             */
            function GetMaxKeyFromUserBoxRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMaxKeyFromUserBoxRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxRequest
             * @instance
             */
            GetMaxKeyFromUserBoxRequest.prototype.appId = $util.newBuffer([]);

            /**
             * Creates a new GetMaxKeyFromUserBoxRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxRequest
             * @static
             * @param {dcnet.pb.IGetMaxKeyFromUserBoxRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetMaxKeyFromUserBoxRequest} GetMaxKeyFromUserBoxRequest instance
             */
            GetMaxKeyFromUserBoxRequest.create = function create(properties) {
                return new GetMaxKeyFromUserBoxRequest(properties);
            };

            /**
             * Encodes the specified GetMaxKeyFromUserBoxRequest message. Does not implicitly {@link dcnet.pb.GetMaxKeyFromUserBoxRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxRequest
             * @static
             * @param {dcnet.pb.IGetMaxKeyFromUserBoxRequest} message GetMaxKeyFromUserBoxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMaxKeyFromUserBoxRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.appId);
                return writer;
            };

            /**
             * Encodes the specified GetMaxKeyFromUserBoxRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetMaxKeyFromUserBoxRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxRequest
             * @static
             * @param {dcnet.pb.IGetMaxKeyFromUserBoxRequest} message GetMaxKeyFromUserBoxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMaxKeyFromUserBoxRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMaxKeyFromUserBoxRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetMaxKeyFromUserBoxRequest} GetMaxKeyFromUserBoxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMaxKeyFromUserBoxRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetMaxKeyFromUserBoxRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.appId = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMaxKeyFromUserBoxRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetMaxKeyFromUserBoxRequest} GetMaxKeyFromUserBoxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMaxKeyFromUserBoxRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMaxKeyFromUserBoxRequest message.
             * @function verify
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMaxKeyFromUserBoxRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                return null;
            };

            /**
             * Creates a GetMaxKeyFromUserBoxRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetMaxKeyFromUserBoxRequest} GetMaxKeyFromUserBoxRequest
             */
            GetMaxKeyFromUserBoxRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetMaxKeyFromUserBoxRequest)
                    return object;
                let message = new $root.dcnet.pb.GetMaxKeyFromUserBoxRequest();
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                return message;
            };

            /**
             * Creates a plain object from a GetMaxKeyFromUserBoxRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxRequest
             * @static
             * @param {dcnet.pb.GetMaxKeyFromUserBoxRequest} message GetMaxKeyFromUserBoxRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMaxKeyFromUserBoxRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                return object;
            };

            /**
             * Converts this GetMaxKeyFromUserBoxRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMaxKeyFromUserBoxRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMaxKeyFromUserBoxRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMaxKeyFromUserBoxRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetMaxKeyFromUserBoxRequest";
            };

            return GetMaxKeyFromUserBoxRequest;
        })();

        pb.GetMaxKeyFromUserBoxReply = (function() {

            /**
             * Properties of a GetMaxKeyFromUserBoxReply.
             * @memberof dcnet.pb
             * @interface IGetMaxKeyFromUserBoxReply
             * @property {Uint8Array|null} [maxkey] GetMaxKeyFromUserBoxReply maxkey
             */

            /**
             * Constructs a new GetMaxKeyFromUserBoxReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetMaxKeyFromUserBoxReply.
             * @implements IGetMaxKeyFromUserBoxReply
             * @constructor
             * @param {dcnet.pb.IGetMaxKeyFromUserBoxReply=} [properties] Properties to set
             */
            function GetMaxKeyFromUserBoxReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMaxKeyFromUserBoxReply maxkey.
             * @member {Uint8Array} maxkey
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxReply
             * @instance
             */
            GetMaxKeyFromUserBoxReply.prototype.maxkey = $util.newBuffer([]);

            /**
             * Creates a new GetMaxKeyFromUserBoxReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxReply
             * @static
             * @param {dcnet.pb.IGetMaxKeyFromUserBoxReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetMaxKeyFromUserBoxReply} GetMaxKeyFromUserBoxReply instance
             */
            GetMaxKeyFromUserBoxReply.create = function create(properties) {
                return new GetMaxKeyFromUserBoxReply(properties);
            };

            /**
             * Encodes the specified GetMaxKeyFromUserBoxReply message. Does not implicitly {@link dcnet.pb.GetMaxKeyFromUserBoxReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxReply
             * @static
             * @param {dcnet.pb.IGetMaxKeyFromUserBoxReply} message GetMaxKeyFromUserBoxReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMaxKeyFromUserBoxReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.maxkey != null && Object.hasOwnProperty.call(message, "maxkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.maxkey);
                return writer;
            };

            /**
             * Encodes the specified GetMaxKeyFromUserBoxReply message, length delimited. Does not implicitly {@link dcnet.pb.GetMaxKeyFromUserBoxReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxReply
             * @static
             * @param {dcnet.pb.IGetMaxKeyFromUserBoxReply} message GetMaxKeyFromUserBoxReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMaxKeyFromUserBoxReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMaxKeyFromUserBoxReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetMaxKeyFromUserBoxReply} GetMaxKeyFromUserBoxReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMaxKeyFromUserBoxReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetMaxKeyFromUserBoxReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.maxkey = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMaxKeyFromUserBoxReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetMaxKeyFromUserBoxReply} GetMaxKeyFromUserBoxReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMaxKeyFromUserBoxReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMaxKeyFromUserBoxReply message.
             * @function verify
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMaxKeyFromUserBoxReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.maxkey != null && message.hasOwnProperty("maxkey"))
                    if (!(message.maxkey && typeof message.maxkey.length === "number" || $util.isString(message.maxkey)))
                        return "maxkey: buffer expected";
                return null;
            };

            /**
             * Creates a GetMaxKeyFromUserBoxReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetMaxKeyFromUserBoxReply} GetMaxKeyFromUserBoxReply
             */
            GetMaxKeyFromUserBoxReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetMaxKeyFromUserBoxReply)
                    return object;
                let message = new $root.dcnet.pb.GetMaxKeyFromUserBoxReply();
                if (object.maxkey != null)
                    if (typeof object.maxkey === "string")
                        $util.base64.decode(object.maxkey, message.maxkey = $util.newBuffer($util.base64.length(object.maxkey)), 0);
                    else if (object.maxkey.length >= 0)
                        message.maxkey = object.maxkey;
                return message;
            };

            /**
             * Creates a plain object from a GetMaxKeyFromUserBoxReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxReply
             * @static
             * @param {dcnet.pb.GetMaxKeyFromUserBoxReply} message GetMaxKeyFromUserBoxReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMaxKeyFromUserBoxReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.maxkey = "";
                    else {
                        object.maxkey = [];
                        if (options.bytes !== Array)
                            object.maxkey = $util.newBuffer(object.maxkey);
                    }
                if (message.maxkey != null && message.hasOwnProperty("maxkey"))
                    object.maxkey = options.bytes === String ? $util.base64.encode(message.maxkey, 0, message.maxkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.maxkey) : message.maxkey;
                return object;
            };

            /**
             * Converts this GetMaxKeyFromUserBoxReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMaxKeyFromUserBoxReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMaxKeyFromUserBoxReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetMaxKeyFromUserBoxReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMaxKeyFromUserBoxReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetMaxKeyFromUserBoxReply";
            };

            return GetMaxKeyFromUserBoxReply;
        })();

        pb.GetMsgFromUserBoxRequest = (function() {

            /**
             * Properties of a GetMsgFromUserBoxRequest.
             * @memberof dcnet.pb
             * @interface IGetMsgFromUserBoxRequest
             * @property {Uint8Array|null} [appId] GetMsgFromUserBoxRequest appId
             * @property {number|null} [blockheight] GetMsgFromUserBoxRequest blockheight
             * @property {Uint8Array|null} [seekKey] GetMsgFromUserBoxRequest seekKey
             * @property {number|null} [limit] GetMsgFromUserBoxRequest limit
             */

            /**
             * Constructs a new GetMsgFromUserBoxRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetMsgFromUserBoxRequest.
             * @implements IGetMsgFromUserBoxRequest
             * @constructor
             * @param {dcnet.pb.IGetMsgFromUserBoxRequest=} [properties] Properties to set
             */
            function GetMsgFromUserBoxRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMsgFromUserBoxRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @instance
             */
            GetMsgFromUserBoxRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetMsgFromUserBoxRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @instance
             */
            GetMsgFromUserBoxRequest.prototype.blockheight = 0;

            /**
             * GetMsgFromUserBoxRequest seekKey.
             * @member {Uint8Array} seekKey
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @instance
             */
            GetMsgFromUserBoxRequest.prototype.seekKey = $util.newBuffer([]);

            /**
             * GetMsgFromUserBoxRequest limit.
             * @member {number} limit
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @instance
             */
            GetMsgFromUserBoxRequest.prototype.limit = 0;

            /**
             * Creates a new GetMsgFromUserBoxRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @static
             * @param {dcnet.pb.IGetMsgFromUserBoxRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetMsgFromUserBoxRequest} GetMsgFromUserBoxRequest instance
             */
            GetMsgFromUserBoxRequest.create = function create(properties) {
                return new GetMsgFromUserBoxRequest(properties);
            };

            /**
             * Encodes the specified GetMsgFromUserBoxRequest message. Does not implicitly {@link dcnet.pb.GetMsgFromUserBoxRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @static
             * @param {dcnet.pb.IGetMsgFromUserBoxRequest} message GetMsgFromUserBoxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMsgFromUserBoxRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.appId);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.seekKey != null && Object.hasOwnProperty.call(message, "seekKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.seekKey);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.limit);
                return writer;
            };

            /**
             * Encodes the specified GetMsgFromUserBoxRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetMsgFromUserBoxRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @static
             * @param {dcnet.pb.IGetMsgFromUserBoxRequest} message GetMsgFromUserBoxRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMsgFromUserBoxRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMsgFromUserBoxRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetMsgFromUserBoxRequest} GetMsgFromUserBoxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMsgFromUserBoxRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetMsgFromUserBoxRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.seekKey = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.limit = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMsgFromUserBoxRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetMsgFromUserBoxRequest} GetMsgFromUserBoxRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMsgFromUserBoxRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMsgFromUserBoxRequest message.
             * @function verify
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMsgFromUserBoxRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    if (!(message.seekKey && typeof message.seekKey.length === "number" || $util.isString(message.seekKey)))
                        return "seekKey: buffer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                return null;
            };

            /**
             * Creates a GetMsgFromUserBoxRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetMsgFromUserBoxRequest} GetMsgFromUserBoxRequest
             */
            GetMsgFromUserBoxRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetMsgFromUserBoxRequest)
                    return object;
                let message = new $root.dcnet.pb.GetMsgFromUserBoxRequest();
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.seekKey != null)
                    if (typeof object.seekKey === "string")
                        $util.base64.decode(object.seekKey, message.seekKey = $util.newBuffer($util.base64.length(object.seekKey)), 0);
                    else if (object.seekKey.length >= 0)
                        message.seekKey = object.seekKey;
                if (object.limit != null)
                    message.limit = object.limit >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetMsgFromUserBoxRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @static
             * @param {dcnet.pb.GetMsgFromUserBoxRequest} message GetMsgFromUserBoxRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMsgFromUserBoxRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.seekKey = "";
                    else {
                        object.seekKey = [];
                        if (options.bytes !== Array)
                            object.seekKey = $util.newBuffer(object.seekKey);
                    }
                    object.limit = 0;
                }
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    object.seekKey = options.bytes === String ? $util.base64.encode(message.seekKey, 0, message.seekKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.seekKey) : message.seekKey;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                return object;
            };

            /**
             * Converts this GetMsgFromUserBoxRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMsgFromUserBoxRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMsgFromUserBoxRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetMsgFromUserBoxRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMsgFromUserBoxRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetMsgFromUserBoxRequest";
            };

            return GetMsgFromUserBoxRequest;
        })();

        pb.GetMsgFromUserBoxReply = (function() {

            /**
             * Properties of a GetMsgFromUserBoxReply.
             * @memberof dcnet.pb
             * @interface IGetMsgFromUserBoxReply
             * @property {Array.<dcnet.pb.IUserMsg>|null} [msgs] GetMsgFromUserBoxReply msgs
             */

            /**
             * Constructs a new GetMsgFromUserBoxReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetMsgFromUserBoxReply.
             * @implements IGetMsgFromUserBoxReply
             * @constructor
             * @param {dcnet.pb.IGetMsgFromUserBoxReply=} [properties] Properties to set
             */
            function GetMsgFromUserBoxReply(properties) {
                this.msgs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMsgFromUserBoxReply msgs.
             * @member {Array.<dcnet.pb.IUserMsg>} msgs
             * @memberof dcnet.pb.GetMsgFromUserBoxReply
             * @instance
             */
            GetMsgFromUserBoxReply.prototype.msgs = $util.emptyArray;

            /**
             * Creates a new GetMsgFromUserBoxReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetMsgFromUserBoxReply
             * @static
             * @param {dcnet.pb.IGetMsgFromUserBoxReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetMsgFromUserBoxReply} GetMsgFromUserBoxReply instance
             */
            GetMsgFromUserBoxReply.create = function create(properties) {
                return new GetMsgFromUserBoxReply(properties);
            };

            /**
             * Encodes the specified GetMsgFromUserBoxReply message. Does not implicitly {@link dcnet.pb.GetMsgFromUserBoxReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetMsgFromUserBoxReply
             * @static
             * @param {dcnet.pb.IGetMsgFromUserBoxReply} message GetMsgFromUserBoxReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMsgFromUserBoxReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.msgs != null && message.msgs.length)
                    for (let i = 0; i < message.msgs.length; ++i)
                        $root.dcnet.pb.UserMsg.encode(message.msgs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetMsgFromUserBoxReply message, length delimited. Does not implicitly {@link dcnet.pb.GetMsgFromUserBoxReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetMsgFromUserBoxReply
             * @static
             * @param {dcnet.pb.IGetMsgFromUserBoxReply} message GetMsgFromUserBoxReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMsgFromUserBoxReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMsgFromUserBoxReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetMsgFromUserBoxReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetMsgFromUserBoxReply} GetMsgFromUserBoxReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMsgFromUserBoxReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetMsgFromUserBoxReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.msgs && message.msgs.length))
                                message.msgs = [];
                            message.msgs.push($root.dcnet.pb.UserMsg.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMsgFromUserBoxReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetMsgFromUserBoxReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetMsgFromUserBoxReply} GetMsgFromUserBoxReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMsgFromUserBoxReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMsgFromUserBoxReply message.
             * @function verify
             * @memberof dcnet.pb.GetMsgFromUserBoxReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMsgFromUserBoxReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.msgs != null && message.hasOwnProperty("msgs")) {
                    if (!Array.isArray(message.msgs))
                        return "msgs: array expected";
                    for (let i = 0; i < message.msgs.length; ++i) {
                        let error = $root.dcnet.pb.UserMsg.verify(message.msgs[i]);
                        if (error)
                            return "msgs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetMsgFromUserBoxReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetMsgFromUserBoxReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetMsgFromUserBoxReply} GetMsgFromUserBoxReply
             */
            GetMsgFromUserBoxReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetMsgFromUserBoxReply)
                    return object;
                let message = new $root.dcnet.pb.GetMsgFromUserBoxReply();
                if (object.msgs) {
                    if (!Array.isArray(object.msgs))
                        throw TypeError(".dcnet.pb.GetMsgFromUserBoxReply.msgs: array expected");
                    message.msgs = [];
                    for (let i = 0; i < object.msgs.length; ++i) {
                        if (typeof object.msgs[i] !== "object")
                            throw TypeError(".dcnet.pb.GetMsgFromUserBoxReply.msgs: object expected");
                        message.msgs[i] = $root.dcnet.pb.UserMsg.fromObject(object.msgs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetMsgFromUserBoxReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetMsgFromUserBoxReply
             * @static
             * @param {dcnet.pb.GetMsgFromUserBoxReply} message GetMsgFromUserBoxReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMsgFromUserBoxReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.msgs = [];
                if (message.msgs && message.msgs.length) {
                    object.msgs = [];
                    for (let j = 0; j < message.msgs.length; ++j)
                        object.msgs[j] = $root.dcnet.pb.UserMsg.toObject(message.msgs[j], options);
                }
                return object;
            };

            /**
             * Converts this GetMsgFromUserBoxReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetMsgFromUserBoxReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMsgFromUserBoxReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMsgFromUserBoxReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetMsgFromUserBoxReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMsgFromUserBoxReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetMsgFromUserBoxReply";
            };

            return GetMsgFromUserBoxReply;
        })();

        pb.UserMsg = (function() {

            /**
             * Properties of a UserMsg.
             * @memberof dcnet.pb
             * @interface IUserMsg
             * @property {Uint8Array|null} [messageId] UserMsg messageId
             * @property {Uint8Array|null} [senderPubkey] UserMsg senderPubkey
             * @property {Uint8Array|null} [receiverPubkey] UserMsg receiverPubkey
             * @property {Uint8Array|null} [appId] UserMsg appId
             * @property {number|null} [blockheight] UserMsg blockheight
             * @property {Uint8Array|null} [encryptMsg] UserMsg encryptMsg
             * @property {Uint8Array|null} [signature] UserMsg signature
             */

            /**
             * Constructs a new UserMsg.
             * @memberof dcnet.pb
             * @classdesc Represents a UserMsg.
             * @implements IUserMsg
             * @constructor
             * @param {dcnet.pb.IUserMsg=} [properties] Properties to set
             */
            function UserMsg(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UserMsg messageId.
             * @member {Uint8Array} messageId
             * @memberof dcnet.pb.UserMsg
             * @instance
             */
            UserMsg.prototype.messageId = $util.newBuffer([]);

            /**
             * UserMsg senderPubkey.
             * @member {Uint8Array} senderPubkey
             * @memberof dcnet.pb.UserMsg
             * @instance
             */
            UserMsg.prototype.senderPubkey = $util.newBuffer([]);

            /**
             * UserMsg receiverPubkey.
             * @member {Uint8Array} receiverPubkey
             * @memberof dcnet.pb.UserMsg
             * @instance
             */
            UserMsg.prototype.receiverPubkey = $util.newBuffer([]);

            /**
             * UserMsg appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.UserMsg
             * @instance
             */
            UserMsg.prototype.appId = $util.newBuffer([]);

            /**
             * UserMsg blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.UserMsg
             * @instance
             */
            UserMsg.prototype.blockheight = 0;

            /**
             * UserMsg encryptMsg.
             * @member {Uint8Array} encryptMsg
             * @memberof dcnet.pb.UserMsg
             * @instance
             */
            UserMsg.prototype.encryptMsg = $util.newBuffer([]);

            /**
             * UserMsg signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.UserMsg
             * @instance
             */
            UserMsg.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new UserMsg instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.UserMsg
             * @static
             * @param {dcnet.pb.IUserMsg=} [properties] Properties to set
             * @returns {dcnet.pb.UserMsg} UserMsg instance
             */
            UserMsg.create = function create(properties) {
                return new UserMsg(properties);
            };

            /**
             * Encodes the specified UserMsg message. Does not implicitly {@link dcnet.pb.UserMsg.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.UserMsg
             * @static
             * @param {dcnet.pb.IUserMsg} message UserMsg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserMsg.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.messageId);
                if (message.senderPubkey != null && Object.hasOwnProperty.call(message, "senderPubkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderPubkey);
                if (message.receiverPubkey != null && Object.hasOwnProperty.call(message, "receiverPubkey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.receiverPubkey);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.appId);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.blockheight);
                if (message.encryptMsg != null && Object.hasOwnProperty.call(message, "encryptMsg"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.encryptMsg);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified UserMsg message, length delimited. Does not implicitly {@link dcnet.pb.UserMsg.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.UserMsg
             * @static
             * @param {dcnet.pb.IUserMsg} message UserMsg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserMsg.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UserMsg message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.UserMsg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.UserMsg} UserMsg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserMsg.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.UserMsg();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.senderPubkey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.receiverPubkey = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.encryptMsg = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UserMsg message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.UserMsg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.UserMsg} UserMsg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserMsg.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UserMsg message.
             * @function verify
             * @memberof dcnet.pb.UserMsg
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UserMsg.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!(message.messageId && typeof message.messageId.length === "number" || $util.isString(message.messageId)))
                        return "messageId: buffer expected";
                if (message.senderPubkey != null && message.hasOwnProperty("senderPubkey"))
                    if (!(message.senderPubkey && typeof message.senderPubkey.length === "number" || $util.isString(message.senderPubkey)))
                        return "senderPubkey: buffer expected";
                if (message.receiverPubkey != null && message.hasOwnProperty("receiverPubkey"))
                    if (!(message.receiverPubkey && typeof message.receiverPubkey.length === "number" || $util.isString(message.receiverPubkey)))
                        return "receiverPubkey: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.encryptMsg != null && message.hasOwnProperty("encryptMsg"))
                    if (!(message.encryptMsg && typeof message.encryptMsg.length === "number" || $util.isString(message.encryptMsg)))
                        return "encryptMsg: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a UserMsg message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.UserMsg
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.UserMsg} UserMsg
             */
            UserMsg.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.UserMsg)
                    return object;
                let message = new $root.dcnet.pb.UserMsg();
                if (object.messageId != null)
                    if (typeof object.messageId === "string")
                        $util.base64.decode(object.messageId, message.messageId = $util.newBuffer($util.base64.length(object.messageId)), 0);
                    else if (object.messageId.length >= 0)
                        message.messageId = object.messageId;
                if (object.senderPubkey != null)
                    if (typeof object.senderPubkey === "string")
                        $util.base64.decode(object.senderPubkey, message.senderPubkey = $util.newBuffer($util.base64.length(object.senderPubkey)), 0);
                    else if (object.senderPubkey.length >= 0)
                        message.senderPubkey = object.senderPubkey;
                if (object.receiverPubkey != null)
                    if (typeof object.receiverPubkey === "string")
                        $util.base64.decode(object.receiverPubkey, message.receiverPubkey = $util.newBuffer($util.base64.length(object.receiverPubkey)), 0);
                    else if (object.receiverPubkey.length >= 0)
                        message.receiverPubkey = object.receiverPubkey;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.encryptMsg != null)
                    if (typeof object.encryptMsg === "string")
                        $util.base64.decode(object.encryptMsg, message.encryptMsg = $util.newBuffer($util.base64.length(object.encryptMsg)), 0);
                    else if (object.encryptMsg.length >= 0)
                        message.encryptMsg = object.encryptMsg;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a UserMsg message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.UserMsg
             * @static
             * @param {dcnet.pb.UserMsg} message UserMsg
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UserMsg.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.messageId = "";
                    else {
                        object.messageId = [];
                        if (options.bytes !== Array)
                            object.messageId = $util.newBuffer(object.messageId);
                    }
                    if (options.bytes === String)
                        object.senderPubkey = "";
                    else {
                        object.senderPubkey = [];
                        if (options.bytes !== Array)
                            object.senderPubkey = $util.newBuffer(object.senderPubkey);
                    }
                    if (options.bytes === String)
                        object.receiverPubkey = "";
                    else {
                        object.receiverPubkey = [];
                        if (options.bytes !== Array)
                            object.receiverPubkey = $util.newBuffer(object.receiverPubkey);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.encryptMsg = "";
                    else {
                        object.encryptMsg = [];
                        if (options.bytes !== Array)
                            object.encryptMsg = $util.newBuffer(object.encryptMsg);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = options.bytes === String ? $util.base64.encode(message.messageId, 0, message.messageId.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageId) : message.messageId;
                if (message.senderPubkey != null && message.hasOwnProperty("senderPubkey"))
                    object.senderPubkey = options.bytes === String ? $util.base64.encode(message.senderPubkey, 0, message.senderPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderPubkey) : message.senderPubkey;
                if (message.receiverPubkey != null && message.hasOwnProperty("receiverPubkey"))
                    object.receiverPubkey = options.bytes === String ? $util.base64.encode(message.receiverPubkey, 0, message.receiverPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.receiverPubkey) : message.receiverPubkey;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.encryptMsg != null && message.hasOwnProperty("encryptMsg"))
                    object.encryptMsg = options.bytes === String ? $util.base64.encode(message.encryptMsg, 0, message.encryptMsg.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptMsg) : message.encryptMsg;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this UserMsg to JSON.
             * @function toJSON
             * @memberof dcnet.pb.UserMsg
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UserMsg.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UserMsg
             * @function getTypeUrl
             * @memberof dcnet.pb.UserMsg
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UserMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.UserMsg";
            };

            return UserMsg;
        })();

        pb.ReportSpamMsgRequest = (function() {

            /**
             * Properties of a ReportSpamMsgRequest.
             * @memberof dcnet.pb
             * @interface IReportSpamMsgRequest
             * @property {dcnet.pb.IUserMsg|null} [msg] ReportSpamMsgRequest msg
             * @property {number|null} [blockheight] ReportSpamMsgRequest blockheight
             * @property {Uint8Array|null} [signature] ReportSpamMsgRequest signature
             * @property {Uint8Array|null} [vaccount] ReportSpamMsgRequest vaccount
             */

            /**
             * Constructs a new ReportSpamMsgRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a ReportSpamMsgRequest.
             * @implements IReportSpamMsgRequest
             * @constructor
             * @param {dcnet.pb.IReportSpamMsgRequest=} [properties] Properties to set
             */
            function ReportSpamMsgRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReportSpamMsgRequest msg.
             * @member {dcnet.pb.IUserMsg|null|undefined} msg
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @instance
             */
            ReportSpamMsgRequest.prototype.msg = null;

            /**
             * ReportSpamMsgRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @instance
             */
            ReportSpamMsgRequest.prototype.blockheight = 0;

            /**
             * ReportSpamMsgRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @instance
             */
            ReportSpamMsgRequest.prototype.signature = $util.newBuffer([]);

            /**
             * ReportSpamMsgRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @instance
             */
            ReportSpamMsgRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new ReportSpamMsgRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @static
             * @param {dcnet.pb.IReportSpamMsgRequest=} [properties] Properties to set
             * @returns {dcnet.pb.ReportSpamMsgRequest} ReportSpamMsgRequest instance
             */
            ReportSpamMsgRequest.create = function create(properties) {
                return new ReportSpamMsgRequest(properties);
            };

            /**
             * Encodes the specified ReportSpamMsgRequest message. Does not implicitly {@link dcnet.pb.ReportSpamMsgRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @static
             * @param {dcnet.pb.IReportSpamMsgRequest} message ReportSpamMsgRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportSpamMsgRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    $root.dcnet.pb.UserMsg.encode(message.msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified ReportSpamMsgRequest message, length delimited. Does not implicitly {@link dcnet.pb.ReportSpamMsgRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @static
             * @param {dcnet.pb.IReportSpamMsgRequest} message ReportSpamMsgRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportSpamMsgRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReportSpamMsgRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ReportSpamMsgRequest} ReportSpamMsgRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportSpamMsgRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ReportSpamMsgRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.msg = $root.dcnet.pb.UserMsg.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReportSpamMsgRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ReportSpamMsgRequest} ReportSpamMsgRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportSpamMsgRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReportSpamMsgRequest message.
             * @function verify
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReportSpamMsgRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.msg != null && message.hasOwnProperty("msg")) {
                    let error = $root.dcnet.pb.UserMsg.verify(message.msg);
                    if (error)
                        return "msg." + error;
                }
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a ReportSpamMsgRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ReportSpamMsgRequest} ReportSpamMsgRequest
             */
            ReportSpamMsgRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ReportSpamMsgRequest)
                    return object;
                let message = new $root.dcnet.pb.ReportSpamMsgRequest();
                if (object.msg != null) {
                    if (typeof object.msg !== "object")
                        throw TypeError(".dcnet.pb.ReportSpamMsgRequest.msg: object expected");
                    message.msg = $root.dcnet.pb.UserMsg.fromObject(object.msg);
                }
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a ReportSpamMsgRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @static
             * @param {dcnet.pb.ReportSpamMsgRequest} message ReportSpamMsgRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReportSpamMsgRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.msg = null;
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = $root.dcnet.pb.UserMsg.toObject(message.msg, options);
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this ReportSpamMsgRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReportSpamMsgRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReportSpamMsgRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.ReportSpamMsgRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReportSpamMsgRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ReportSpamMsgRequest";
            };

            return ReportSpamMsgRequest;
        })();

        pb.ReportSpamMsgReply = (function() {

            /**
             * Properties of a ReportSpamMsgReply.
             * @memberof dcnet.pb
             * @interface IReportSpamMsgReply
             */

            /**
             * Constructs a new ReportSpamMsgReply.
             * @memberof dcnet.pb
             * @classdesc Represents a ReportSpamMsgReply.
             * @implements IReportSpamMsgReply
             * @constructor
             * @param {dcnet.pb.IReportSpamMsgReply=} [properties] Properties to set
             */
            function ReportSpamMsgReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ReportSpamMsgReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ReportSpamMsgReply
             * @static
             * @param {dcnet.pb.IReportSpamMsgReply=} [properties] Properties to set
             * @returns {dcnet.pb.ReportSpamMsgReply} ReportSpamMsgReply instance
             */
            ReportSpamMsgReply.create = function create(properties) {
                return new ReportSpamMsgReply(properties);
            };

            /**
             * Encodes the specified ReportSpamMsgReply message. Does not implicitly {@link dcnet.pb.ReportSpamMsgReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ReportSpamMsgReply
             * @static
             * @param {dcnet.pb.IReportSpamMsgReply} message ReportSpamMsgReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportSpamMsgReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ReportSpamMsgReply message, length delimited. Does not implicitly {@link dcnet.pb.ReportSpamMsgReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ReportSpamMsgReply
             * @static
             * @param {dcnet.pb.IReportSpamMsgReply} message ReportSpamMsgReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportSpamMsgReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReportSpamMsgReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ReportSpamMsgReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ReportSpamMsgReply} ReportSpamMsgReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportSpamMsgReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ReportSpamMsgReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReportSpamMsgReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ReportSpamMsgReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ReportSpamMsgReply} ReportSpamMsgReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportSpamMsgReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReportSpamMsgReply message.
             * @function verify
             * @memberof dcnet.pb.ReportSpamMsgReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReportSpamMsgReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ReportSpamMsgReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ReportSpamMsgReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ReportSpamMsgReply} ReportSpamMsgReply
             */
            ReportSpamMsgReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ReportSpamMsgReply)
                    return object;
                return new $root.dcnet.pb.ReportSpamMsgReply();
            };

            /**
             * Creates a plain object from a ReportSpamMsgReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ReportSpamMsgReply
             * @static
             * @param {dcnet.pb.ReportSpamMsgReply} message ReportSpamMsgReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReportSpamMsgReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ReportSpamMsgReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ReportSpamMsgReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReportSpamMsgReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReportSpamMsgReply
             * @function getTypeUrl
             * @memberof dcnet.pb.ReportSpamMsgReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReportSpamMsgReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ReportSpamMsgReply";
            };

            return ReportSpamMsgReply;
        })();

        pb.GetUserClientPeersRequest = (function() {

            /**
             * Properties of a GetUserClientPeersRequest.
             * @memberof dcnet.pb
             * @interface IGetUserClientPeersRequest
             * @property {Uint8Array|null} [userPubkey] GetUserClientPeersRequest userPubkey
             */

            /**
             * Constructs a new GetUserClientPeersRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetUserClientPeersRequest.
             * @implements IGetUserClientPeersRequest
             * @constructor
             * @param {dcnet.pb.IGetUserClientPeersRequest=} [properties] Properties to set
             */
            function GetUserClientPeersRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUserClientPeersRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.GetUserClientPeersRequest
             * @instance
             */
            GetUserClientPeersRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * Creates a new GetUserClientPeersRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetUserClientPeersRequest
             * @static
             * @param {dcnet.pb.IGetUserClientPeersRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetUserClientPeersRequest} GetUserClientPeersRequest instance
             */
            GetUserClientPeersRequest.create = function create(properties) {
                return new GetUserClientPeersRequest(properties);
            };

            /**
             * Encodes the specified GetUserClientPeersRequest message. Does not implicitly {@link dcnet.pb.GetUserClientPeersRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetUserClientPeersRequest
             * @static
             * @param {dcnet.pb.IGetUserClientPeersRequest} message GetUserClientPeersRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserClientPeersRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                return writer;
            };

            /**
             * Encodes the specified GetUserClientPeersRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetUserClientPeersRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetUserClientPeersRequest
             * @static
             * @param {dcnet.pb.IGetUserClientPeersRequest} message GetUserClientPeersRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserClientPeersRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUserClientPeersRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetUserClientPeersRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetUserClientPeersRequest} GetUserClientPeersRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserClientPeersRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetUserClientPeersRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUserClientPeersRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetUserClientPeersRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetUserClientPeersRequest} GetUserClientPeersRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserClientPeersRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUserClientPeersRequest message.
             * @function verify
             * @memberof dcnet.pb.GetUserClientPeersRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUserClientPeersRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                return null;
            };

            /**
             * Creates a GetUserClientPeersRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetUserClientPeersRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetUserClientPeersRequest} GetUserClientPeersRequest
             */
            GetUserClientPeersRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetUserClientPeersRequest)
                    return object;
                let message = new $root.dcnet.pb.GetUserClientPeersRequest();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                return message;
            };

            /**
             * Creates a plain object from a GetUserClientPeersRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetUserClientPeersRequest
             * @static
             * @param {dcnet.pb.GetUserClientPeersRequest} message GetUserClientPeersRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUserClientPeersRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                return object;
            };

            /**
             * Converts this GetUserClientPeersRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetUserClientPeersRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUserClientPeersRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUserClientPeersRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetUserClientPeersRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUserClientPeersRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetUserClientPeersRequest";
            };

            return GetUserClientPeersRequest;
        })();

        pb.GetUserClientPeersReply = (function() {

            /**
             * Properties of a GetUserClientPeersReply.
             * @memberof dcnet.pb
             * @interface IGetUserClientPeersReply
             * @property {Array.<string>|null} [peers] GetUserClientPeersReply peers
             */

            /**
             * Constructs a new GetUserClientPeersReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetUserClientPeersReply.
             * @implements IGetUserClientPeersReply
             * @constructor
             * @param {dcnet.pb.IGetUserClientPeersReply=} [properties] Properties to set
             */
            function GetUserClientPeersReply(properties) {
                this.peers = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUserClientPeersReply peers.
             * @member {Array.<string>} peers
             * @memberof dcnet.pb.GetUserClientPeersReply
             * @instance
             */
            GetUserClientPeersReply.prototype.peers = $util.emptyArray;

            /**
             * Creates a new GetUserClientPeersReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetUserClientPeersReply
             * @static
             * @param {dcnet.pb.IGetUserClientPeersReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetUserClientPeersReply} GetUserClientPeersReply instance
             */
            GetUserClientPeersReply.create = function create(properties) {
                return new GetUserClientPeersReply(properties);
            };

            /**
             * Encodes the specified GetUserClientPeersReply message. Does not implicitly {@link dcnet.pb.GetUserClientPeersReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetUserClientPeersReply
             * @static
             * @param {dcnet.pb.IGetUserClientPeersReply} message GetUserClientPeersReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserClientPeersReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peers != null && message.peers.length)
                    for (let i = 0; i < message.peers.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.peers[i]);
                return writer;
            };

            /**
             * Encodes the specified GetUserClientPeersReply message, length delimited. Does not implicitly {@link dcnet.pb.GetUserClientPeersReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetUserClientPeersReply
             * @static
             * @param {dcnet.pb.IGetUserClientPeersReply} message GetUserClientPeersReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserClientPeersReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUserClientPeersReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetUserClientPeersReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetUserClientPeersReply} GetUserClientPeersReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserClientPeersReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetUserClientPeersReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.peers && message.peers.length))
                                message.peers = [];
                            message.peers.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUserClientPeersReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetUserClientPeersReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetUserClientPeersReply} GetUserClientPeersReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserClientPeersReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUserClientPeersReply message.
             * @function verify
             * @memberof dcnet.pb.GetUserClientPeersReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUserClientPeersReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peers != null && message.hasOwnProperty("peers")) {
                    if (!Array.isArray(message.peers))
                        return "peers: array expected";
                    for (let i = 0; i < message.peers.length; ++i)
                        if (!$util.isString(message.peers[i]))
                            return "peers: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GetUserClientPeersReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetUserClientPeersReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetUserClientPeersReply} GetUserClientPeersReply
             */
            GetUserClientPeersReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetUserClientPeersReply)
                    return object;
                let message = new $root.dcnet.pb.GetUserClientPeersReply();
                if (object.peers) {
                    if (!Array.isArray(object.peers))
                        throw TypeError(".dcnet.pb.GetUserClientPeersReply.peers: array expected");
                    message.peers = [];
                    for (let i = 0; i < object.peers.length; ++i)
                        message.peers[i] = String(object.peers[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUserClientPeersReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetUserClientPeersReply
             * @static
             * @param {dcnet.pb.GetUserClientPeersReply} message GetUserClientPeersReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUserClientPeersReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.peers = [];
                if (message.peers && message.peers.length) {
                    object.peers = [];
                    for (let j = 0; j < message.peers.length; ++j)
                        object.peers[j] = message.peers[j];
                }
                return object;
            };

            /**
             * Converts this GetUserClientPeersReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetUserClientPeersReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUserClientPeersReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUserClientPeersReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetUserClientPeersReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUserClientPeersReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetUserClientPeersReply";
            };

            return GetUserClientPeersReply;
        })();

        pb.AddThemeObjRequest = (function() {

            /**
             * Properties of an AddThemeObjRequest.
             * @memberof dcnet.pb
             * @interface IAddThemeObjRequest
             * @property {Uint8Array|null} [theme] AddThemeObjRequest theme
             * @property {Uint8Array|null} [appId] AddThemeObjRequest appId
             * @property {number|null} [blockheight] AddThemeObjRequest blockheight
             * @property {number|null} [commentSpace] AddThemeObjRequest commentSpace
             * @property {number|null} [allowSpace] AddThemeObjRequest allowSpace
             * @property {Uint8Array|null} [userPubkey] AddThemeObjRequest userPubkey
             * @property {number|null} [openFlag] AddThemeObjRequest openFlag
             * @property {Uint8Array|null} [signature] AddThemeObjRequest signature
             * @property {number|null} [CCount] AddThemeObjRequest CCount
             * @property {number|null} [UpCount] AddThemeObjRequest UpCount
             * @property {number|null} [DownCount] AddThemeObjRequest DownCount
             * @property {number|null} [TCount] AddThemeObjRequest TCount
             * @property {Uint8Array|null} [vaccount] AddThemeObjRequest vaccount
             */

            /**
             * Constructs a new AddThemeObjRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AddThemeObjRequest.
             * @implements IAddThemeObjRequest
             * @constructor
             * @param {dcnet.pb.IAddThemeObjRequest=} [properties] Properties to set
             */
            function AddThemeObjRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddThemeObjRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.theme = $util.newBuffer([]);

            /**
             * AddThemeObjRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.appId = $util.newBuffer([]);

            /**
             * AddThemeObjRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.blockheight = 0;

            /**
             * AddThemeObjRequest commentSpace.
             * @member {number} commentSpace
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.commentSpace = 0;

            /**
             * AddThemeObjRequest allowSpace.
             * @member {number} allowSpace
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.allowSpace = 0;

            /**
             * AddThemeObjRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * AddThemeObjRequest openFlag.
             * @member {number} openFlag
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.openFlag = 0;

            /**
             * AddThemeObjRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.signature = $util.newBuffer([]);

            /**
             * AddThemeObjRequest CCount.
             * @member {number} CCount
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.CCount = 0;

            /**
             * AddThemeObjRequest UpCount.
             * @member {number} UpCount
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.UpCount = 0;

            /**
             * AddThemeObjRequest DownCount.
             * @member {number} DownCount
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.DownCount = 0;

            /**
             * AddThemeObjRequest TCount.
             * @member {number} TCount
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.TCount = 0;

            /**
             * AddThemeObjRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             */
            AddThemeObjRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new AddThemeObjRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddThemeObjRequest
             * @static
             * @param {dcnet.pb.IAddThemeObjRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AddThemeObjRequest} AddThemeObjRequest instance
             */
            AddThemeObjRequest.create = function create(properties) {
                return new AddThemeObjRequest(properties);
            };

            /**
             * Encodes the specified AddThemeObjRequest message. Does not implicitly {@link dcnet.pb.AddThemeObjRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddThemeObjRequest
             * @static
             * @param {dcnet.pb.IAddThemeObjRequest} message AddThemeObjRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThemeObjRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.blockheight);
                if (message.commentSpace != null && Object.hasOwnProperty.call(message, "commentSpace"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.commentSpace);
                if (message.allowSpace != null && Object.hasOwnProperty.call(message, "allowSpace"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.allowSpace);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.userPubkey);
                if (message.openFlag != null && Object.hasOwnProperty.call(message, "openFlag"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.openFlag);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.signature);
                if (message.CCount != null && Object.hasOwnProperty.call(message, "CCount"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.CCount);
                if (message.UpCount != null && Object.hasOwnProperty.call(message, "UpCount"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.UpCount);
                if (message.DownCount != null && Object.hasOwnProperty.call(message, "DownCount"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.DownCount);
                if (message.TCount != null && Object.hasOwnProperty.call(message, "TCount"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.TCount);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified AddThemeObjRequest message, length delimited. Does not implicitly {@link dcnet.pb.AddThemeObjRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddThemeObjRequest
             * @static
             * @param {dcnet.pb.IAddThemeObjRequest} message AddThemeObjRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThemeObjRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddThemeObjRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddThemeObjRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddThemeObjRequest} AddThemeObjRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThemeObjRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddThemeObjRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.commentSpace = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.allowSpace = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.openFlag = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 9: {
                            message.CCount = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.UpCount = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.DownCount = reader.uint32();
                            break;
                        }
                    case 12: {
                            message.TCount = reader.uint32();
                            break;
                        }
                    case 13: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddThemeObjRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddThemeObjRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddThemeObjRequest} AddThemeObjRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThemeObjRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddThemeObjRequest message.
             * @function verify
             * @memberof dcnet.pb.AddThemeObjRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddThemeObjRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.commentSpace != null && message.hasOwnProperty("commentSpace"))
                    if (!$util.isInteger(message.commentSpace))
                        return "commentSpace: integer expected";
                if (message.allowSpace != null && message.hasOwnProperty("allowSpace"))
                    if (!$util.isInteger(message.allowSpace))
                        return "allowSpace: integer expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.openFlag != null && message.hasOwnProperty("openFlag"))
                    if (!$util.isInteger(message.openFlag))
                        return "openFlag: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.CCount != null && message.hasOwnProperty("CCount"))
                    if (!$util.isInteger(message.CCount))
                        return "CCount: integer expected";
                if (message.UpCount != null && message.hasOwnProperty("UpCount"))
                    if (!$util.isInteger(message.UpCount))
                        return "UpCount: integer expected";
                if (message.DownCount != null && message.hasOwnProperty("DownCount"))
                    if (!$util.isInteger(message.DownCount))
                        return "DownCount: integer expected";
                if (message.TCount != null && message.hasOwnProperty("TCount"))
                    if (!$util.isInteger(message.TCount))
                        return "TCount: integer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates an AddThemeObjRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddThemeObjRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddThemeObjRequest} AddThemeObjRequest
             */
            AddThemeObjRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddThemeObjRequest)
                    return object;
                let message = new $root.dcnet.pb.AddThemeObjRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.commentSpace != null)
                    message.commentSpace = object.commentSpace >>> 0;
                if (object.allowSpace != null)
                    message.allowSpace = object.allowSpace >>> 0;
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.openFlag != null)
                    message.openFlag = object.openFlag >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.CCount != null)
                    message.CCount = object.CCount >>> 0;
                if (object.UpCount != null)
                    message.UpCount = object.UpCount >>> 0;
                if (object.DownCount != null)
                    message.DownCount = object.DownCount >>> 0;
                if (object.TCount != null)
                    message.TCount = object.TCount >>> 0;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from an AddThemeObjRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddThemeObjRequest
             * @static
             * @param {dcnet.pb.AddThemeObjRequest} message AddThemeObjRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddThemeObjRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    object.blockheight = 0;
                    object.commentSpace = 0;
                    object.allowSpace = 0;
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    object.openFlag = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    object.CCount = 0;
                    object.UpCount = 0;
                    object.DownCount = 0;
                    object.TCount = 0;
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.commentSpace != null && message.hasOwnProperty("commentSpace"))
                    object.commentSpace = message.commentSpace;
                if (message.allowSpace != null && message.hasOwnProperty("allowSpace"))
                    object.allowSpace = message.allowSpace;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.openFlag != null && message.hasOwnProperty("openFlag"))
                    object.openFlag = message.openFlag;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.CCount != null && message.hasOwnProperty("CCount"))
                    object.CCount = message.CCount;
                if (message.UpCount != null && message.hasOwnProperty("UpCount"))
                    object.UpCount = message.UpCount;
                if (message.DownCount != null && message.hasOwnProperty("DownCount"))
                    object.DownCount = message.DownCount;
                if (message.TCount != null && message.hasOwnProperty("TCount"))
                    object.TCount = message.TCount;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this AddThemeObjRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddThemeObjRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddThemeObjRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddThemeObjRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AddThemeObjRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddThemeObjRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddThemeObjRequest";
            };

            return AddThemeObjRequest;
        })();

        pb.AddThemeObjReply = (function() {

            /**
             * Properties of an AddThemeObjReply.
             * @memberof dcnet.pb
             * @interface IAddThemeObjReply
             * @property {number|null} [flag] AddThemeObjReply flag
             */

            /**
             * Constructs a new AddThemeObjReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AddThemeObjReply.
             * @implements IAddThemeObjReply
             * @constructor
             * @param {dcnet.pb.IAddThemeObjReply=} [properties] Properties to set
             */
            function AddThemeObjReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddThemeObjReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.AddThemeObjReply
             * @instance
             */
            AddThemeObjReply.prototype.flag = 0;

            /**
             * Creates a new AddThemeObjReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddThemeObjReply
             * @static
             * @param {dcnet.pb.IAddThemeObjReply=} [properties] Properties to set
             * @returns {dcnet.pb.AddThemeObjReply} AddThemeObjReply instance
             */
            AddThemeObjReply.create = function create(properties) {
                return new AddThemeObjReply(properties);
            };

            /**
             * Encodes the specified AddThemeObjReply message. Does not implicitly {@link dcnet.pb.AddThemeObjReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddThemeObjReply
             * @static
             * @param {dcnet.pb.IAddThemeObjReply} message AddThemeObjReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThemeObjReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified AddThemeObjReply message, length delimited. Does not implicitly {@link dcnet.pb.AddThemeObjReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddThemeObjReply
             * @static
             * @param {dcnet.pb.IAddThemeObjReply} message AddThemeObjReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThemeObjReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddThemeObjReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddThemeObjReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddThemeObjReply} AddThemeObjReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThemeObjReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddThemeObjReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddThemeObjReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddThemeObjReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddThemeObjReply} AddThemeObjReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThemeObjReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddThemeObjReply message.
             * @function verify
             * @memberof dcnet.pb.AddThemeObjReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddThemeObjReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates an AddThemeObjReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddThemeObjReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddThemeObjReply} AddThemeObjReply
             */
            AddThemeObjReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddThemeObjReply)
                    return object;
                let message = new $root.dcnet.pb.AddThemeObjReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AddThemeObjReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddThemeObjReply
             * @static
             * @param {dcnet.pb.AddThemeObjReply} message AddThemeObjReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddThemeObjReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this AddThemeObjReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddThemeObjReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddThemeObjReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddThemeObjReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AddThemeObjReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddThemeObjReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddThemeObjReply";
            };

            return AddThemeObjReply;
        })();

        pb.AddThemeSpaceRequest = (function() {

            /**
             * Properties of an AddThemeSpaceRequest.
             * @memberof dcnet.pb
             * @interface IAddThemeSpaceRequest
             * @property {Uint8Array|null} [theme] AddThemeSpaceRequest theme
             * @property {Uint8Array|null} [appId] AddThemeSpaceRequest appId
             * @property {number|null} [blockheight] AddThemeSpaceRequest blockheight
             * @property {number|null} [addspace] AddThemeSpaceRequest addspace
             * @property {Uint8Array|null} [userPubkey] AddThemeSpaceRequest userPubkey
             * @property {Uint8Array|null} [signature] AddThemeSpaceRequest signature
             * @property {Uint8Array|null} [vaccount] AddThemeSpaceRequest vaccount
             */

            /**
             * Constructs a new AddThemeSpaceRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AddThemeSpaceRequest.
             * @implements IAddThemeSpaceRequest
             * @constructor
             * @param {dcnet.pb.IAddThemeSpaceRequest=} [properties] Properties to set
             */
            function AddThemeSpaceRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddThemeSpaceRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @instance
             */
            AddThemeSpaceRequest.prototype.theme = $util.newBuffer([]);

            /**
             * AddThemeSpaceRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @instance
             */
            AddThemeSpaceRequest.prototype.appId = $util.newBuffer([]);

            /**
             * AddThemeSpaceRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @instance
             */
            AddThemeSpaceRequest.prototype.blockheight = 0;

            /**
             * AddThemeSpaceRequest addspace.
             * @member {number} addspace
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @instance
             */
            AddThemeSpaceRequest.prototype.addspace = 0;

            /**
             * AddThemeSpaceRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @instance
             */
            AddThemeSpaceRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * AddThemeSpaceRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @instance
             */
            AddThemeSpaceRequest.prototype.signature = $util.newBuffer([]);

            /**
             * AddThemeSpaceRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @instance
             */
            AddThemeSpaceRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new AddThemeSpaceRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @static
             * @param {dcnet.pb.IAddThemeSpaceRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AddThemeSpaceRequest} AddThemeSpaceRequest instance
             */
            AddThemeSpaceRequest.create = function create(properties) {
                return new AddThemeSpaceRequest(properties);
            };

            /**
             * Encodes the specified AddThemeSpaceRequest message. Does not implicitly {@link dcnet.pb.AddThemeSpaceRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @static
             * @param {dcnet.pb.IAddThemeSpaceRequest} message AddThemeSpaceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThemeSpaceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.blockheight);
                if (message.addspace != null && Object.hasOwnProperty.call(message, "addspace"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.addspace);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.userPubkey);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified AddThemeSpaceRequest message, length delimited. Does not implicitly {@link dcnet.pb.AddThemeSpaceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @static
             * @param {dcnet.pb.IAddThemeSpaceRequest} message AddThemeSpaceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThemeSpaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddThemeSpaceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddThemeSpaceRequest} AddThemeSpaceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThemeSpaceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddThemeSpaceRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.addspace = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddThemeSpaceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddThemeSpaceRequest} AddThemeSpaceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThemeSpaceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddThemeSpaceRequest message.
             * @function verify
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddThemeSpaceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.addspace != null && message.hasOwnProperty("addspace"))
                    if (!$util.isInteger(message.addspace))
                        return "addspace: integer expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates an AddThemeSpaceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddThemeSpaceRequest} AddThemeSpaceRequest
             */
            AddThemeSpaceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddThemeSpaceRequest)
                    return object;
                let message = new $root.dcnet.pb.AddThemeSpaceRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.addspace != null)
                    message.addspace = object.addspace >>> 0;
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from an AddThemeSpaceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @static
             * @param {dcnet.pb.AddThemeSpaceRequest} message AddThemeSpaceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddThemeSpaceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    object.blockheight = 0;
                    object.addspace = 0;
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.addspace != null && message.hasOwnProperty("addspace"))
                    object.addspace = message.addspace;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this AddThemeSpaceRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddThemeSpaceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddThemeSpaceRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AddThemeSpaceRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddThemeSpaceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddThemeSpaceRequest";
            };

            return AddThemeSpaceRequest;
        })();

        pb.AddThemeSpaceReply = (function() {

            /**
             * Properties of an AddThemeSpaceReply.
             * @memberof dcnet.pb
             * @interface IAddThemeSpaceReply
             * @property {number|null} [flag] AddThemeSpaceReply flag
             */

            /**
             * Constructs a new AddThemeSpaceReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AddThemeSpaceReply.
             * @implements IAddThemeSpaceReply
             * @constructor
             * @param {dcnet.pb.IAddThemeSpaceReply=} [properties] Properties to set
             */
            function AddThemeSpaceReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddThemeSpaceReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.AddThemeSpaceReply
             * @instance
             */
            AddThemeSpaceReply.prototype.flag = 0;

            /**
             * Creates a new AddThemeSpaceReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddThemeSpaceReply
             * @static
             * @param {dcnet.pb.IAddThemeSpaceReply=} [properties] Properties to set
             * @returns {dcnet.pb.AddThemeSpaceReply} AddThemeSpaceReply instance
             */
            AddThemeSpaceReply.create = function create(properties) {
                return new AddThemeSpaceReply(properties);
            };

            /**
             * Encodes the specified AddThemeSpaceReply message. Does not implicitly {@link dcnet.pb.AddThemeSpaceReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddThemeSpaceReply
             * @static
             * @param {dcnet.pb.IAddThemeSpaceReply} message AddThemeSpaceReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThemeSpaceReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified AddThemeSpaceReply message, length delimited. Does not implicitly {@link dcnet.pb.AddThemeSpaceReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddThemeSpaceReply
             * @static
             * @param {dcnet.pb.IAddThemeSpaceReply} message AddThemeSpaceReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddThemeSpaceReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddThemeSpaceReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddThemeSpaceReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddThemeSpaceReply} AddThemeSpaceReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThemeSpaceReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddThemeSpaceReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddThemeSpaceReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddThemeSpaceReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddThemeSpaceReply} AddThemeSpaceReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddThemeSpaceReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddThemeSpaceReply message.
             * @function verify
             * @memberof dcnet.pb.AddThemeSpaceReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddThemeSpaceReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates an AddThemeSpaceReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddThemeSpaceReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddThemeSpaceReply} AddThemeSpaceReply
             */
            AddThemeSpaceReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddThemeSpaceReply)
                    return object;
                let message = new $root.dcnet.pb.AddThemeSpaceReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AddThemeSpaceReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddThemeSpaceReply
             * @static
             * @param {dcnet.pb.AddThemeSpaceReply} message AddThemeSpaceReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddThemeSpaceReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this AddThemeSpaceReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddThemeSpaceReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddThemeSpaceReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddThemeSpaceReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AddThemeSpaceReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddThemeSpaceReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddThemeSpaceReply";
            };

            return AddThemeSpaceReply;
        })();

        pb.SetCacheKeyRequest = (function() {

            /**
             * Properties of a SetCacheKeyRequest.
             * @memberof dcnet.pb
             * @interface ISetCacheKeyRequest
             * @property {number|null} [expire] SetCacheKeyRequest expire
             * @property {number|null} [blockheight] SetCacheKeyRequest blockheight
             * @property {Uint8Array|null} [value] SetCacheKeyRequest value
             * @property {Uint8Array|null} [signature] SetCacheKeyRequest signature
             */

            /**
             * Constructs a new SetCacheKeyRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a SetCacheKeyRequest.
             * @implements ISetCacheKeyRequest
             * @constructor
             * @param {dcnet.pb.ISetCacheKeyRequest=} [properties] Properties to set
             */
            function SetCacheKeyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetCacheKeyRequest expire.
             * @member {number} expire
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @instance
             */
            SetCacheKeyRequest.prototype.expire = 0;

            /**
             * SetCacheKeyRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @instance
             */
            SetCacheKeyRequest.prototype.blockheight = 0;

            /**
             * SetCacheKeyRequest value.
             * @member {Uint8Array} value
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @instance
             */
            SetCacheKeyRequest.prototype.value = $util.newBuffer([]);

            /**
             * SetCacheKeyRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @instance
             */
            SetCacheKeyRequest.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new SetCacheKeyRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @static
             * @param {dcnet.pb.ISetCacheKeyRequest=} [properties] Properties to set
             * @returns {dcnet.pb.SetCacheKeyRequest} SetCacheKeyRequest instance
             */
            SetCacheKeyRequest.create = function create(properties) {
                return new SetCacheKeyRequest(properties);
            };

            /**
             * Encodes the specified SetCacheKeyRequest message. Does not implicitly {@link dcnet.pb.SetCacheKeyRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @static
             * @param {dcnet.pb.ISetCacheKeyRequest} message SetCacheKeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetCacheKeyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.expire != null && Object.hasOwnProperty.call(message, "expire"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.expire);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified SetCacheKeyRequest message, length delimited. Does not implicitly {@link dcnet.pb.SetCacheKeyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @static
             * @param {dcnet.pb.ISetCacheKeyRequest} message SetCacheKeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetCacheKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetCacheKeyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SetCacheKeyRequest} SetCacheKeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetCacheKeyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SetCacheKeyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.expire = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.value = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetCacheKeyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SetCacheKeyRequest} SetCacheKeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetCacheKeyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetCacheKeyRequest message.
             * @function verify
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetCacheKeyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.expire != null && message.hasOwnProperty("expire"))
                    if (!$util.isInteger(message.expire))
                        return "expire: integer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a SetCacheKeyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SetCacheKeyRequest} SetCacheKeyRequest
             */
            SetCacheKeyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SetCacheKeyRequest)
                    return object;
                let message = new $root.dcnet.pb.SetCacheKeyRequest();
                if (object.expire != null)
                    message.expire = object.expire >>> 0;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length >= 0)
                        message.value = object.value;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a SetCacheKeyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @static
             * @param {dcnet.pb.SetCacheKeyRequest} message SetCacheKeyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetCacheKeyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.expire = 0;
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.expire != null && message.hasOwnProperty("expire"))
                    object.expire = message.expire;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this SetCacheKeyRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetCacheKeyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetCacheKeyRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.SetCacheKeyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetCacheKeyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SetCacheKeyRequest";
            };

            return SetCacheKeyRequest;
        })();

        pb.SetCacheKeyReply = (function() {

            /**
             * Properties of a SetCacheKeyReply.
             * @memberof dcnet.pb
             * @interface ISetCacheKeyReply
             * @property {number|null} [flag] SetCacheKeyReply flag
             * @property {Uint8Array|null} [cacheKey] SetCacheKeyReply cacheKey
             */

            /**
             * Constructs a new SetCacheKeyReply.
             * @memberof dcnet.pb
             * @classdesc Represents a SetCacheKeyReply.
             * @implements ISetCacheKeyReply
             * @constructor
             * @param {dcnet.pb.ISetCacheKeyReply=} [properties] Properties to set
             */
            function SetCacheKeyReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetCacheKeyReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.SetCacheKeyReply
             * @instance
             */
            SetCacheKeyReply.prototype.flag = 0;

            /**
             * SetCacheKeyReply cacheKey.
             * @member {Uint8Array} cacheKey
             * @memberof dcnet.pb.SetCacheKeyReply
             * @instance
             */
            SetCacheKeyReply.prototype.cacheKey = $util.newBuffer([]);

            /**
             * Creates a new SetCacheKeyReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SetCacheKeyReply
             * @static
             * @param {dcnet.pb.ISetCacheKeyReply=} [properties] Properties to set
             * @returns {dcnet.pb.SetCacheKeyReply} SetCacheKeyReply instance
             */
            SetCacheKeyReply.create = function create(properties) {
                return new SetCacheKeyReply(properties);
            };

            /**
             * Encodes the specified SetCacheKeyReply message. Does not implicitly {@link dcnet.pb.SetCacheKeyReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SetCacheKeyReply
             * @static
             * @param {dcnet.pb.ISetCacheKeyReply} message SetCacheKeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetCacheKeyReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.cacheKey != null && Object.hasOwnProperty.call(message, "cacheKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.cacheKey);
                return writer;
            };

            /**
             * Encodes the specified SetCacheKeyReply message, length delimited. Does not implicitly {@link dcnet.pb.SetCacheKeyReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SetCacheKeyReply
             * @static
             * @param {dcnet.pb.ISetCacheKeyReply} message SetCacheKeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetCacheKeyReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetCacheKeyReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SetCacheKeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SetCacheKeyReply} SetCacheKeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetCacheKeyReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SetCacheKeyReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.cacheKey = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetCacheKeyReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SetCacheKeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SetCacheKeyReply} SetCacheKeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetCacheKeyReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetCacheKeyReply message.
             * @function verify
             * @memberof dcnet.pb.SetCacheKeyReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetCacheKeyReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.cacheKey != null && message.hasOwnProperty("cacheKey"))
                    if (!(message.cacheKey && typeof message.cacheKey.length === "number" || $util.isString(message.cacheKey)))
                        return "cacheKey: buffer expected";
                return null;
            };

            /**
             * Creates a SetCacheKeyReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SetCacheKeyReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SetCacheKeyReply} SetCacheKeyReply
             */
            SetCacheKeyReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SetCacheKeyReply)
                    return object;
                let message = new $root.dcnet.pb.SetCacheKeyReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.cacheKey != null)
                    if (typeof object.cacheKey === "string")
                        $util.base64.decode(object.cacheKey, message.cacheKey = $util.newBuffer($util.base64.length(object.cacheKey)), 0);
                    else if (object.cacheKey.length >= 0)
                        message.cacheKey = object.cacheKey;
                return message;
            };

            /**
             * Creates a plain object from a SetCacheKeyReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SetCacheKeyReply
             * @static
             * @param {dcnet.pb.SetCacheKeyReply} message SetCacheKeyReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetCacheKeyReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.cacheKey = "";
                    else {
                        object.cacheKey = [];
                        if (options.bytes !== Array)
                            object.cacheKey = $util.newBuffer(object.cacheKey);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.cacheKey != null && message.hasOwnProperty("cacheKey"))
                    object.cacheKey = options.bytes === String ? $util.base64.encode(message.cacheKey, 0, message.cacheKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.cacheKey) : message.cacheKey;
                return object;
            };

            /**
             * Converts this SetCacheKeyReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SetCacheKeyReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetCacheKeyReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetCacheKeyReply
             * @function getTypeUrl
             * @memberof dcnet.pb.SetCacheKeyReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetCacheKeyReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SetCacheKeyReply";
            };

            return SetCacheKeyReply;
        })();

        pb.GetCacheValueRequest = (function() {

            /**
             * Properties of a GetCacheValueRequest.
             * @memberof dcnet.pb
             * @interface IGetCacheValueRequest
             * @property {Uint8Array|null} [key] GetCacheValueRequest key
             */

            /**
             * Constructs a new GetCacheValueRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetCacheValueRequest.
             * @implements IGetCacheValueRequest
             * @constructor
             * @param {dcnet.pb.IGetCacheValueRequest=} [properties] Properties to set
             */
            function GetCacheValueRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCacheValueRequest key.
             * @member {Uint8Array} key
             * @memberof dcnet.pb.GetCacheValueRequest
             * @instance
             */
            GetCacheValueRequest.prototype.key = $util.newBuffer([]);

            /**
             * Creates a new GetCacheValueRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetCacheValueRequest
             * @static
             * @param {dcnet.pb.IGetCacheValueRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetCacheValueRequest} GetCacheValueRequest instance
             */
            GetCacheValueRequest.create = function create(properties) {
                return new GetCacheValueRequest(properties);
            };

            /**
             * Encodes the specified GetCacheValueRequest message. Does not implicitly {@link dcnet.pb.GetCacheValueRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetCacheValueRequest
             * @static
             * @param {dcnet.pb.IGetCacheValueRequest} message GetCacheValueRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCacheValueRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                return writer;
            };

            /**
             * Encodes the specified GetCacheValueRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetCacheValueRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetCacheValueRequest
             * @static
             * @param {dcnet.pb.IGetCacheValueRequest} message GetCacheValueRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCacheValueRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCacheValueRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetCacheValueRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetCacheValueRequest} GetCacheValueRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCacheValueRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetCacheValueRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCacheValueRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetCacheValueRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetCacheValueRequest} GetCacheValueRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCacheValueRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCacheValueRequest message.
             * @function verify
             * @memberof dcnet.pb.GetCacheValueRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCacheValueRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                return null;
            };

            /**
             * Creates a GetCacheValueRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetCacheValueRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetCacheValueRequest} GetCacheValueRequest
             */
            GetCacheValueRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetCacheValueRequest)
                    return object;
                let message = new $root.dcnet.pb.GetCacheValueRequest();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length >= 0)
                        message.key = object.key;
                return message;
            };

            /**
             * Creates a plain object from a GetCacheValueRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetCacheValueRequest
             * @static
             * @param {dcnet.pb.GetCacheValueRequest} message GetCacheValueRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCacheValueRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.key = "";
                    else {
                        object.key = [];
                        if (options.bytes !== Array)
                            object.key = $util.newBuffer(object.key);
                    }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                return object;
            };

            /**
             * Converts this GetCacheValueRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetCacheValueRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCacheValueRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCacheValueRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetCacheValueRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCacheValueRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetCacheValueRequest";
            };

            return GetCacheValueRequest;
        })();

        pb.GetCacheValueReply = (function() {

            /**
             * Properties of a GetCacheValueReply.
             * @memberof dcnet.pb
             * @interface IGetCacheValueReply
             * @property {Uint8Array|null} [value] GetCacheValueReply value
             */

            /**
             * Constructs a new GetCacheValueReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetCacheValueReply.
             * @implements IGetCacheValueReply
             * @constructor
             * @param {dcnet.pb.IGetCacheValueReply=} [properties] Properties to set
             */
            function GetCacheValueReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCacheValueReply value.
             * @member {Uint8Array} value
             * @memberof dcnet.pb.GetCacheValueReply
             * @instance
             */
            GetCacheValueReply.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new GetCacheValueReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetCacheValueReply
             * @static
             * @param {dcnet.pb.IGetCacheValueReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetCacheValueReply} GetCacheValueReply instance
             */
            GetCacheValueReply.create = function create(properties) {
                return new GetCacheValueReply(properties);
            };

            /**
             * Encodes the specified GetCacheValueReply message. Does not implicitly {@link dcnet.pb.GetCacheValueReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetCacheValueReply
             * @static
             * @param {dcnet.pb.IGetCacheValueReply} message GetCacheValueReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCacheValueReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified GetCacheValueReply message, length delimited. Does not implicitly {@link dcnet.pb.GetCacheValueReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetCacheValueReply
             * @static
             * @param {dcnet.pb.IGetCacheValueReply} message GetCacheValueReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCacheValueReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCacheValueReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetCacheValueReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetCacheValueReply} GetCacheValueReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCacheValueReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetCacheValueReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCacheValueReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetCacheValueReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetCacheValueReply} GetCacheValueReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCacheValueReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCacheValueReply message.
             * @function verify
             * @memberof dcnet.pb.GetCacheValueReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCacheValueReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a GetCacheValueReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetCacheValueReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetCacheValueReply} GetCacheValueReply
             */
            GetCacheValueReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetCacheValueReply)
                    return object;
                let message = new $root.dcnet.pb.GetCacheValueReply();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length >= 0)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a GetCacheValueReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetCacheValueReply
             * @static
             * @param {dcnet.pb.GetCacheValueReply} message GetCacheValueReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCacheValueReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this GetCacheValueReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetCacheValueReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCacheValueReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCacheValueReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetCacheValueReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCacheValueReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetCacheValueReply";
            };

            return GetCacheValueReply;
        })();

        pb.GetThemeSpaceRequest = (function() {

            /**
             * Properties of a GetThemeSpaceRequest.
             * @memberof dcnet.pb
             * @interface IGetThemeSpaceRequest
             * @property {Uint8Array|null} [theme] GetThemeSpaceRequest theme
             * @property {Uint8Array|null} [appId] GetThemeSpaceRequest appId
             * @property {number|null} [blockheight] GetThemeSpaceRequest blockheight
             * @property {Uint8Array|null} [userPubkey] GetThemeSpaceRequest userPubkey
             * @property {Uint8Array|null} [signature] GetThemeSpaceRequest signature
             * @property {Uint8Array|null} [vaccount] GetThemeSpaceRequest vaccount
             */

            /**
             * Constructs a new GetThemeSpaceRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThemeSpaceRequest.
             * @implements IGetThemeSpaceRequest
             * @constructor
             * @param {dcnet.pb.IGetThemeSpaceRequest=} [properties] Properties to set
             */
            function GetThemeSpaceRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThemeSpaceRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @instance
             */
            GetThemeSpaceRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetThemeSpaceRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @instance
             */
            GetThemeSpaceRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetThemeSpaceRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @instance
             */
            GetThemeSpaceRequest.prototype.blockheight = 0;

            /**
             * GetThemeSpaceRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @instance
             */
            GetThemeSpaceRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * GetThemeSpaceRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @instance
             */
            GetThemeSpaceRequest.prototype.signature = $util.newBuffer([]);

            /**
             * GetThemeSpaceRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @instance
             */
            GetThemeSpaceRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new GetThemeSpaceRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @static
             * @param {dcnet.pb.IGetThemeSpaceRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetThemeSpaceRequest} GetThemeSpaceRequest instance
             */
            GetThemeSpaceRequest.create = function create(properties) {
                return new GetThemeSpaceRequest(properties);
            };

            /**
             * Encodes the specified GetThemeSpaceRequest message. Does not implicitly {@link dcnet.pb.GetThemeSpaceRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @static
             * @param {dcnet.pb.IGetThemeSpaceRequest} message GetThemeSpaceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeSpaceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.blockheight);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.userPubkey);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified GetThemeSpaceRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetThemeSpaceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @static
             * @param {dcnet.pb.IGetThemeSpaceRequest} message GetThemeSpaceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeSpaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThemeSpaceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThemeSpaceRequest} GetThemeSpaceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeSpaceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThemeSpaceRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThemeSpaceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThemeSpaceRequest} GetThemeSpaceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeSpaceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThemeSpaceRequest message.
             * @function verify
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThemeSpaceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a GetThemeSpaceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThemeSpaceRequest} GetThemeSpaceRequest
             */
            GetThemeSpaceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThemeSpaceRequest)
                    return object;
                let message = new $root.dcnet.pb.GetThemeSpaceRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a GetThemeSpaceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @static
             * @param {dcnet.pb.GetThemeSpaceRequest} message GetThemeSpaceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThemeSpaceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this GetThemeSpaceRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThemeSpaceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThemeSpaceRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThemeSpaceRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThemeSpaceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThemeSpaceRequest";
            };

            return GetThemeSpaceRequest;
        })();

        pb.GetThemeSpaceReply = (function() {

            /**
             * Properties of a GetThemeSpaceReply.
             * @memberof dcnet.pb
             * @interface IGetThemeSpaceReply
             * @property {number|null} [space] GetThemeSpaceReply space
             */

            /**
             * Constructs a new GetThemeSpaceReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThemeSpaceReply.
             * @implements IGetThemeSpaceReply
             * @constructor
             * @param {dcnet.pb.IGetThemeSpaceReply=} [properties] Properties to set
             */
            function GetThemeSpaceReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThemeSpaceReply space.
             * @member {number} space
             * @memberof dcnet.pb.GetThemeSpaceReply
             * @instance
             */
            GetThemeSpaceReply.prototype.space = 0;

            /**
             * Creates a new GetThemeSpaceReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThemeSpaceReply
             * @static
             * @param {dcnet.pb.IGetThemeSpaceReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetThemeSpaceReply} GetThemeSpaceReply instance
             */
            GetThemeSpaceReply.create = function create(properties) {
                return new GetThemeSpaceReply(properties);
            };

            /**
             * Encodes the specified GetThemeSpaceReply message. Does not implicitly {@link dcnet.pb.GetThemeSpaceReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThemeSpaceReply
             * @static
             * @param {dcnet.pb.IGetThemeSpaceReply} message GetThemeSpaceReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeSpaceReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.space != null && Object.hasOwnProperty.call(message, "space"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.space);
                return writer;
            };

            /**
             * Encodes the specified GetThemeSpaceReply message, length delimited. Does not implicitly {@link dcnet.pb.GetThemeSpaceReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThemeSpaceReply
             * @static
             * @param {dcnet.pb.IGetThemeSpaceReply} message GetThemeSpaceReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeSpaceReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThemeSpaceReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThemeSpaceReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThemeSpaceReply} GetThemeSpaceReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeSpaceReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThemeSpaceReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.space = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThemeSpaceReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThemeSpaceReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThemeSpaceReply} GetThemeSpaceReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeSpaceReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThemeSpaceReply message.
             * @function verify
             * @memberof dcnet.pb.GetThemeSpaceReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThemeSpaceReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.space != null && message.hasOwnProperty("space"))
                    if (!$util.isInteger(message.space))
                        return "space: integer expected";
                return null;
            };

            /**
             * Creates a GetThemeSpaceReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThemeSpaceReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThemeSpaceReply} GetThemeSpaceReply
             */
            GetThemeSpaceReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThemeSpaceReply)
                    return object;
                let message = new $root.dcnet.pb.GetThemeSpaceReply();
                if (object.space != null)
                    message.space = object.space >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetThemeSpaceReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThemeSpaceReply
             * @static
             * @param {dcnet.pb.GetThemeSpaceReply} message GetThemeSpaceReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThemeSpaceReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.space = 0;
                if (message.space != null && message.hasOwnProperty("space"))
                    object.space = message.space;
                return object;
            };

            /**
             * Converts this GetThemeSpaceReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThemeSpaceReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThemeSpaceReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThemeSpaceReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThemeSpaceReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThemeSpaceReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThemeSpaceReply";
            };

            return GetThemeSpaceReply;
        })();

        pb.DeleteThemeObjRequest = (function() {

            /**
             * Properties of a DeleteThemeObjRequest.
             * @memberof dcnet.pb
             * @interface IDeleteThemeObjRequest
             * @property {Uint8Array|null} [theme] DeleteThemeObjRequest theme
             * @property {Uint8Array|null} [appId] DeleteThemeObjRequest appId
             * @property {number|null} [blockheight] DeleteThemeObjRequest blockheight
             * @property {Uint8Array|null} [userPubkey] DeleteThemeObjRequest userPubkey
             * @property {Uint8Array|null} [signature] DeleteThemeObjRequest signature
             * @property {Uint8Array|null} [vaccount] DeleteThemeObjRequest vaccount
             */

            /**
             * Constructs a new DeleteThemeObjRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteThemeObjRequest.
             * @implements IDeleteThemeObjRequest
             * @constructor
             * @param {dcnet.pb.IDeleteThemeObjRequest=} [properties] Properties to set
             */
            function DeleteThemeObjRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteThemeObjRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @instance
             */
            DeleteThemeObjRequest.prototype.theme = $util.newBuffer([]);

            /**
             * DeleteThemeObjRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @instance
             */
            DeleteThemeObjRequest.prototype.appId = $util.newBuffer([]);

            /**
             * DeleteThemeObjRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @instance
             */
            DeleteThemeObjRequest.prototype.blockheight = 0;

            /**
             * DeleteThemeObjRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @instance
             */
            DeleteThemeObjRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * DeleteThemeObjRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @instance
             */
            DeleteThemeObjRequest.prototype.signature = $util.newBuffer([]);

            /**
             * DeleteThemeObjRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @instance
             */
            DeleteThemeObjRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new DeleteThemeObjRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @static
             * @param {dcnet.pb.IDeleteThemeObjRequest=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteThemeObjRequest} DeleteThemeObjRequest instance
             */
            DeleteThemeObjRequest.create = function create(properties) {
                return new DeleteThemeObjRequest(properties);
            };

            /**
             * Encodes the specified DeleteThemeObjRequest message. Does not implicitly {@link dcnet.pb.DeleteThemeObjRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @static
             * @param {dcnet.pb.IDeleteThemeObjRequest} message DeleteThemeObjRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteThemeObjRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.blockheight);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.userPubkey);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified DeleteThemeObjRequest message, length delimited. Does not implicitly {@link dcnet.pb.DeleteThemeObjRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @static
             * @param {dcnet.pb.IDeleteThemeObjRequest} message DeleteThemeObjRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteThemeObjRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteThemeObjRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteThemeObjRequest} DeleteThemeObjRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteThemeObjRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteThemeObjRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteThemeObjRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteThemeObjRequest} DeleteThemeObjRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteThemeObjRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteThemeObjRequest message.
             * @function verify
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteThemeObjRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a DeleteThemeObjRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteThemeObjRequest} DeleteThemeObjRequest
             */
            DeleteThemeObjRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteThemeObjRequest)
                    return object;
                let message = new $root.dcnet.pb.DeleteThemeObjRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a DeleteThemeObjRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @static
             * @param {dcnet.pb.DeleteThemeObjRequest} message DeleteThemeObjRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteThemeObjRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this DeleteThemeObjRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteThemeObjRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteThemeObjRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteThemeObjRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteThemeObjRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteThemeObjRequest";
            };

            return DeleteThemeObjRequest;
        })();

        pb.DeleteThemeObjReply = (function() {

            /**
             * Properties of a DeleteThemeObjReply.
             * @memberof dcnet.pb
             * @interface IDeleteThemeObjReply
             * @property {number|null} [flag] DeleteThemeObjReply flag
             */

            /**
             * Constructs a new DeleteThemeObjReply.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteThemeObjReply.
             * @implements IDeleteThemeObjReply
             * @constructor
             * @param {dcnet.pb.IDeleteThemeObjReply=} [properties] Properties to set
             */
            function DeleteThemeObjReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteThemeObjReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.DeleteThemeObjReply
             * @instance
             */
            DeleteThemeObjReply.prototype.flag = 0;

            /**
             * Creates a new DeleteThemeObjReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteThemeObjReply
             * @static
             * @param {dcnet.pb.IDeleteThemeObjReply=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteThemeObjReply} DeleteThemeObjReply instance
             */
            DeleteThemeObjReply.create = function create(properties) {
                return new DeleteThemeObjReply(properties);
            };

            /**
             * Encodes the specified DeleteThemeObjReply message. Does not implicitly {@link dcnet.pb.DeleteThemeObjReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteThemeObjReply
             * @static
             * @param {dcnet.pb.IDeleteThemeObjReply} message DeleteThemeObjReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteThemeObjReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified DeleteThemeObjReply message, length delimited. Does not implicitly {@link dcnet.pb.DeleteThemeObjReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteThemeObjReply
             * @static
             * @param {dcnet.pb.IDeleteThemeObjReply} message DeleteThemeObjReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteThemeObjReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteThemeObjReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteThemeObjReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteThemeObjReply} DeleteThemeObjReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteThemeObjReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteThemeObjReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteThemeObjReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteThemeObjReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteThemeObjReply} DeleteThemeObjReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteThemeObjReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteThemeObjReply message.
             * @function verify
             * @memberof dcnet.pb.DeleteThemeObjReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteThemeObjReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a DeleteThemeObjReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteThemeObjReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteThemeObjReply} DeleteThemeObjReply
             */
            DeleteThemeObjReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteThemeObjReply)
                    return object;
                let message = new $root.dcnet.pb.DeleteThemeObjReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DeleteThemeObjReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteThemeObjReply
             * @static
             * @param {dcnet.pb.DeleteThemeObjReply} message DeleteThemeObjReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteThemeObjReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this DeleteThemeObjReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteThemeObjReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteThemeObjReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteThemeObjReply
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteThemeObjReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteThemeObjReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteThemeObjReply";
            };

            return DeleteThemeObjReply;
        })();

        pb.PublishCommentToThemeRequest = (function() {

            /**
             * Properties of a PublishCommentToThemeRequest.
             * @memberof dcnet.pb
             * @interface IPublishCommentToThemeRequest
             * @property {Uint8Array|null} [theme] PublishCommentToThemeRequest theme
             * @property {Uint8Array|null} [appId] PublishCommentToThemeRequest appId
             * @property {Uint8Array|null} [themeAuthor] PublishCommentToThemeRequest themeAuthor
             * @property {number|null} [blockheight] PublishCommentToThemeRequest blockheight
             * @property {Uint8Array|null} [userPubkey] PublishCommentToThemeRequest userPubkey
             * @property {Uint8Array|null} [commentCid] PublishCommentToThemeRequest commentCid
             * @property {Uint8Array|null} [comment] PublishCommentToThemeRequest comment
             * @property {number|null} [commentSize] PublishCommentToThemeRequest commentSize
             * @property {number|null} [status] PublishCommentToThemeRequest status
             * @property {Uint8Array|null} [refercommentkey] PublishCommentToThemeRequest refercommentkey
             * @property {number|null} [CCount] PublishCommentToThemeRequest CCount
             * @property {number|null} [UpCount] PublishCommentToThemeRequest UpCount
             * @property {number|null} [DownCount] PublishCommentToThemeRequest DownCount
             * @property {number|null} [TCount] PublishCommentToThemeRequest TCount
             * @property {number|null} [type] PublishCommentToThemeRequest type
             * @property {Uint8Array|null} [signature] PublishCommentToThemeRequest signature
             * @property {Uint8Array|null} [vaccount] PublishCommentToThemeRequest vaccount
             * @property {number|Long|null} [timestamp] PublishCommentToThemeRequest timestamp
             */

            /**
             * Constructs a new PublishCommentToThemeRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a PublishCommentToThemeRequest.
             * @implements IPublishCommentToThemeRequest
             * @constructor
             * @param {dcnet.pb.IPublishCommentToThemeRequest=} [properties] Properties to set
             */
            function PublishCommentToThemeRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PublishCommentToThemeRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.theme = $util.newBuffer([]);

            /**
             * PublishCommentToThemeRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.appId = $util.newBuffer([]);

            /**
             * PublishCommentToThemeRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * PublishCommentToThemeRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.blockheight = 0;

            /**
             * PublishCommentToThemeRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * PublishCommentToThemeRequest commentCid.
             * @member {Uint8Array} commentCid
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.commentCid = $util.newBuffer([]);

            /**
             * PublishCommentToThemeRequest comment.
             * @member {Uint8Array} comment
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.comment = $util.newBuffer([]);

            /**
             * PublishCommentToThemeRequest commentSize.
             * @member {number} commentSize
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.commentSize = 0;

            /**
             * PublishCommentToThemeRequest status.
             * @member {number} status
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.status = 0;

            /**
             * PublishCommentToThemeRequest refercommentkey.
             * @member {Uint8Array} refercommentkey
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.refercommentkey = $util.newBuffer([]);

            /**
             * PublishCommentToThemeRequest CCount.
             * @member {number} CCount
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.CCount = 0;

            /**
             * PublishCommentToThemeRequest UpCount.
             * @member {number} UpCount
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.UpCount = 0;

            /**
             * PublishCommentToThemeRequest DownCount.
             * @member {number} DownCount
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.DownCount = 0;

            /**
             * PublishCommentToThemeRequest TCount.
             * @member {number} TCount
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.TCount = 0;

            /**
             * PublishCommentToThemeRequest type.
             * @member {number} type
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.type = 0;

            /**
             * PublishCommentToThemeRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.signature = $util.newBuffer([]);

            /**
             * PublishCommentToThemeRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * PublishCommentToThemeRequest timestamp.
             * @member {number|Long} timestamp
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             */
            PublishCommentToThemeRequest.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new PublishCommentToThemeRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @static
             * @param {dcnet.pb.IPublishCommentToThemeRequest=} [properties] Properties to set
             * @returns {dcnet.pb.PublishCommentToThemeRequest} PublishCommentToThemeRequest instance
             */
            PublishCommentToThemeRequest.create = function create(properties) {
                return new PublishCommentToThemeRequest(properties);
            };

            /**
             * Encodes the specified PublishCommentToThemeRequest message. Does not implicitly {@link dcnet.pb.PublishCommentToThemeRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @static
             * @param {dcnet.pb.IPublishCommentToThemeRequest} message PublishCommentToThemeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PublishCommentToThemeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockheight);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.userPubkey);
                if (message.commentCid != null && Object.hasOwnProperty.call(message, "commentCid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.commentCid);
                if (message.comment != null && Object.hasOwnProperty.call(message, "comment"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.comment);
                if (message.commentSize != null && Object.hasOwnProperty.call(message, "commentSize"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.commentSize);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.status);
                if (message.refercommentkey != null && Object.hasOwnProperty.call(message, "refercommentkey"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.refercommentkey);
                if (message.CCount != null && Object.hasOwnProperty.call(message, "CCount"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.CCount);
                if (message.UpCount != null && Object.hasOwnProperty.call(message, "UpCount"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.UpCount);
                if (message.DownCount != null && Object.hasOwnProperty.call(message, "DownCount"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.DownCount);
                if (message.TCount != null && Object.hasOwnProperty.call(message, "TCount"))
                    writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.TCount);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.type);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 17, wireType 2 =*/138).bytes(message.vaccount);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 18, wireType 0 =*/144).uint64(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified PublishCommentToThemeRequest message, length delimited. Does not implicitly {@link dcnet.pb.PublishCommentToThemeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @static
             * @param {dcnet.pb.IPublishCommentToThemeRequest} message PublishCommentToThemeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PublishCommentToThemeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PublishCommentToThemeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.PublishCommentToThemeRequest} PublishCommentToThemeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PublishCommentToThemeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.PublishCommentToThemeRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.commentCid = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.comment = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.commentSize = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.status = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.refercommentkey = reader.bytes();
                            break;
                        }
                    case 11: {
                            message.CCount = reader.uint32();
                            break;
                        }
                    case 12: {
                            message.UpCount = reader.uint32();
                            break;
                        }
                    case 13: {
                            message.DownCount = reader.uint32();
                            break;
                        }
                    case 14: {
                            message.TCount = reader.uint32();
                            break;
                        }
                    case 15: {
                            message.type = reader.uint32();
                            break;
                        }
                    case 16: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 17: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    case 18: {
                            message.timestamp = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PublishCommentToThemeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.PublishCommentToThemeRequest} PublishCommentToThemeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PublishCommentToThemeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PublishCommentToThemeRequest message.
             * @function verify
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PublishCommentToThemeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.commentCid != null && message.hasOwnProperty("commentCid"))
                    if (!(message.commentCid && typeof message.commentCid.length === "number" || $util.isString(message.commentCid)))
                        return "commentCid: buffer expected";
                if (message.comment != null && message.hasOwnProperty("comment"))
                    if (!(message.comment && typeof message.comment.length === "number" || $util.isString(message.comment)))
                        return "comment: buffer expected";
                if (message.commentSize != null && message.hasOwnProperty("commentSize"))
                    if (!$util.isInteger(message.commentSize))
                        return "commentSize: integer expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                if (message.refercommentkey != null && message.hasOwnProperty("refercommentkey"))
                    if (!(message.refercommentkey && typeof message.refercommentkey.length === "number" || $util.isString(message.refercommentkey)))
                        return "refercommentkey: buffer expected";
                if (message.CCount != null && message.hasOwnProperty("CCount"))
                    if (!$util.isInteger(message.CCount))
                        return "CCount: integer expected";
                if (message.UpCount != null && message.hasOwnProperty("UpCount"))
                    if (!$util.isInteger(message.UpCount))
                        return "UpCount: integer expected";
                if (message.DownCount != null && message.hasOwnProperty("DownCount"))
                    if (!$util.isInteger(message.DownCount))
                        return "DownCount: integer expected";
                if (message.TCount != null && message.hasOwnProperty("TCount"))
                    if (!$util.isInteger(message.TCount))
                        return "TCount: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                return null;
            };

            /**
             * Creates a PublishCommentToThemeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.PublishCommentToThemeRequest} PublishCommentToThemeRequest
             */
            PublishCommentToThemeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.PublishCommentToThemeRequest)
                    return object;
                let message = new $root.dcnet.pb.PublishCommentToThemeRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.commentCid != null)
                    if (typeof object.commentCid === "string")
                        $util.base64.decode(object.commentCid, message.commentCid = $util.newBuffer($util.base64.length(object.commentCid)), 0);
                    else if (object.commentCid.length >= 0)
                        message.commentCid = object.commentCid;
                if (object.comment != null)
                    if (typeof object.comment === "string")
                        $util.base64.decode(object.comment, message.comment = $util.newBuffer($util.base64.length(object.comment)), 0);
                    else if (object.comment.length >= 0)
                        message.comment = object.comment;
                if (object.commentSize != null)
                    message.commentSize = object.commentSize >>> 0;
                if (object.status != null)
                    message.status = object.status >>> 0;
                if (object.refercommentkey != null)
                    if (typeof object.refercommentkey === "string")
                        $util.base64.decode(object.refercommentkey, message.refercommentkey = $util.newBuffer($util.base64.length(object.refercommentkey)), 0);
                    else if (object.refercommentkey.length >= 0)
                        message.refercommentkey = object.refercommentkey;
                if (object.CCount != null)
                    message.CCount = object.CCount >>> 0;
                if (object.UpCount != null)
                    message.UpCount = object.UpCount >>> 0;
                if (object.DownCount != null)
                    message.DownCount = object.DownCount >>> 0;
                if (object.TCount != null)
                    message.TCount = object.TCount >>> 0;
                if (object.type != null)
                    message.type = object.type >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a PublishCommentToThemeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @static
             * @param {dcnet.pb.PublishCommentToThemeRequest} message PublishCommentToThemeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PublishCommentToThemeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.commentCid = "";
                    else {
                        object.commentCid = [];
                        if (options.bytes !== Array)
                            object.commentCid = $util.newBuffer(object.commentCid);
                    }
                    if (options.bytes === String)
                        object.comment = "";
                    else {
                        object.comment = [];
                        if (options.bytes !== Array)
                            object.comment = $util.newBuffer(object.comment);
                    }
                    object.commentSize = 0;
                    object.status = 0;
                    if (options.bytes === String)
                        object.refercommentkey = "";
                    else {
                        object.refercommentkey = [];
                        if (options.bytes !== Array)
                            object.refercommentkey = $util.newBuffer(object.refercommentkey);
                    }
                    object.CCount = 0;
                    object.UpCount = 0;
                    object.DownCount = 0;
                    object.TCount = 0;
                    object.type = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.commentCid != null && message.hasOwnProperty("commentCid"))
                    object.commentCid = options.bytes === String ? $util.base64.encode(message.commentCid, 0, message.commentCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.commentCid) : message.commentCid;
                if (message.comment != null && message.hasOwnProperty("comment"))
                    object.comment = options.bytes === String ? $util.base64.encode(message.comment, 0, message.comment.length) : options.bytes === Array ? Array.prototype.slice.call(message.comment) : message.comment;
                if (message.commentSize != null && message.hasOwnProperty("commentSize"))
                    object.commentSize = message.commentSize;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                if (message.refercommentkey != null && message.hasOwnProperty("refercommentkey"))
                    object.refercommentkey = options.bytes === String ? $util.base64.encode(message.refercommentkey, 0, message.refercommentkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.refercommentkey) : message.refercommentkey;
                if (message.CCount != null && message.hasOwnProperty("CCount"))
                    object.CCount = message.CCount;
                if (message.UpCount != null && message.hasOwnProperty("UpCount"))
                    object.UpCount = message.UpCount;
                if (message.DownCount != null && message.hasOwnProperty("DownCount"))
                    object.DownCount = message.DownCount;
                if (message.TCount != null && message.hasOwnProperty("TCount"))
                    object.TCount = message.TCount;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                return object;
            };

            /**
             * Converts this PublishCommentToThemeRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PublishCommentToThemeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PublishCommentToThemeRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.PublishCommentToThemeRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PublishCommentToThemeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.PublishCommentToThemeRequest";
            };

            return PublishCommentToThemeRequest;
        })();

        pb.PublishCommentToThemeReply = (function() {

            /**
             * Properties of a PublishCommentToThemeReply.
             * @memberof dcnet.pb
             * @interface IPublishCommentToThemeReply
             * @property {number|null} [flag] PublishCommentToThemeReply flag
             */

            /**
             * Constructs a new PublishCommentToThemeReply.
             * @memberof dcnet.pb
             * @classdesc Represents a PublishCommentToThemeReply.
             * @implements IPublishCommentToThemeReply
             * @constructor
             * @param {dcnet.pb.IPublishCommentToThemeReply=} [properties] Properties to set
             */
            function PublishCommentToThemeReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PublishCommentToThemeReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.PublishCommentToThemeReply
             * @instance
             */
            PublishCommentToThemeReply.prototype.flag = 0;

            /**
             * Creates a new PublishCommentToThemeReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.PublishCommentToThemeReply
             * @static
             * @param {dcnet.pb.IPublishCommentToThemeReply=} [properties] Properties to set
             * @returns {dcnet.pb.PublishCommentToThemeReply} PublishCommentToThemeReply instance
             */
            PublishCommentToThemeReply.create = function create(properties) {
                return new PublishCommentToThemeReply(properties);
            };

            /**
             * Encodes the specified PublishCommentToThemeReply message. Does not implicitly {@link dcnet.pb.PublishCommentToThemeReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.PublishCommentToThemeReply
             * @static
             * @param {dcnet.pb.IPublishCommentToThemeReply} message PublishCommentToThemeReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PublishCommentToThemeReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified PublishCommentToThemeReply message, length delimited. Does not implicitly {@link dcnet.pb.PublishCommentToThemeReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.PublishCommentToThemeReply
             * @static
             * @param {dcnet.pb.IPublishCommentToThemeReply} message PublishCommentToThemeReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PublishCommentToThemeReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PublishCommentToThemeReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.PublishCommentToThemeReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.PublishCommentToThemeReply} PublishCommentToThemeReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PublishCommentToThemeReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.PublishCommentToThemeReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PublishCommentToThemeReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.PublishCommentToThemeReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.PublishCommentToThemeReply} PublishCommentToThemeReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PublishCommentToThemeReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PublishCommentToThemeReply message.
             * @function verify
             * @memberof dcnet.pb.PublishCommentToThemeReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PublishCommentToThemeReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a PublishCommentToThemeReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.PublishCommentToThemeReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.PublishCommentToThemeReply} PublishCommentToThemeReply
             */
            PublishCommentToThemeReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.PublishCommentToThemeReply)
                    return object;
                let message = new $root.dcnet.pb.PublishCommentToThemeReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a PublishCommentToThemeReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.PublishCommentToThemeReply
             * @static
             * @param {dcnet.pb.PublishCommentToThemeReply} message PublishCommentToThemeReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PublishCommentToThemeReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this PublishCommentToThemeReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.PublishCommentToThemeReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PublishCommentToThemeReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PublishCommentToThemeReply
             * @function getTypeUrl
             * @memberof dcnet.pb.PublishCommentToThemeReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PublishCommentToThemeReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.PublishCommentToThemeReply";
            };

            return PublishCommentToThemeReply;
        })();

        pb.SetKeyValueRequest = (function() {

            /**
             * Properties of a SetKeyValueRequest.
             * @memberof dcnet.pb
             * @interface ISetKeyValueRequest
             * @property {Uint8Array|null} [theme] SetKeyValueRequest theme
             * @property {Uint8Array|null} [appId] SetKeyValueRequest appId
             * @property {Uint8Array|null} [themeAuthor] SetKeyValueRequest themeAuthor
             * @property {number|null} [blockheight] SetKeyValueRequest blockheight
             * @property {Uint8Array|null} [userPubkey] SetKeyValueRequest userPubkey
             * @property {Uint8Array|null} [contentCid] SetKeyValueRequest contentCid
             * @property {Uint8Array|null} [content] SetKeyValueRequest content
             * @property {number|null} [contentSize] SetKeyValueRequest contentSize
             * @property {number|null} [type] SetKeyValueRequest type
             * @property {Uint8Array|null} [signature] SetKeyValueRequest signature
             * @property {Uint8Array|null} [vaccount] SetKeyValueRequest vaccount
             */

            /**
             * Constructs a new SetKeyValueRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a SetKeyValueRequest.
             * @implements ISetKeyValueRequest
             * @constructor
             * @param {dcnet.pb.ISetKeyValueRequest=} [properties] Properties to set
             */
            function SetKeyValueRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetKeyValueRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             */
            SetKeyValueRequest.prototype.theme = $util.newBuffer([]);

            /**
             * SetKeyValueRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             */
            SetKeyValueRequest.prototype.appId = $util.newBuffer([]);

            /**
             * SetKeyValueRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             */
            SetKeyValueRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * SetKeyValueRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             */
            SetKeyValueRequest.prototype.blockheight = 0;

            /**
             * SetKeyValueRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             */
            SetKeyValueRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * SetKeyValueRequest contentCid.
             * @member {Uint8Array} contentCid
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             */
            SetKeyValueRequest.prototype.contentCid = $util.newBuffer([]);

            /**
             * SetKeyValueRequest content.
             * @member {Uint8Array} content
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             */
            SetKeyValueRequest.prototype.content = $util.newBuffer([]);

            /**
             * SetKeyValueRequest contentSize.
             * @member {number} contentSize
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             */
            SetKeyValueRequest.prototype.contentSize = 0;

            /**
             * SetKeyValueRequest type.
             * @member {number} type
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             */
            SetKeyValueRequest.prototype.type = 0;

            /**
             * SetKeyValueRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             */
            SetKeyValueRequest.prototype.signature = $util.newBuffer([]);

            /**
             * SetKeyValueRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             */
            SetKeyValueRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new SetKeyValueRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SetKeyValueRequest
             * @static
             * @param {dcnet.pb.ISetKeyValueRequest=} [properties] Properties to set
             * @returns {dcnet.pb.SetKeyValueRequest} SetKeyValueRequest instance
             */
            SetKeyValueRequest.create = function create(properties) {
                return new SetKeyValueRequest(properties);
            };

            /**
             * Encodes the specified SetKeyValueRequest message. Does not implicitly {@link dcnet.pb.SetKeyValueRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SetKeyValueRequest
             * @static
             * @param {dcnet.pb.ISetKeyValueRequest} message SetKeyValueRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetKeyValueRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockheight);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.userPubkey);
                if (message.contentCid != null && Object.hasOwnProperty.call(message, "contentCid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.contentCid);
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.content);
                if (message.contentSize != null && Object.hasOwnProperty.call(message, "contentSize"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.contentSize);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.type);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified SetKeyValueRequest message, length delimited. Does not implicitly {@link dcnet.pb.SetKeyValueRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SetKeyValueRequest
             * @static
             * @param {dcnet.pb.ISetKeyValueRequest} message SetKeyValueRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetKeyValueRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetKeyValueRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SetKeyValueRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SetKeyValueRequest} SetKeyValueRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetKeyValueRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SetKeyValueRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.contentCid = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.content = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.contentSize = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.type = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 11: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetKeyValueRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SetKeyValueRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SetKeyValueRequest} SetKeyValueRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetKeyValueRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetKeyValueRequest message.
             * @function verify
             * @memberof dcnet.pb.SetKeyValueRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetKeyValueRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.contentCid != null && message.hasOwnProperty("contentCid"))
                    if (!(message.contentCid && typeof message.contentCid.length === "number" || $util.isString(message.contentCid)))
                        return "contentCid: buffer expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                        return "content: buffer expected";
                if (message.contentSize != null && message.hasOwnProperty("contentSize"))
                    if (!$util.isInteger(message.contentSize))
                        return "contentSize: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a SetKeyValueRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SetKeyValueRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SetKeyValueRequest} SetKeyValueRequest
             */
            SetKeyValueRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SetKeyValueRequest)
                    return object;
                let message = new $root.dcnet.pb.SetKeyValueRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.contentCid != null)
                    if (typeof object.contentCid === "string")
                        $util.base64.decode(object.contentCid, message.contentCid = $util.newBuffer($util.base64.length(object.contentCid)), 0);
                    else if (object.contentCid.length >= 0)
                        message.contentCid = object.contentCid;
                if (object.content != null)
                    if (typeof object.content === "string")
                        $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                    else if (object.content.length >= 0)
                        message.content = object.content;
                if (object.contentSize != null)
                    message.contentSize = object.contentSize >>> 0;
                if (object.type != null)
                    message.type = object.type >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a SetKeyValueRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SetKeyValueRequest
             * @static
             * @param {dcnet.pb.SetKeyValueRequest} message SetKeyValueRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetKeyValueRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.contentCid = "";
                    else {
                        object.contentCid = [];
                        if (options.bytes !== Array)
                            object.contentCid = $util.newBuffer(object.contentCid);
                    }
                    if (options.bytes === String)
                        object.content = "";
                    else {
                        object.content = [];
                        if (options.bytes !== Array)
                            object.content = $util.newBuffer(object.content);
                    }
                    object.contentSize = 0;
                    object.type = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.contentCid != null && message.hasOwnProperty("contentCid"))
                    object.contentCid = options.bytes === String ? $util.base64.encode(message.contentCid, 0, message.contentCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.contentCid) : message.contentCid;
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                if (message.contentSize != null && message.hasOwnProperty("contentSize"))
                    object.contentSize = message.contentSize;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this SetKeyValueRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SetKeyValueRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetKeyValueRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetKeyValueRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.SetKeyValueRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetKeyValueRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SetKeyValueRequest";
            };

            return SetKeyValueRequest;
        })();

        pb.SetKeyValueReply = (function() {

            /**
             * Properties of a SetKeyValueReply.
             * @memberof dcnet.pb
             * @interface ISetKeyValueReply
             * @property {number|null} [flag] SetKeyValueReply flag
             */

            /**
             * Constructs a new SetKeyValueReply.
             * @memberof dcnet.pb
             * @classdesc Represents a SetKeyValueReply.
             * @implements ISetKeyValueReply
             * @constructor
             * @param {dcnet.pb.ISetKeyValueReply=} [properties] Properties to set
             */
            function SetKeyValueReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetKeyValueReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.SetKeyValueReply
             * @instance
             */
            SetKeyValueReply.prototype.flag = 0;

            /**
             * Creates a new SetKeyValueReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SetKeyValueReply
             * @static
             * @param {dcnet.pb.ISetKeyValueReply=} [properties] Properties to set
             * @returns {dcnet.pb.SetKeyValueReply} SetKeyValueReply instance
             */
            SetKeyValueReply.create = function create(properties) {
                return new SetKeyValueReply(properties);
            };

            /**
             * Encodes the specified SetKeyValueReply message. Does not implicitly {@link dcnet.pb.SetKeyValueReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SetKeyValueReply
             * @static
             * @param {dcnet.pb.ISetKeyValueReply} message SetKeyValueReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetKeyValueReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified SetKeyValueReply message, length delimited. Does not implicitly {@link dcnet.pb.SetKeyValueReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SetKeyValueReply
             * @static
             * @param {dcnet.pb.ISetKeyValueReply} message SetKeyValueReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetKeyValueReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetKeyValueReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SetKeyValueReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SetKeyValueReply} SetKeyValueReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetKeyValueReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SetKeyValueReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetKeyValueReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SetKeyValueReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SetKeyValueReply} SetKeyValueReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetKeyValueReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetKeyValueReply message.
             * @function verify
             * @memberof dcnet.pb.SetKeyValueReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetKeyValueReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a SetKeyValueReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SetKeyValueReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SetKeyValueReply} SetKeyValueReply
             */
            SetKeyValueReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SetKeyValueReply)
                    return object;
                let message = new $root.dcnet.pb.SetKeyValueReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SetKeyValueReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SetKeyValueReply
             * @static
             * @param {dcnet.pb.SetKeyValueReply} message SetKeyValueReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetKeyValueReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this SetKeyValueReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SetKeyValueReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetKeyValueReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetKeyValueReply
             * @function getTypeUrl
             * @memberof dcnet.pb.SetKeyValueReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetKeyValueReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SetKeyValueReply";
            };

            return SetKeyValueReply;
        })();

        pb.ConfigThemeObjAuthRequest = (function() {

            /**
             * Properties of a ConfigThemeObjAuthRequest.
             * @memberof dcnet.pb
             * @interface IConfigThemeObjAuthRequest
             * @property {Uint8Array|null} [theme] ConfigThemeObjAuthRequest theme
             * @property {Uint8Array|null} [appId] ConfigThemeObjAuthRequest appId
             * @property {Uint8Array|null} [themeAuthor] ConfigThemeObjAuthRequest themeAuthor
             * @property {number|null} [blockheight] ConfigThemeObjAuthRequest blockheight
             * @property {Uint8Array|null} [userPubkey] ConfigThemeObjAuthRequest userPubkey
             * @property {Uint8Array|null} [contentCid] ConfigThemeObjAuthRequest contentCid
             * @property {Uint8Array|null} [content] ConfigThemeObjAuthRequest content
             * @property {number|null} [contentSize] ConfigThemeObjAuthRequest contentSize
             * @property {number|null} [type] ConfigThemeObjAuthRequest type
             * @property {Uint8Array|null} [signature] ConfigThemeObjAuthRequest signature
             * @property {Uint8Array|null} [vaccount] ConfigThemeObjAuthRequest vaccount
             */

            /**
             * Constructs a new ConfigThemeObjAuthRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a ConfigThemeObjAuthRequest.
             * @implements IConfigThemeObjAuthRequest
             * @constructor
             * @param {dcnet.pb.IConfigThemeObjAuthRequest=} [properties] Properties to set
             */
            function ConfigThemeObjAuthRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConfigThemeObjAuthRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             */
            ConfigThemeObjAuthRequest.prototype.theme = $util.newBuffer([]);

            /**
             * ConfigThemeObjAuthRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             */
            ConfigThemeObjAuthRequest.prototype.appId = $util.newBuffer([]);

            /**
             * ConfigThemeObjAuthRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             */
            ConfigThemeObjAuthRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * ConfigThemeObjAuthRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             */
            ConfigThemeObjAuthRequest.prototype.blockheight = 0;

            /**
             * ConfigThemeObjAuthRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             */
            ConfigThemeObjAuthRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * ConfigThemeObjAuthRequest contentCid.
             * @member {Uint8Array} contentCid
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             */
            ConfigThemeObjAuthRequest.prototype.contentCid = $util.newBuffer([]);

            /**
             * ConfigThemeObjAuthRequest content.
             * @member {Uint8Array} content
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             */
            ConfigThemeObjAuthRequest.prototype.content = $util.newBuffer([]);

            /**
             * ConfigThemeObjAuthRequest contentSize.
             * @member {number} contentSize
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             */
            ConfigThemeObjAuthRequest.prototype.contentSize = 0;

            /**
             * ConfigThemeObjAuthRequest type.
             * @member {number} type
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             */
            ConfigThemeObjAuthRequest.prototype.type = 0;

            /**
             * ConfigThemeObjAuthRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             */
            ConfigThemeObjAuthRequest.prototype.signature = $util.newBuffer([]);

            /**
             * ConfigThemeObjAuthRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             */
            ConfigThemeObjAuthRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new ConfigThemeObjAuthRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @static
             * @param {dcnet.pb.IConfigThemeObjAuthRequest=} [properties] Properties to set
             * @returns {dcnet.pb.ConfigThemeObjAuthRequest} ConfigThemeObjAuthRequest instance
             */
            ConfigThemeObjAuthRequest.create = function create(properties) {
                return new ConfigThemeObjAuthRequest(properties);
            };

            /**
             * Encodes the specified ConfigThemeObjAuthRequest message. Does not implicitly {@link dcnet.pb.ConfigThemeObjAuthRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @static
             * @param {dcnet.pb.IConfigThemeObjAuthRequest} message ConfigThemeObjAuthRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigThemeObjAuthRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockheight);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.userPubkey);
                if (message.contentCid != null && Object.hasOwnProperty.call(message, "contentCid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.contentCid);
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.content);
                if (message.contentSize != null && Object.hasOwnProperty.call(message, "contentSize"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.contentSize);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.type);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified ConfigThemeObjAuthRequest message, length delimited. Does not implicitly {@link dcnet.pb.ConfigThemeObjAuthRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @static
             * @param {dcnet.pb.IConfigThemeObjAuthRequest} message ConfigThemeObjAuthRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigThemeObjAuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConfigThemeObjAuthRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ConfigThemeObjAuthRequest} ConfigThemeObjAuthRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigThemeObjAuthRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ConfigThemeObjAuthRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.contentCid = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.content = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.contentSize = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.type = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 11: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConfigThemeObjAuthRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ConfigThemeObjAuthRequest} ConfigThemeObjAuthRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigThemeObjAuthRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConfigThemeObjAuthRequest message.
             * @function verify
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigThemeObjAuthRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.contentCid != null && message.hasOwnProperty("contentCid"))
                    if (!(message.contentCid && typeof message.contentCid.length === "number" || $util.isString(message.contentCid)))
                        return "contentCid: buffer expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                        return "content: buffer expected";
                if (message.contentSize != null && message.hasOwnProperty("contentSize"))
                    if (!$util.isInteger(message.contentSize))
                        return "contentSize: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a ConfigThemeObjAuthRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ConfigThemeObjAuthRequest} ConfigThemeObjAuthRequest
             */
            ConfigThemeObjAuthRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ConfigThemeObjAuthRequest)
                    return object;
                let message = new $root.dcnet.pb.ConfigThemeObjAuthRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.contentCid != null)
                    if (typeof object.contentCid === "string")
                        $util.base64.decode(object.contentCid, message.contentCid = $util.newBuffer($util.base64.length(object.contentCid)), 0);
                    else if (object.contentCid.length >= 0)
                        message.contentCid = object.contentCid;
                if (object.content != null)
                    if (typeof object.content === "string")
                        $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                    else if (object.content.length >= 0)
                        message.content = object.content;
                if (object.contentSize != null)
                    message.contentSize = object.contentSize >>> 0;
                if (object.type != null)
                    message.type = object.type >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a ConfigThemeObjAuthRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @static
             * @param {dcnet.pb.ConfigThemeObjAuthRequest} message ConfigThemeObjAuthRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigThemeObjAuthRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.contentCid = "";
                    else {
                        object.contentCid = [];
                        if (options.bytes !== Array)
                            object.contentCid = $util.newBuffer(object.contentCid);
                    }
                    if (options.bytes === String)
                        object.content = "";
                    else {
                        object.content = [];
                        if (options.bytes !== Array)
                            object.content = $util.newBuffer(object.content);
                    }
                    object.contentSize = 0;
                    object.type = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.contentCid != null && message.hasOwnProperty("contentCid"))
                    object.contentCid = options.bytes === String ? $util.base64.encode(message.contentCid, 0, message.contentCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.contentCid) : message.contentCid;
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                if (message.contentSize != null && message.hasOwnProperty("contentSize"))
                    object.contentSize = message.contentSize;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this ConfigThemeObjAuthRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigThemeObjAuthRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ConfigThemeObjAuthRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.ConfigThemeObjAuthRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ConfigThemeObjAuthRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ConfigThemeObjAuthRequest";
            };

            return ConfigThemeObjAuthRequest;
        })();

        pb.ConfigThemeObjAuthReply = (function() {

            /**
             * Properties of a ConfigThemeObjAuthReply.
             * @memberof dcnet.pb
             * @interface IConfigThemeObjAuthReply
             * @property {number|null} [flag] ConfigThemeObjAuthReply flag
             */

            /**
             * Constructs a new ConfigThemeObjAuthReply.
             * @memberof dcnet.pb
             * @classdesc Represents a ConfigThemeObjAuthReply.
             * @implements IConfigThemeObjAuthReply
             * @constructor
             * @param {dcnet.pb.IConfigThemeObjAuthReply=} [properties] Properties to set
             */
            function ConfigThemeObjAuthReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConfigThemeObjAuthReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.ConfigThemeObjAuthReply
             * @instance
             */
            ConfigThemeObjAuthReply.prototype.flag = 0;

            /**
             * Creates a new ConfigThemeObjAuthReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ConfigThemeObjAuthReply
             * @static
             * @param {dcnet.pb.IConfigThemeObjAuthReply=} [properties] Properties to set
             * @returns {dcnet.pb.ConfigThemeObjAuthReply} ConfigThemeObjAuthReply instance
             */
            ConfigThemeObjAuthReply.create = function create(properties) {
                return new ConfigThemeObjAuthReply(properties);
            };

            /**
             * Encodes the specified ConfigThemeObjAuthReply message. Does not implicitly {@link dcnet.pb.ConfigThemeObjAuthReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ConfigThemeObjAuthReply
             * @static
             * @param {dcnet.pb.IConfigThemeObjAuthReply} message ConfigThemeObjAuthReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigThemeObjAuthReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified ConfigThemeObjAuthReply message, length delimited. Does not implicitly {@link dcnet.pb.ConfigThemeObjAuthReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ConfigThemeObjAuthReply
             * @static
             * @param {dcnet.pb.IConfigThemeObjAuthReply} message ConfigThemeObjAuthReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigThemeObjAuthReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConfigThemeObjAuthReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ConfigThemeObjAuthReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ConfigThemeObjAuthReply} ConfigThemeObjAuthReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigThemeObjAuthReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ConfigThemeObjAuthReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConfigThemeObjAuthReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ConfigThemeObjAuthReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ConfigThemeObjAuthReply} ConfigThemeObjAuthReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigThemeObjAuthReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConfigThemeObjAuthReply message.
             * @function verify
             * @memberof dcnet.pb.ConfigThemeObjAuthReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigThemeObjAuthReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a ConfigThemeObjAuthReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ConfigThemeObjAuthReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ConfigThemeObjAuthReply} ConfigThemeObjAuthReply
             */
            ConfigThemeObjAuthReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ConfigThemeObjAuthReply)
                    return object;
                let message = new $root.dcnet.pb.ConfigThemeObjAuthReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ConfigThemeObjAuthReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ConfigThemeObjAuthReply
             * @static
             * @param {dcnet.pb.ConfigThemeObjAuthReply} message ConfigThemeObjAuthReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigThemeObjAuthReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this ConfigThemeObjAuthReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ConfigThemeObjAuthReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigThemeObjAuthReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ConfigThemeObjAuthReply
             * @function getTypeUrl
             * @memberof dcnet.pb.ConfigThemeObjAuthReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ConfigThemeObjAuthReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ConfigThemeObjAuthReply";
            };

            return ConfigThemeObjAuthReply;
        })();

        pb.AddUserOffChainSpaceRequest = (function() {

            /**
             * Properties of an AddUserOffChainSpaceRequest.
             * @memberof dcnet.pb
             * @interface IAddUserOffChainSpaceRequest
             * @property {Uint8Array|null} [userPubkey] AddUserOffChainSpaceRequest userPubkey
             * @property {number|null} [blockheight] AddUserOffChainSpaceRequest blockheight
             * @property {Uint8Array|null} [peerid] AddUserOffChainSpaceRequest peerid
             * @property {Uint8Array|null} [signature] AddUserOffChainSpaceRequest signature
             * @property {Uint8Array|null} [vaccount] AddUserOffChainSpaceRequest vaccount
             */

            /**
             * Constructs a new AddUserOffChainSpaceRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AddUserOffChainSpaceRequest.
             * @implements IAddUserOffChainSpaceRequest
             * @constructor
             * @param {dcnet.pb.IAddUserOffChainSpaceRequest=} [properties] Properties to set
             */
            function AddUserOffChainSpaceRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddUserOffChainSpaceRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @instance
             */
            AddUserOffChainSpaceRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * AddUserOffChainSpaceRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @instance
             */
            AddUserOffChainSpaceRequest.prototype.blockheight = 0;

            /**
             * AddUserOffChainSpaceRequest peerid.
             * @member {Uint8Array} peerid
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @instance
             */
            AddUserOffChainSpaceRequest.prototype.peerid = $util.newBuffer([]);

            /**
             * AddUserOffChainSpaceRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @instance
             */
            AddUserOffChainSpaceRequest.prototype.signature = $util.newBuffer([]);

            /**
             * AddUserOffChainSpaceRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @instance
             */
            AddUserOffChainSpaceRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new AddUserOffChainSpaceRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @static
             * @param {dcnet.pb.IAddUserOffChainSpaceRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AddUserOffChainSpaceRequest} AddUserOffChainSpaceRequest instance
             */
            AddUserOffChainSpaceRequest.create = function create(properties) {
                return new AddUserOffChainSpaceRequest(properties);
            };

            /**
             * Encodes the specified AddUserOffChainSpaceRequest message. Does not implicitly {@link dcnet.pb.AddUserOffChainSpaceRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @static
             * @param {dcnet.pb.IAddUserOffChainSpaceRequest} message AddUserOffChainSpaceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddUserOffChainSpaceRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.peerid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified AddUserOffChainSpaceRequest message, length delimited. Does not implicitly {@link dcnet.pb.AddUserOffChainSpaceRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @static
             * @param {dcnet.pb.IAddUserOffChainSpaceRequest} message AddUserOffChainSpaceRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddUserOffChainSpaceRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddUserOffChainSpaceRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddUserOffChainSpaceRequest} AddUserOffChainSpaceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddUserOffChainSpaceRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddUserOffChainSpaceRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.peerid = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddUserOffChainSpaceRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddUserOffChainSpaceRequest} AddUserOffChainSpaceRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddUserOffChainSpaceRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddUserOffChainSpaceRequest message.
             * @function verify
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddUserOffChainSpaceRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                        return "peerid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates an AddUserOffChainSpaceRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddUserOffChainSpaceRequest} AddUserOffChainSpaceRequest
             */
            AddUserOffChainSpaceRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddUserOffChainSpaceRequest)
                    return object;
                let message = new $root.dcnet.pb.AddUserOffChainSpaceRequest();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.peerid != null)
                    if (typeof object.peerid === "string")
                        $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                    else if (object.peerid.length >= 0)
                        message.peerid = object.peerid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from an AddUserOffChainSpaceRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @static
             * @param {dcnet.pb.AddUserOffChainSpaceRequest} message AddUserOffChainSpaceRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddUserOffChainSpaceRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.peerid = "";
                    else {
                        object.peerid = [];
                        if (options.bytes !== Array)
                            object.peerid = $util.newBuffer(object.peerid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this AddUserOffChainSpaceRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddUserOffChainSpaceRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddUserOffChainSpaceRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AddUserOffChainSpaceRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddUserOffChainSpaceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddUserOffChainSpaceRequest";
            };

            return AddUserOffChainSpaceRequest;
        })();

        pb.AddUserOffChainSpaceReply = (function() {

            /**
             * Properties of an AddUserOffChainSpaceReply.
             * @memberof dcnet.pb
             * @interface IAddUserOffChainSpaceReply
             */

            /**
             * Constructs a new AddUserOffChainSpaceReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AddUserOffChainSpaceReply.
             * @implements IAddUserOffChainSpaceReply
             * @constructor
             * @param {dcnet.pb.IAddUserOffChainSpaceReply=} [properties] Properties to set
             */
            function AddUserOffChainSpaceReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new AddUserOffChainSpaceReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddUserOffChainSpaceReply
             * @static
             * @param {dcnet.pb.IAddUserOffChainSpaceReply=} [properties] Properties to set
             * @returns {dcnet.pb.AddUserOffChainSpaceReply} AddUserOffChainSpaceReply instance
             */
            AddUserOffChainSpaceReply.create = function create(properties) {
                return new AddUserOffChainSpaceReply(properties);
            };

            /**
             * Encodes the specified AddUserOffChainSpaceReply message. Does not implicitly {@link dcnet.pb.AddUserOffChainSpaceReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddUserOffChainSpaceReply
             * @static
             * @param {dcnet.pb.IAddUserOffChainSpaceReply} message AddUserOffChainSpaceReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddUserOffChainSpaceReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified AddUserOffChainSpaceReply message, length delimited. Does not implicitly {@link dcnet.pb.AddUserOffChainSpaceReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddUserOffChainSpaceReply
             * @static
             * @param {dcnet.pb.IAddUserOffChainSpaceReply} message AddUserOffChainSpaceReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddUserOffChainSpaceReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddUserOffChainSpaceReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddUserOffChainSpaceReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddUserOffChainSpaceReply} AddUserOffChainSpaceReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddUserOffChainSpaceReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddUserOffChainSpaceReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddUserOffChainSpaceReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddUserOffChainSpaceReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddUserOffChainSpaceReply} AddUserOffChainSpaceReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddUserOffChainSpaceReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddUserOffChainSpaceReply message.
             * @function verify
             * @memberof dcnet.pb.AddUserOffChainSpaceReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddUserOffChainSpaceReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an AddUserOffChainSpaceReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddUserOffChainSpaceReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddUserOffChainSpaceReply} AddUserOffChainSpaceReply
             */
            AddUserOffChainSpaceReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddUserOffChainSpaceReply)
                    return object;
                return new $root.dcnet.pb.AddUserOffChainSpaceReply();
            };

            /**
             * Creates a plain object from an AddUserOffChainSpaceReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddUserOffChainSpaceReply
             * @static
             * @param {dcnet.pb.AddUserOffChainSpaceReply} message AddUserOffChainSpaceReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddUserOffChainSpaceReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this AddUserOffChainSpaceReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddUserOffChainSpaceReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddUserOffChainSpaceReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddUserOffChainSpaceReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AddUserOffChainSpaceReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddUserOffChainSpaceReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddUserOffChainSpaceReply";
            };

            return AddUserOffChainSpaceReply;
        })();

        pb.ReportMaliciousCommentRequest = (function() {

            /**
             * Properties of a ReportMaliciousCommentRequest.
             * @memberof dcnet.pb
             * @interface IReportMaliciousCommentRequest
             * @property {Uint8Array|null} [theme] ReportMaliciousCommentRequest theme
             * @property {Uint8Array|null} [appId] ReportMaliciousCommentRequest appId
             * @property {Uint8Array|null} [themeAuthor] ReportMaliciousCommentRequest themeAuthor
             * @property {number|null} [blockheight] ReportMaliciousCommentRequest blockheight
             * @property {number|null} [commentBlockheight] ReportMaliciousCommentRequest commentBlockheight
             * @property {Uint8Array|null} [commentCid] ReportMaliciousCommentRequest commentCid
             * @property {Uint8Array|null} [signature] ReportMaliciousCommentRequest signature
             * @property {Uint8Array|null} [vaccount] ReportMaliciousCommentRequest vaccount
             */

            /**
             * Constructs a new ReportMaliciousCommentRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a ReportMaliciousCommentRequest.
             * @implements IReportMaliciousCommentRequest
             * @constructor
             * @param {dcnet.pb.IReportMaliciousCommentRequest=} [properties] Properties to set
             */
            function ReportMaliciousCommentRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReportMaliciousCommentRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @instance
             */
            ReportMaliciousCommentRequest.prototype.theme = $util.newBuffer([]);

            /**
             * ReportMaliciousCommentRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @instance
             */
            ReportMaliciousCommentRequest.prototype.appId = $util.newBuffer([]);

            /**
             * ReportMaliciousCommentRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @instance
             */
            ReportMaliciousCommentRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * ReportMaliciousCommentRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @instance
             */
            ReportMaliciousCommentRequest.prototype.blockheight = 0;

            /**
             * ReportMaliciousCommentRequest commentBlockheight.
             * @member {number} commentBlockheight
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @instance
             */
            ReportMaliciousCommentRequest.prototype.commentBlockheight = 0;

            /**
             * ReportMaliciousCommentRequest commentCid.
             * @member {Uint8Array} commentCid
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @instance
             */
            ReportMaliciousCommentRequest.prototype.commentCid = $util.newBuffer([]);

            /**
             * ReportMaliciousCommentRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @instance
             */
            ReportMaliciousCommentRequest.prototype.signature = $util.newBuffer([]);

            /**
             * ReportMaliciousCommentRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @instance
             */
            ReportMaliciousCommentRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new ReportMaliciousCommentRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @static
             * @param {dcnet.pb.IReportMaliciousCommentRequest=} [properties] Properties to set
             * @returns {dcnet.pb.ReportMaliciousCommentRequest} ReportMaliciousCommentRequest instance
             */
            ReportMaliciousCommentRequest.create = function create(properties) {
                return new ReportMaliciousCommentRequest(properties);
            };

            /**
             * Encodes the specified ReportMaliciousCommentRequest message. Does not implicitly {@link dcnet.pb.ReportMaliciousCommentRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @static
             * @param {dcnet.pb.IReportMaliciousCommentRequest} message ReportMaliciousCommentRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportMaliciousCommentRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockheight);
                if (message.commentBlockheight != null && Object.hasOwnProperty.call(message, "commentBlockheight"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.commentBlockheight);
                if (message.commentCid != null && Object.hasOwnProperty.call(message, "commentCid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.commentCid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified ReportMaliciousCommentRequest message, length delimited. Does not implicitly {@link dcnet.pb.ReportMaliciousCommentRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @static
             * @param {dcnet.pb.IReportMaliciousCommentRequest} message ReportMaliciousCommentRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportMaliciousCommentRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReportMaliciousCommentRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ReportMaliciousCommentRequest} ReportMaliciousCommentRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportMaliciousCommentRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ReportMaliciousCommentRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.commentBlockheight = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.commentCid = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReportMaliciousCommentRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ReportMaliciousCommentRequest} ReportMaliciousCommentRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportMaliciousCommentRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReportMaliciousCommentRequest message.
             * @function verify
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReportMaliciousCommentRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.commentBlockheight != null && message.hasOwnProperty("commentBlockheight"))
                    if (!$util.isInteger(message.commentBlockheight))
                        return "commentBlockheight: integer expected";
                if (message.commentCid != null && message.hasOwnProperty("commentCid"))
                    if (!(message.commentCid && typeof message.commentCid.length === "number" || $util.isString(message.commentCid)))
                        return "commentCid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a ReportMaliciousCommentRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ReportMaliciousCommentRequest} ReportMaliciousCommentRequest
             */
            ReportMaliciousCommentRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ReportMaliciousCommentRequest)
                    return object;
                let message = new $root.dcnet.pb.ReportMaliciousCommentRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.commentBlockheight != null)
                    message.commentBlockheight = object.commentBlockheight >>> 0;
                if (object.commentCid != null)
                    if (typeof object.commentCid === "string")
                        $util.base64.decode(object.commentCid, message.commentCid = $util.newBuffer($util.base64.length(object.commentCid)), 0);
                    else if (object.commentCid.length >= 0)
                        message.commentCid = object.commentCid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a ReportMaliciousCommentRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @static
             * @param {dcnet.pb.ReportMaliciousCommentRequest} message ReportMaliciousCommentRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReportMaliciousCommentRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.blockheight = 0;
                    object.commentBlockheight = 0;
                    if (options.bytes === String)
                        object.commentCid = "";
                    else {
                        object.commentCid = [];
                        if (options.bytes !== Array)
                            object.commentCid = $util.newBuffer(object.commentCid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.commentBlockheight != null && message.hasOwnProperty("commentBlockheight"))
                    object.commentBlockheight = message.commentBlockheight;
                if (message.commentCid != null && message.hasOwnProperty("commentCid"))
                    object.commentCid = options.bytes === String ? $util.base64.encode(message.commentCid, 0, message.commentCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.commentCid) : message.commentCid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this ReportMaliciousCommentRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReportMaliciousCommentRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReportMaliciousCommentRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.ReportMaliciousCommentRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReportMaliciousCommentRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ReportMaliciousCommentRequest";
            };

            return ReportMaliciousCommentRequest;
        })();

        pb.ReportMaliciousCommentReply = (function() {

            /**
             * Properties of a ReportMaliciousCommentReply.
             * @memberof dcnet.pb
             * @interface IReportMaliciousCommentReply
             * @property {number|null} [flag] ReportMaliciousCommentReply flag
             */

            /**
             * Constructs a new ReportMaliciousCommentReply.
             * @memberof dcnet.pb
             * @classdesc Represents a ReportMaliciousCommentReply.
             * @implements IReportMaliciousCommentReply
             * @constructor
             * @param {dcnet.pb.IReportMaliciousCommentReply=} [properties] Properties to set
             */
            function ReportMaliciousCommentReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReportMaliciousCommentReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.ReportMaliciousCommentReply
             * @instance
             */
            ReportMaliciousCommentReply.prototype.flag = 0;

            /**
             * Creates a new ReportMaliciousCommentReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ReportMaliciousCommentReply
             * @static
             * @param {dcnet.pb.IReportMaliciousCommentReply=} [properties] Properties to set
             * @returns {dcnet.pb.ReportMaliciousCommentReply} ReportMaliciousCommentReply instance
             */
            ReportMaliciousCommentReply.create = function create(properties) {
                return new ReportMaliciousCommentReply(properties);
            };

            /**
             * Encodes the specified ReportMaliciousCommentReply message. Does not implicitly {@link dcnet.pb.ReportMaliciousCommentReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ReportMaliciousCommentReply
             * @static
             * @param {dcnet.pb.IReportMaliciousCommentReply} message ReportMaliciousCommentReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportMaliciousCommentReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified ReportMaliciousCommentReply message, length delimited. Does not implicitly {@link dcnet.pb.ReportMaliciousCommentReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ReportMaliciousCommentReply
             * @static
             * @param {dcnet.pb.IReportMaliciousCommentReply} message ReportMaliciousCommentReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReportMaliciousCommentReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReportMaliciousCommentReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ReportMaliciousCommentReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ReportMaliciousCommentReply} ReportMaliciousCommentReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportMaliciousCommentReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ReportMaliciousCommentReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReportMaliciousCommentReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ReportMaliciousCommentReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ReportMaliciousCommentReply} ReportMaliciousCommentReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReportMaliciousCommentReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReportMaliciousCommentReply message.
             * @function verify
             * @memberof dcnet.pb.ReportMaliciousCommentReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReportMaliciousCommentReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a ReportMaliciousCommentReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ReportMaliciousCommentReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ReportMaliciousCommentReply} ReportMaliciousCommentReply
             */
            ReportMaliciousCommentReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ReportMaliciousCommentReply)
                    return object;
                let message = new $root.dcnet.pb.ReportMaliciousCommentReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ReportMaliciousCommentReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ReportMaliciousCommentReply
             * @static
             * @param {dcnet.pb.ReportMaliciousCommentReply} message ReportMaliciousCommentReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReportMaliciousCommentReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this ReportMaliciousCommentReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ReportMaliciousCommentReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReportMaliciousCommentReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReportMaliciousCommentReply
             * @function getTypeUrl
             * @memberof dcnet.pb.ReportMaliciousCommentReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReportMaliciousCommentReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ReportMaliciousCommentReply";
            };

            return ReportMaliciousCommentReply;
        })();

        pb.SetObjCommentPublicRequest = (function() {

            /**
             * Properties of a SetObjCommentPublicRequest.
             * @memberof dcnet.pb
             * @interface ISetObjCommentPublicRequest
             * @property {Uint8Array|null} [theme] SetObjCommentPublicRequest theme
             * @property {Uint8Array|null} [appId] SetObjCommentPublicRequest appId
             * @property {Uint8Array|null} [themeAuthor] SetObjCommentPublicRequest themeAuthor
             * @property {number|null} [blockheight] SetObjCommentPublicRequest blockheight
             * @property {number|null} [commentBlockheight] SetObjCommentPublicRequest commentBlockheight
             * @property {Uint8Array|null} [commentCid] SetObjCommentPublicRequest commentCid
             * @property {Uint8Array|null} [signature] SetObjCommentPublicRequest signature
             * @property {Uint8Array|null} [vaccount] SetObjCommentPublicRequest vaccount
             */

            /**
             * Constructs a new SetObjCommentPublicRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a SetObjCommentPublicRequest.
             * @implements ISetObjCommentPublicRequest
             * @constructor
             * @param {dcnet.pb.ISetObjCommentPublicRequest=} [properties] Properties to set
             */
            function SetObjCommentPublicRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetObjCommentPublicRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @instance
             */
            SetObjCommentPublicRequest.prototype.theme = $util.newBuffer([]);

            /**
             * SetObjCommentPublicRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @instance
             */
            SetObjCommentPublicRequest.prototype.appId = $util.newBuffer([]);

            /**
             * SetObjCommentPublicRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @instance
             */
            SetObjCommentPublicRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * SetObjCommentPublicRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @instance
             */
            SetObjCommentPublicRequest.prototype.blockheight = 0;

            /**
             * SetObjCommentPublicRequest commentBlockheight.
             * @member {number} commentBlockheight
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @instance
             */
            SetObjCommentPublicRequest.prototype.commentBlockheight = 0;

            /**
             * SetObjCommentPublicRequest commentCid.
             * @member {Uint8Array} commentCid
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @instance
             */
            SetObjCommentPublicRequest.prototype.commentCid = $util.newBuffer([]);

            /**
             * SetObjCommentPublicRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @instance
             */
            SetObjCommentPublicRequest.prototype.signature = $util.newBuffer([]);

            /**
             * SetObjCommentPublicRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @instance
             */
            SetObjCommentPublicRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new SetObjCommentPublicRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @static
             * @param {dcnet.pb.ISetObjCommentPublicRequest=} [properties] Properties to set
             * @returns {dcnet.pb.SetObjCommentPublicRequest} SetObjCommentPublicRequest instance
             */
            SetObjCommentPublicRequest.create = function create(properties) {
                return new SetObjCommentPublicRequest(properties);
            };

            /**
             * Encodes the specified SetObjCommentPublicRequest message. Does not implicitly {@link dcnet.pb.SetObjCommentPublicRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @static
             * @param {dcnet.pb.ISetObjCommentPublicRequest} message SetObjCommentPublicRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetObjCommentPublicRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockheight);
                if (message.commentBlockheight != null && Object.hasOwnProperty.call(message, "commentBlockheight"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.commentBlockheight);
                if (message.commentCid != null && Object.hasOwnProperty.call(message, "commentCid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.commentCid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified SetObjCommentPublicRequest message, length delimited. Does not implicitly {@link dcnet.pb.SetObjCommentPublicRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @static
             * @param {dcnet.pb.ISetObjCommentPublicRequest} message SetObjCommentPublicRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetObjCommentPublicRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetObjCommentPublicRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SetObjCommentPublicRequest} SetObjCommentPublicRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetObjCommentPublicRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SetObjCommentPublicRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.commentBlockheight = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.commentCid = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetObjCommentPublicRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SetObjCommentPublicRequest} SetObjCommentPublicRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetObjCommentPublicRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetObjCommentPublicRequest message.
             * @function verify
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetObjCommentPublicRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.commentBlockheight != null && message.hasOwnProperty("commentBlockheight"))
                    if (!$util.isInteger(message.commentBlockheight))
                        return "commentBlockheight: integer expected";
                if (message.commentCid != null && message.hasOwnProperty("commentCid"))
                    if (!(message.commentCid && typeof message.commentCid.length === "number" || $util.isString(message.commentCid)))
                        return "commentCid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a SetObjCommentPublicRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SetObjCommentPublicRequest} SetObjCommentPublicRequest
             */
            SetObjCommentPublicRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SetObjCommentPublicRequest)
                    return object;
                let message = new $root.dcnet.pb.SetObjCommentPublicRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.commentBlockheight != null)
                    message.commentBlockheight = object.commentBlockheight >>> 0;
                if (object.commentCid != null)
                    if (typeof object.commentCid === "string")
                        $util.base64.decode(object.commentCid, message.commentCid = $util.newBuffer($util.base64.length(object.commentCid)), 0);
                    else if (object.commentCid.length >= 0)
                        message.commentCid = object.commentCid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a SetObjCommentPublicRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @static
             * @param {dcnet.pb.SetObjCommentPublicRequest} message SetObjCommentPublicRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetObjCommentPublicRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.blockheight = 0;
                    object.commentBlockheight = 0;
                    if (options.bytes === String)
                        object.commentCid = "";
                    else {
                        object.commentCid = [];
                        if (options.bytes !== Array)
                            object.commentCid = $util.newBuffer(object.commentCid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.commentBlockheight != null && message.hasOwnProperty("commentBlockheight"))
                    object.commentBlockheight = message.commentBlockheight;
                if (message.commentCid != null && message.hasOwnProperty("commentCid"))
                    object.commentCid = options.bytes === String ? $util.base64.encode(message.commentCid, 0, message.commentCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.commentCid) : message.commentCid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this SetObjCommentPublicRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetObjCommentPublicRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetObjCommentPublicRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.SetObjCommentPublicRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetObjCommentPublicRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SetObjCommentPublicRequest";
            };

            return SetObjCommentPublicRequest;
        })();

        pb.SetObjCommentPublicReply = (function() {

            /**
             * Properties of a SetObjCommentPublicReply.
             * @memberof dcnet.pb
             * @interface ISetObjCommentPublicReply
             * @property {number|null} [flag] SetObjCommentPublicReply flag
             */

            /**
             * Constructs a new SetObjCommentPublicReply.
             * @memberof dcnet.pb
             * @classdesc Represents a SetObjCommentPublicReply.
             * @implements ISetObjCommentPublicReply
             * @constructor
             * @param {dcnet.pb.ISetObjCommentPublicReply=} [properties] Properties to set
             */
            function SetObjCommentPublicReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetObjCommentPublicReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.SetObjCommentPublicReply
             * @instance
             */
            SetObjCommentPublicReply.prototype.flag = 0;

            /**
             * Creates a new SetObjCommentPublicReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SetObjCommentPublicReply
             * @static
             * @param {dcnet.pb.ISetObjCommentPublicReply=} [properties] Properties to set
             * @returns {dcnet.pb.SetObjCommentPublicReply} SetObjCommentPublicReply instance
             */
            SetObjCommentPublicReply.create = function create(properties) {
                return new SetObjCommentPublicReply(properties);
            };

            /**
             * Encodes the specified SetObjCommentPublicReply message. Does not implicitly {@link dcnet.pb.SetObjCommentPublicReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SetObjCommentPublicReply
             * @static
             * @param {dcnet.pb.ISetObjCommentPublicReply} message SetObjCommentPublicReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetObjCommentPublicReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified SetObjCommentPublicReply message, length delimited. Does not implicitly {@link dcnet.pb.SetObjCommentPublicReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SetObjCommentPublicReply
             * @static
             * @param {dcnet.pb.ISetObjCommentPublicReply} message SetObjCommentPublicReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetObjCommentPublicReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetObjCommentPublicReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SetObjCommentPublicReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SetObjCommentPublicReply} SetObjCommentPublicReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetObjCommentPublicReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SetObjCommentPublicReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetObjCommentPublicReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SetObjCommentPublicReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SetObjCommentPublicReply} SetObjCommentPublicReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetObjCommentPublicReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetObjCommentPublicReply message.
             * @function verify
             * @memberof dcnet.pb.SetObjCommentPublicReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetObjCommentPublicReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a SetObjCommentPublicReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SetObjCommentPublicReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SetObjCommentPublicReply} SetObjCommentPublicReply
             */
            SetObjCommentPublicReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SetObjCommentPublicReply)
                    return object;
                let message = new $root.dcnet.pb.SetObjCommentPublicReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SetObjCommentPublicReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SetObjCommentPublicReply
             * @static
             * @param {dcnet.pb.SetObjCommentPublicReply} message SetObjCommentPublicReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetObjCommentPublicReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this SetObjCommentPublicReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SetObjCommentPublicReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetObjCommentPublicReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetObjCommentPublicReply
             * @function getTypeUrl
             * @memberof dcnet.pb.SetObjCommentPublicReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetObjCommentPublicReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SetObjCommentPublicReply";
            };

            return SetObjCommentPublicReply;
        })();

        pb.DeleteSelfCommentRequest = (function() {

            /**
             * Properties of a DeleteSelfCommentRequest.
             * @memberof dcnet.pb
             * @interface IDeleteSelfCommentRequest
             * @property {Uint8Array|null} [theme] DeleteSelfCommentRequest theme
             * @property {Uint8Array|null} [appId] DeleteSelfCommentRequest appId
             * @property {Uint8Array|null} [userPubkey] DeleteSelfCommentRequest userPubkey
             * @property {Uint8Array|null} [themeAuthor] DeleteSelfCommentRequest themeAuthor
             * @property {number|null} [blockheight] DeleteSelfCommentRequest blockheight
             * @property {number|null} [commentBlockheight] DeleteSelfCommentRequest commentBlockheight
             * @property {Uint8Array|null} [commentCid] DeleteSelfCommentRequest commentCid
             * @property {Uint8Array|null} [signature] DeleteSelfCommentRequest signature
             * @property {Uint8Array|null} [vaccount] DeleteSelfCommentRequest vaccount
             */

            /**
             * Constructs a new DeleteSelfCommentRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteSelfCommentRequest.
             * @implements IDeleteSelfCommentRequest
             * @constructor
             * @param {dcnet.pb.IDeleteSelfCommentRequest=} [properties] Properties to set
             */
            function DeleteSelfCommentRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteSelfCommentRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @instance
             */
            DeleteSelfCommentRequest.prototype.theme = $util.newBuffer([]);

            /**
             * DeleteSelfCommentRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @instance
             */
            DeleteSelfCommentRequest.prototype.appId = $util.newBuffer([]);

            /**
             * DeleteSelfCommentRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @instance
             */
            DeleteSelfCommentRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * DeleteSelfCommentRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @instance
             */
            DeleteSelfCommentRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * DeleteSelfCommentRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @instance
             */
            DeleteSelfCommentRequest.prototype.blockheight = 0;

            /**
             * DeleteSelfCommentRequest commentBlockheight.
             * @member {number} commentBlockheight
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @instance
             */
            DeleteSelfCommentRequest.prototype.commentBlockheight = 0;

            /**
             * DeleteSelfCommentRequest commentCid.
             * @member {Uint8Array} commentCid
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @instance
             */
            DeleteSelfCommentRequest.prototype.commentCid = $util.newBuffer([]);

            /**
             * DeleteSelfCommentRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @instance
             */
            DeleteSelfCommentRequest.prototype.signature = $util.newBuffer([]);

            /**
             * DeleteSelfCommentRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @instance
             */
            DeleteSelfCommentRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new DeleteSelfCommentRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @static
             * @param {dcnet.pb.IDeleteSelfCommentRequest=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteSelfCommentRequest} DeleteSelfCommentRequest instance
             */
            DeleteSelfCommentRequest.create = function create(properties) {
                return new DeleteSelfCommentRequest(properties);
            };

            /**
             * Encodes the specified DeleteSelfCommentRequest message. Does not implicitly {@link dcnet.pb.DeleteSelfCommentRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @static
             * @param {dcnet.pb.IDeleteSelfCommentRequest} message DeleteSelfCommentRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSelfCommentRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.userPubkey);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.themeAuthor);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.blockheight);
                if (message.commentBlockheight != null && Object.hasOwnProperty.call(message, "commentBlockheight"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.commentBlockheight);
                if (message.commentCid != null && Object.hasOwnProperty.call(message, "commentCid"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.commentCid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified DeleteSelfCommentRequest message, length delimited. Does not implicitly {@link dcnet.pb.DeleteSelfCommentRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @static
             * @param {dcnet.pb.IDeleteSelfCommentRequest} message DeleteSelfCommentRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSelfCommentRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteSelfCommentRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteSelfCommentRequest} DeleteSelfCommentRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSelfCommentRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteSelfCommentRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.commentBlockheight = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.commentCid = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 9: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteSelfCommentRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteSelfCommentRequest} DeleteSelfCommentRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSelfCommentRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteSelfCommentRequest message.
             * @function verify
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteSelfCommentRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.commentBlockheight != null && message.hasOwnProperty("commentBlockheight"))
                    if (!$util.isInteger(message.commentBlockheight))
                        return "commentBlockheight: integer expected";
                if (message.commentCid != null && message.hasOwnProperty("commentCid"))
                    if (!(message.commentCid && typeof message.commentCid.length === "number" || $util.isString(message.commentCid)))
                        return "commentCid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a DeleteSelfCommentRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteSelfCommentRequest} DeleteSelfCommentRequest
             */
            DeleteSelfCommentRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteSelfCommentRequest)
                    return object;
                let message = new $root.dcnet.pb.DeleteSelfCommentRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.commentBlockheight != null)
                    message.commentBlockheight = object.commentBlockheight >>> 0;
                if (object.commentCid != null)
                    if (typeof object.commentCid === "string")
                        $util.base64.decode(object.commentCid, message.commentCid = $util.newBuffer($util.base64.length(object.commentCid)), 0);
                    else if (object.commentCid.length >= 0)
                        message.commentCid = object.commentCid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a DeleteSelfCommentRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @static
             * @param {dcnet.pb.DeleteSelfCommentRequest} message DeleteSelfCommentRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteSelfCommentRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.blockheight = 0;
                    object.commentBlockheight = 0;
                    if (options.bytes === String)
                        object.commentCid = "";
                    else {
                        object.commentCid = [];
                        if (options.bytes !== Array)
                            object.commentCid = $util.newBuffer(object.commentCid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.commentBlockheight != null && message.hasOwnProperty("commentBlockheight"))
                    object.commentBlockheight = message.commentBlockheight;
                if (message.commentCid != null && message.hasOwnProperty("commentCid"))
                    object.commentCid = options.bytes === String ? $util.base64.encode(message.commentCid, 0, message.commentCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.commentCid) : message.commentCid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this DeleteSelfCommentRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteSelfCommentRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteSelfCommentRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteSelfCommentRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteSelfCommentRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteSelfCommentRequest";
            };

            return DeleteSelfCommentRequest;
        })();

        pb.DeleteSelfCommentReply = (function() {

            /**
             * Properties of a DeleteSelfCommentReply.
             * @memberof dcnet.pb
             * @interface IDeleteSelfCommentReply
             * @property {number|null} [flag] DeleteSelfCommentReply flag
             */

            /**
             * Constructs a new DeleteSelfCommentReply.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteSelfCommentReply.
             * @implements IDeleteSelfCommentReply
             * @constructor
             * @param {dcnet.pb.IDeleteSelfCommentReply=} [properties] Properties to set
             */
            function DeleteSelfCommentReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteSelfCommentReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.DeleteSelfCommentReply
             * @instance
             */
            DeleteSelfCommentReply.prototype.flag = 0;

            /**
             * Creates a new DeleteSelfCommentReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteSelfCommentReply
             * @static
             * @param {dcnet.pb.IDeleteSelfCommentReply=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteSelfCommentReply} DeleteSelfCommentReply instance
             */
            DeleteSelfCommentReply.create = function create(properties) {
                return new DeleteSelfCommentReply(properties);
            };

            /**
             * Encodes the specified DeleteSelfCommentReply message. Does not implicitly {@link dcnet.pb.DeleteSelfCommentReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteSelfCommentReply
             * @static
             * @param {dcnet.pb.IDeleteSelfCommentReply} message DeleteSelfCommentReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSelfCommentReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified DeleteSelfCommentReply message, length delimited. Does not implicitly {@link dcnet.pb.DeleteSelfCommentReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteSelfCommentReply
             * @static
             * @param {dcnet.pb.IDeleteSelfCommentReply} message DeleteSelfCommentReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSelfCommentReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteSelfCommentReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteSelfCommentReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteSelfCommentReply} DeleteSelfCommentReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSelfCommentReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteSelfCommentReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteSelfCommentReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteSelfCommentReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteSelfCommentReply} DeleteSelfCommentReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSelfCommentReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteSelfCommentReply message.
             * @function verify
             * @memberof dcnet.pb.DeleteSelfCommentReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteSelfCommentReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a DeleteSelfCommentReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteSelfCommentReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteSelfCommentReply} DeleteSelfCommentReply
             */
            DeleteSelfCommentReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteSelfCommentReply)
                    return object;
                let message = new $root.dcnet.pb.DeleteSelfCommentReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DeleteSelfCommentReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteSelfCommentReply
             * @static
             * @param {dcnet.pb.DeleteSelfCommentReply} message DeleteSelfCommentReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteSelfCommentReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this DeleteSelfCommentReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteSelfCommentReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteSelfCommentReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteSelfCommentReply
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteSelfCommentReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteSelfCommentReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteSelfCommentReply";
            };

            return DeleteSelfCommentReply;
        })();

        pb.DeleteCommentToObjRequest = (function() {

            /**
             * Properties of a DeleteCommentToObjRequest.
             * @memberof dcnet.pb
             * @interface IDeleteCommentToObjRequest
             * @property {Uint8Array|null} [theme] DeleteCommentToObjRequest theme
             * @property {Uint8Array|null} [appId] DeleteCommentToObjRequest appId
             * @property {Uint8Array|null} [userPubkey] DeleteCommentToObjRequest userPubkey
             * @property {Uint8Array|null} [themeAuthor] DeleteCommentToObjRequest themeAuthor
             * @property {number|null} [blockheight] DeleteCommentToObjRequest blockheight
             * @property {number|null} [commentBlockheight] DeleteCommentToObjRequest commentBlockheight
             * @property {Uint8Array|null} [commentCid] DeleteCommentToObjRequest commentCid
             * @property {Uint8Array|null} [signature] DeleteCommentToObjRequest signature
             * @property {Uint8Array|null} [vaccount] DeleteCommentToObjRequest vaccount
             */

            /**
             * Constructs a new DeleteCommentToObjRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteCommentToObjRequest.
             * @implements IDeleteCommentToObjRequest
             * @constructor
             * @param {dcnet.pb.IDeleteCommentToObjRequest=} [properties] Properties to set
             */
            function DeleteCommentToObjRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteCommentToObjRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @instance
             */
            DeleteCommentToObjRequest.prototype.theme = $util.newBuffer([]);

            /**
             * DeleteCommentToObjRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @instance
             */
            DeleteCommentToObjRequest.prototype.appId = $util.newBuffer([]);

            /**
             * DeleteCommentToObjRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @instance
             */
            DeleteCommentToObjRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * DeleteCommentToObjRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @instance
             */
            DeleteCommentToObjRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * DeleteCommentToObjRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @instance
             */
            DeleteCommentToObjRequest.prototype.blockheight = 0;

            /**
             * DeleteCommentToObjRequest commentBlockheight.
             * @member {number} commentBlockheight
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @instance
             */
            DeleteCommentToObjRequest.prototype.commentBlockheight = 0;

            /**
             * DeleteCommentToObjRequest commentCid.
             * @member {Uint8Array} commentCid
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @instance
             */
            DeleteCommentToObjRequest.prototype.commentCid = $util.newBuffer([]);

            /**
             * DeleteCommentToObjRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @instance
             */
            DeleteCommentToObjRequest.prototype.signature = $util.newBuffer([]);

            /**
             * DeleteCommentToObjRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @instance
             */
            DeleteCommentToObjRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new DeleteCommentToObjRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @static
             * @param {dcnet.pb.IDeleteCommentToObjRequest=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteCommentToObjRequest} DeleteCommentToObjRequest instance
             */
            DeleteCommentToObjRequest.create = function create(properties) {
                return new DeleteCommentToObjRequest(properties);
            };

            /**
             * Encodes the specified DeleteCommentToObjRequest message. Does not implicitly {@link dcnet.pb.DeleteCommentToObjRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @static
             * @param {dcnet.pb.IDeleteCommentToObjRequest} message DeleteCommentToObjRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteCommentToObjRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.userPubkey);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.themeAuthor);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.blockheight);
                if (message.commentBlockheight != null && Object.hasOwnProperty.call(message, "commentBlockheight"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.commentBlockheight);
                if (message.commentCid != null && Object.hasOwnProperty.call(message, "commentCid"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.commentCid);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified DeleteCommentToObjRequest message, length delimited. Does not implicitly {@link dcnet.pb.DeleteCommentToObjRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @static
             * @param {dcnet.pb.IDeleteCommentToObjRequest} message DeleteCommentToObjRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteCommentToObjRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteCommentToObjRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteCommentToObjRequest} DeleteCommentToObjRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteCommentToObjRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteCommentToObjRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.commentBlockheight = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.commentCid = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 9: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteCommentToObjRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteCommentToObjRequest} DeleteCommentToObjRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteCommentToObjRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteCommentToObjRequest message.
             * @function verify
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteCommentToObjRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.commentBlockheight != null && message.hasOwnProperty("commentBlockheight"))
                    if (!$util.isInteger(message.commentBlockheight))
                        return "commentBlockheight: integer expected";
                if (message.commentCid != null && message.hasOwnProperty("commentCid"))
                    if (!(message.commentCid && typeof message.commentCid.length === "number" || $util.isString(message.commentCid)))
                        return "commentCid: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a DeleteCommentToObjRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteCommentToObjRequest} DeleteCommentToObjRequest
             */
            DeleteCommentToObjRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteCommentToObjRequest)
                    return object;
                let message = new $root.dcnet.pb.DeleteCommentToObjRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.commentBlockheight != null)
                    message.commentBlockheight = object.commentBlockheight >>> 0;
                if (object.commentCid != null)
                    if (typeof object.commentCid === "string")
                        $util.base64.decode(object.commentCid, message.commentCid = $util.newBuffer($util.base64.length(object.commentCid)), 0);
                    else if (object.commentCid.length >= 0)
                        message.commentCid = object.commentCid;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a DeleteCommentToObjRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @static
             * @param {dcnet.pb.DeleteCommentToObjRequest} message DeleteCommentToObjRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteCommentToObjRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.blockheight = 0;
                    object.commentBlockheight = 0;
                    if (options.bytes === String)
                        object.commentCid = "";
                    else {
                        object.commentCid = [];
                        if (options.bytes !== Array)
                            object.commentCid = $util.newBuffer(object.commentCid);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.commentBlockheight != null && message.hasOwnProperty("commentBlockheight"))
                    object.commentBlockheight = message.commentBlockheight;
                if (message.commentCid != null && message.hasOwnProperty("commentCid"))
                    object.commentCid = options.bytes === String ? $util.base64.encode(message.commentCid, 0, message.commentCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.commentCid) : message.commentCid;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this DeleteCommentToObjRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteCommentToObjRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteCommentToObjRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteCommentToObjRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteCommentToObjRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteCommentToObjRequest";
            };

            return DeleteCommentToObjRequest;
        })();

        pb.DeleteCommentToObjReply = (function() {

            /**
             * Properties of a DeleteCommentToObjReply.
             * @memberof dcnet.pb
             * @interface IDeleteCommentToObjReply
             * @property {number|null} [flag] DeleteCommentToObjReply flag
             */

            /**
             * Constructs a new DeleteCommentToObjReply.
             * @memberof dcnet.pb
             * @classdesc Represents a DeleteCommentToObjReply.
             * @implements IDeleteCommentToObjReply
             * @constructor
             * @param {dcnet.pb.IDeleteCommentToObjReply=} [properties] Properties to set
             */
            function DeleteCommentToObjReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteCommentToObjReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.DeleteCommentToObjReply
             * @instance
             */
            DeleteCommentToObjReply.prototype.flag = 0;

            /**
             * Creates a new DeleteCommentToObjReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeleteCommentToObjReply
             * @static
             * @param {dcnet.pb.IDeleteCommentToObjReply=} [properties] Properties to set
             * @returns {dcnet.pb.DeleteCommentToObjReply} DeleteCommentToObjReply instance
             */
            DeleteCommentToObjReply.create = function create(properties) {
                return new DeleteCommentToObjReply(properties);
            };

            /**
             * Encodes the specified DeleteCommentToObjReply message. Does not implicitly {@link dcnet.pb.DeleteCommentToObjReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeleteCommentToObjReply
             * @static
             * @param {dcnet.pb.IDeleteCommentToObjReply} message DeleteCommentToObjReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteCommentToObjReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified DeleteCommentToObjReply message, length delimited. Does not implicitly {@link dcnet.pb.DeleteCommentToObjReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeleteCommentToObjReply
             * @static
             * @param {dcnet.pb.IDeleteCommentToObjReply} message DeleteCommentToObjReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteCommentToObjReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteCommentToObjReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeleteCommentToObjReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeleteCommentToObjReply} DeleteCommentToObjReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteCommentToObjReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeleteCommentToObjReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteCommentToObjReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeleteCommentToObjReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeleteCommentToObjReply} DeleteCommentToObjReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteCommentToObjReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteCommentToObjReply message.
             * @function verify
             * @memberof dcnet.pb.DeleteCommentToObjReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteCommentToObjReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a DeleteCommentToObjReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeleteCommentToObjReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeleteCommentToObjReply} DeleteCommentToObjReply
             */
            DeleteCommentToObjReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeleteCommentToObjReply)
                    return object;
                let message = new $root.dcnet.pb.DeleteCommentToObjReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DeleteCommentToObjReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeleteCommentToObjReply
             * @static
             * @param {dcnet.pb.DeleteCommentToObjReply} message DeleteCommentToObjReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteCommentToObjReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this DeleteCommentToObjReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeleteCommentToObjReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteCommentToObjReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteCommentToObjReply
             * @function getTypeUrl
             * @memberof dcnet.pb.DeleteCommentToObjReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteCommentToObjReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeleteCommentToObjReply";
            };

            return DeleteCommentToObjReply;
        })();

        pb.GetThemeObjRequest = (function() {

            /**
             * Properties of a GetThemeObjRequest.
             * @memberof dcnet.pb
             * @interface IGetThemeObjRequest
             * @property {Uint8Array|null} [appId] GetThemeObjRequest appId
             * @property {Uint8Array|null} [themeAuthor] GetThemeObjRequest themeAuthor
             * @property {number|null} [startHeight] GetThemeObjRequest startHeight
             * @property {number|null} [direction] GetThemeObjRequest direction
             * @property {number|null} [offset] GetThemeObjRequest offset
             * @property {number|null} [limit] GetThemeObjRequest limit
             * @property {Uint8Array|null} [seekKey] GetThemeObjRequest seekKey
             * @property {Uint8Array|null} [vaccount] GetThemeObjRequest vaccount
             */

            /**
             * Constructs a new GetThemeObjRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThemeObjRequest.
             * @implements IGetThemeObjRequest
             * @constructor
             * @param {dcnet.pb.IGetThemeObjRequest=} [properties] Properties to set
             */
            function GetThemeObjRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThemeObjRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetThemeObjRequest
             * @instance
             */
            GetThemeObjRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetThemeObjRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetThemeObjRequest
             * @instance
             */
            GetThemeObjRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * GetThemeObjRequest startHeight.
             * @member {number} startHeight
             * @memberof dcnet.pb.GetThemeObjRequest
             * @instance
             */
            GetThemeObjRequest.prototype.startHeight = 0;

            /**
             * GetThemeObjRequest direction.
             * @member {number} direction
             * @memberof dcnet.pb.GetThemeObjRequest
             * @instance
             */
            GetThemeObjRequest.prototype.direction = 0;

            /**
             * GetThemeObjRequest offset.
             * @member {number} offset
             * @memberof dcnet.pb.GetThemeObjRequest
             * @instance
             */
            GetThemeObjRequest.prototype.offset = 0;

            /**
             * GetThemeObjRequest limit.
             * @member {number} limit
             * @memberof dcnet.pb.GetThemeObjRequest
             * @instance
             */
            GetThemeObjRequest.prototype.limit = 0;

            /**
             * GetThemeObjRequest seekKey.
             * @member {Uint8Array} seekKey
             * @memberof dcnet.pb.GetThemeObjRequest
             * @instance
             */
            GetThemeObjRequest.prototype.seekKey = $util.newBuffer([]);

            /**
             * GetThemeObjRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.GetThemeObjRequest
             * @instance
             */
            GetThemeObjRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new GetThemeObjRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThemeObjRequest
             * @static
             * @param {dcnet.pb.IGetThemeObjRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetThemeObjRequest} GetThemeObjRequest instance
             */
            GetThemeObjRequest.create = function create(properties) {
                return new GetThemeObjRequest(properties);
            };

            /**
             * Encodes the specified GetThemeObjRequest message. Does not implicitly {@link dcnet.pb.GetThemeObjRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThemeObjRequest
             * @static
             * @param {dcnet.pb.IGetThemeObjRequest} message GetThemeObjRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeObjRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.themeAuthor);
                if (message.startHeight != null && Object.hasOwnProperty.call(message, "startHeight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.startHeight);
                if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.direction);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.offset);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.limit);
                if (message.seekKey != null && Object.hasOwnProperty.call(message, "seekKey"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.seekKey);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified GetThemeObjRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetThemeObjRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThemeObjRequest
             * @static
             * @param {dcnet.pb.IGetThemeObjRequest} message GetThemeObjRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeObjRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThemeObjRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThemeObjRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThemeObjRequest} GetThemeObjRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeObjRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThemeObjRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.startHeight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.direction = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.offset = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.limit = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.seekKey = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThemeObjRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThemeObjRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThemeObjRequest} GetThemeObjRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeObjRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThemeObjRequest message.
             * @function verify
             * @memberof dcnet.pb.GetThemeObjRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThemeObjRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    if (!$util.isInteger(message.startHeight))
                        return "startHeight: integer expected";
                if (message.direction != null && message.hasOwnProperty("direction"))
                    if (!$util.isInteger(message.direction))
                        return "direction: integer expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset))
                        return "offset: integer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    if (!(message.seekKey && typeof message.seekKey.length === "number" || $util.isString(message.seekKey)))
                        return "seekKey: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a GetThemeObjRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThemeObjRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThemeObjRequest} GetThemeObjRequest
             */
            GetThemeObjRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThemeObjRequest)
                    return object;
                let message = new $root.dcnet.pb.GetThemeObjRequest();
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.startHeight != null)
                    message.startHeight = object.startHeight >>> 0;
                if (object.direction != null)
                    message.direction = object.direction >>> 0;
                if (object.offset != null)
                    message.offset = object.offset >>> 0;
                if (object.limit != null)
                    message.limit = object.limit >>> 0;
                if (object.seekKey != null)
                    if (typeof object.seekKey === "string")
                        $util.base64.decode(object.seekKey, message.seekKey = $util.newBuffer($util.base64.length(object.seekKey)), 0);
                    else if (object.seekKey.length >= 0)
                        message.seekKey = object.seekKey;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a GetThemeObjRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThemeObjRequest
             * @static
             * @param {dcnet.pb.GetThemeObjRequest} message GetThemeObjRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThemeObjRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.startHeight = 0;
                    object.direction = 0;
                    object.offset = 0;
                    object.limit = 0;
                    if (options.bytes === String)
                        object.seekKey = "";
                    else {
                        object.seekKey = [];
                        if (options.bytes !== Array)
                            object.seekKey = $util.newBuffer(object.seekKey);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    object.startHeight = message.startHeight;
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = message.direction;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    object.seekKey = options.bytes === String ? $util.base64.encode(message.seekKey, 0, message.seekKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.seekKey) : message.seekKey;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this GetThemeObjRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThemeObjRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThemeObjRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThemeObjRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThemeObjRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThemeObjRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThemeObjRequest";
            };

            return GetThemeObjRequest;
        })();

        pb.GetThemeObjReply = (function() {

            /**
             * Properties of a GetThemeObjReply.
             * @memberof dcnet.pb
             * @interface IGetThemeObjReply
             * @property {number|null} [flag] GetThemeObjReply flag
             * @property {Uint8Array|null} [objsCid] GetThemeObjReply objsCid
             */

            /**
             * Constructs a new GetThemeObjReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThemeObjReply.
             * @implements IGetThemeObjReply
             * @constructor
             * @param {dcnet.pb.IGetThemeObjReply=} [properties] Properties to set
             */
            function GetThemeObjReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThemeObjReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetThemeObjReply
             * @instance
             */
            GetThemeObjReply.prototype.flag = 0;

            /**
             * GetThemeObjReply objsCid.
             * @member {Uint8Array} objsCid
             * @memberof dcnet.pb.GetThemeObjReply
             * @instance
             */
            GetThemeObjReply.prototype.objsCid = $util.newBuffer([]);

            /**
             * Creates a new GetThemeObjReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThemeObjReply
             * @static
             * @param {dcnet.pb.IGetThemeObjReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetThemeObjReply} GetThemeObjReply instance
             */
            GetThemeObjReply.create = function create(properties) {
                return new GetThemeObjReply(properties);
            };

            /**
             * Encodes the specified GetThemeObjReply message. Does not implicitly {@link dcnet.pb.GetThemeObjReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThemeObjReply
             * @static
             * @param {dcnet.pb.IGetThemeObjReply} message GetThemeObjReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeObjReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.objsCid != null && Object.hasOwnProperty.call(message, "objsCid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.objsCid);
                return writer;
            };

            /**
             * Encodes the specified GetThemeObjReply message, length delimited. Does not implicitly {@link dcnet.pb.GetThemeObjReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThemeObjReply
             * @static
             * @param {dcnet.pb.IGetThemeObjReply} message GetThemeObjReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeObjReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThemeObjReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThemeObjReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThemeObjReply} GetThemeObjReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeObjReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThemeObjReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.objsCid = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThemeObjReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThemeObjReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThemeObjReply} GetThemeObjReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeObjReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThemeObjReply message.
             * @function verify
             * @memberof dcnet.pb.GetThemeObjReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThemeObjReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.objsCid != null && message.hasOwnProperty("objsCid"))
                    if (!(message.objsCid && typeof message.objsCid.length === "number" || $util.isString(message.objsCid)))
                        return "objsCid: buffer expected";
                return null;
            };

            /**
             * Creates a GetThemeObjReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThemeObjReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThemeObjReply} GetThemeObjReply
             */
            GetThemeObjReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThemeObjReply)
                    return object;
                let message = new $root.dcnet.pb.GetThemeObjReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.objsCid != null)
                    if (typeof object.objsCid === "string")
                        $util.base64.decode(object.objsCid, message.objsCid = $util.newBuffer($util.base64.length(object.objsCid)), 0);
                    else if (object.objsCid.length >= 0)
                        message.objsCid = object.objsCid;
                return message;
            };

            /**
             * Creates a plain object from a GetThemeObjReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThemeObjReply
             * @static
             * @param {dcnet.pb.GetThemeObjReply} message GetThemeObjReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThemeObjReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.objsCid = "";
                    else {
                        object.objsCid = [];
                        if (options.bytes !== Array)
                            object.objsCid = $util.newBuffer(object.objsCid);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.objsCid != null && message.hasOwnProperty("objsCid"))
                    object.objsCid = options.bytes === String ? $util.base64.encode(message.objsCid, 0, message.objsCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.objsCid) : message.objsCid;
                return object;
            };

            /**
             * Converts this GetThemeObjReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThemeObjReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThemeObjReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThemeObjReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThemeObjReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThemeObjReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThemeObjReply";
            };

            return GetThemeObjReply;
        })();

        pb.SyncThemeObjRequest = (function() {

            /**
             * Properties of a SyncThemeObjRequest.
             * @memberof dcnet.pb
             * @interface ISyncThemeObjRequest
             * @property {Uint8Array|null} [appId] SyncThemeObjRequest appId
             * @property {Uint8Array|null} [themeAuthor] SyncThemeObjRequest themeAuthor
             * @property {Uint8Array|null} [theme] SyncThemeObjRequest theme
             */

            /**
             * Constructs a new SyncThemeObjRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a SyncThemeObjRequest.
             * @implements ISyncThemeObjRequest
             * @constructor
             * @param {dcnet.pb.ISyncThemeObjRequest=} [properties] Properties to set
             */
            function SyncThemeObjRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SyncThemeObjRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @instance
             */
            SyncThemeObjRequest.prototype.appId = $util.newBuffer([]);

            /**
             * SyncThemeObjRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @instance
             */
            SyncThemeObjRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * SyncThemeObjRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @instance
             */
            SyncThemeObjRequest.prototype.theme = $util.newBuffer([]);

            /**
             * Creates a new SyncThemeObjRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @static
             * @param {dcnet.pb.ISyncThemeObjRequest=} [properties] Properties to set
             * @returns {dcnet.pb.SyncThemeObjRequest} SyncThemeObjRequest instance
             */
            SyncThemeObjRequest.create = function create(properties) {
                return new SyncThemeObjRequest(properties);
            };

            /**
             * Encodes the specified SyncThemeObjRequest message. Does not implicitly {@link dcnet.pb.SyncThemeObjRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @static
             * @param {dcnet.pb.ISyncThemeObjRequest} message SyncThemeObjRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SyncThemeObjRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.themeAuthor);
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.theme);
                return writer;
            };

            /**
             * Encodes the specified SyncThemeObjRequest message, length delimited. Does not implicitly {@link dcnet.pb.SyncThemeObjRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @static
             * @param {dcnet.pb.ISyncThemeObjRequest} message SyncThemeObjRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SyncThemeObjRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SyncThemeObjRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SyncThemeObjRequest} SyncThemeObjRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SyncThemeObjRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SyncThemeObjRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.theme = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SyncThemeObjRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SyncThemeObjRequest} SyncThemeObjRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SyncThemeObjRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SyncThemeObjRequest message.
             * @function verify
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SyncThemeObjRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                return null;
            };

            /**
             * Creates a SyncThemeObjRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SyncThemeObjRequest} SyncThemeObjRequest
             */
            SyncThemeObjRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SyncThemeObjRequest)
                    return object;
                let message = new $root.dcnet.pb.SyncThemeObjRequest();
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                return message;
            };

            /**
             * Creates a plain object from a SyncThemeObjRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @static
             * @param {dcnet.pb.SyncThemeObjRequest} message SyncThemeObjRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SyncThemeObjRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                }
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                return object;
            };

            /**
             * Converts this SyncThemeObjRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SyncThemeObjRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SyncThemeObjRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.SyncThemeObjRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SyncThemeObjRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SyncThemeObjRequest";
            };

            return SyncThemeObjRequest;
        })();

        pb.SyncThemeObjReply = (function() {

            /**
             * Properties of a SyncThemeObjReply.
             * @memberof dcnet.pb
             * @interface ISyncThemeObjReply
             * @property {number|null} [flag] SyncThemeObjReply flag
             * @property {Uint8Array|null} [addThemReqRawData] SyncThemeObjReply addThemReqRawData
             */

            /**
             * Constructs a new SyncThemeObjReply.
             * @memberof dcnet.pb
             * @classdesc Represents a SyncThemeObjReply.
             * @implements ISyncThemeObjReply
             * @constructor
             * @param {dcnet.pb.ISyncThemeObjReply=} [properties] Properties to set
             */
            function SyncThemeObjReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SyncThemeObjReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.SyncThemeObjReply
             * @instance
             */
            SyncThemeObjReply.prototype.flag = 0;

            /**
             * SyncThemeObjReply addThemReqRawData.
             * @member {Uint8Array} addThemReqRawData
             * @memberof dcnet.pb.SyncThemeObjReply
             * @instance
             */
            SyncThemeObjReply.prototype.addThemReqRawData = $util.newBuffer([]);

            /**
             * Creates a new SyncThemeObjReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.SyncThemeObjReply
             * @static
             * @param {dcnet.pb.ISyncThemeObjReply=} [properties] Properties to set
             * @returns {dcnet.pb.SyncThemeObjReply} SyncThemeObjReply instance
             */
            SyncThemeObjReply.create = function create(properties) {
                return new SyncThemeObjReply(properties);
            };

            /**
             * Encodes the specified SyncThemeObjReply message. Does not implicitly {@link dcnet.pb.SyncThemeObjReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.SyncThemeObjReply
             * @static
             * @param {dcnet.pb.ISyncThemeObjReply} message SyncThemeObjReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SyncThemeObjReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.addThemReqRawData != null && Object.hasOwnProperty.call(message, "addThemReqRawData"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.addThemReqRawData);
                return writer;
            };

            /**
             * Encodes the specified SyncThemeObjReply message, length delimited. Does not implicitly {@link dcnet.pb.SyncThemeObjReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.SyncThemeObjReply
             * @static
             * @param {dcnet.pb.ISyncThemeObjReply} message SyncThemeObjReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SyncThemeObjReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SyncThemeObjReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.SyncThemeObjReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.SyncThemeObjReply} SyncThemeObjReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SyncThemeObjReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.SyncThemeObjReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.addThemReqRawData = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SyncThemeObjReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.SyncThemeObjReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.SyncThemeObjReply} SyncThemeObjReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SyncThemeObjReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SyncThemeObjReply message.
             * @function verify
             * @memberof dcnet.pb.SyncThemeObjReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SyncThemeObjReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.addThemReqRawData != null && message.hasOwnProperty("addThemReqRawData"))
                    if (!(message.addThemReqRawData && typeof message.addThemReqRawData.length === "number" || $util.isString(message.addThemReqRawData)))
                        return "addThemReqRawData: buffer expected";
                return null;
            };

            /**
             * Creates a SyncThemeObjReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.SyncThemeObjReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.SyncThemeObjReply} SyncThemeObjReply
             */
            SyncThemeObjReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.SyncThemeObjReply)
                    return object;
                let message = new $root.dcnet.pb.SyncThemeObjReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.addThemReqRawData != null)
                    if (typeof object.addThemReqRawData === "string")
                        $util.base64.decode(object.addThemReqRawData, message.addThemReqRawData = $util.newBuffer($util.base64.length(object.addThemReqRawData)), 0);
                    else if (object.addThemReqRawData.length >= 0)
                        message.addThemReqRawData = object.addThemReqRawData;
                return message;
            };

            /**
             * Creates a plain object from a SyncThemeObjReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.SyncThemeObjReply
             * @static
             * @param {dcnet.pb.SyncThemeObjReply} message SyncThemeObjReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SyncThemeObjReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.addThemReqRawData = "";
                    else {
                        object.addThemReqRawData = [];
                        if (options.bytes !== Array)
                            object.addThemReqRawData = $util.newBuffer(object.addThemReqRawData);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.addThemReqRawData != null && message.hasOwnProperty("addThemReqRawData"))
                    object.addThemReqRawData = options.bytes === String ? $util.base64.encode(message.addThemReqRawData, 0, message.addThemReqRawData.length) : options.bytes === Array ? Array.prototype.slice.call(message.addThemReqRawData) : message.addThemReqRawData;
                return object;
            };

            /**
             * Converts this SyncThemeObjReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.SyncThemeObjReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SyncThemeObjReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SyncThemeObjReply
             * @function getTypeUrl
             * @memberof dcnet.pb.SyncThemeObjReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SyncThemeObjReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.SyncThemeObjReply";
            };

            return SyncThemeObjReply;
        })();

        pb.GetThemeCommentsRequest = (function() {

            /**
             * Properties of a GetThemeCommentsRequest.
             * @memberof dcnet.pb
             * @interface IGetThemeCommentsRequest
             * @property {Uint8Array|null} [theme] GetThemeCommentsRequest theme
             * @property {Uint8Array|null} [appId] GetThemeCommentsRequest appId
             * @property {Uint8Array|null} [themeAuthor] GetThemeCommentsRequest themeAuthor
             * @property {number|null} [startHeight] GetThemeCommentsRequest startHeight
             * @property {number|null} [direction] GetThemeCommentsRequest direction
             * @property {number|null} [offset] GetThemeCommentsRequest offset
             * @property {number|null} [limit] GetThemeCommentsRequest limit
             * @property {Uint8Array|null} [seekKey] GetThemeCommentsRequest seekKey
             * @property {Uint8Array|null} [vaccount] GetThemeCommentsRequest vaccount
             */

            /**
             * Constructs a new GetThemeCommentsRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThemeCommentsRequest.
             * @implements IGetThemeCommentsRequest
             * @constructor
             * @param {dcnet.pb.IGetThemeCommentsRequest=} [properties] Properties to set
             */
            function GetThemeCommentsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThemeCommentsRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @instance
             */
            GetThemeCommentsRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetThemeCommentsRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @instance
             */
            GetThemeCommentsRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetThemeCommentsRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @instance
             */
            GetThemeCommentsRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * GetThemeCommentsRequest startHeight.
             * @member {number} startHeight
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @instance
             */
            GetThemeCommentsRequest.prototype.startHeight = 0;

            /**
             * GetThemeCommentsRequest direction.
             * @member {number} direction
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @instance
             */
            GetThemeCommentsRequest.prototype.direction = 0;

            /**
             * GetThemeCommentsRequest offset.
             * @member {number} offset
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @instance
             */
            GetThemeCommentsRequest.prototype.offset = 0;

            /**
             * GetThemeCommentsRequest limit.
             * @member {number} limit
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @instance
             */
            GetThemeCommentsRequest.prototype.limit = 0;

            /**
             * GetThemeCommentsRequest seekKey.
             * @member {Uint8Array} seekKey
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @instance
             */
            GetThemeCommentsRequest.prototype.seekKey = $util.newBuffer([]);

            /**
             * GetThemeCommentsRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @instance
             */
            GetThemeCommentsRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new GetThemeCommentsRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @static
             * @param {dcnet.pb.IGetThemeCommentsRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetThemeCommentsRequest} GetThemeCommentsRequest instance
             */
            GetThemeCommentsRequest.create = function create(properties) {
                return new GetThemeCommentsRequest(properties);
            };

            /**
             * Encodes the specified GetThemeCommentsRequest message. Does not implicitly {@link dcnet.pb.GetThemeCommentsRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @static
             * @param {dcnet.pb.IGetThemeCommentsRequest} message GetThemeCommentsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeCommentsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.startHeight != null && Object.hasOwnProperty.call(message, "startHeight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.startHeight);
                if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.direction);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.offset);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.limit);
                if (message.seekKey != null && Object.hasOwnProperty.call(message, "seekKey"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.seekKey);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified GetThemeCommentsRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetThemeCommentsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @static
             * @param {dcnet.pb.IGetThemeCommentsRequest} message GetThemeCommentsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeCommentsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThemeCommentsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThemeCommentsRequest} GetThemeCommentsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeCommentsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThemeCommentsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.startHeight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.direction = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.offset = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.limit = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.seekKey = reader.bytes();
                            break;
                        }
                    case 9: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThemeCommentsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThemeCommentsRequest} GetThemeCommentsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeCommentsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThemeCommentsRequest message.
             * @function verify
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThemeCommentsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    if (!$util.isInteger(message.startHeight))
                        return "startHeight: integer expected";
                if (message.direction != null && message.hasOwnProperty("direction"))
                    if (!$util.isInteger(message.direction))
                        return "direction: integer expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset))
                        return "offset: integer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    if (!(message.seekKey && typeof message.seekKey.length === "number" || $util.isString(message.seekKey)))
                        return "seekKey: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a GetThemeCommentsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThemeCommentsRequest} GetThemeCommentsRequest
             */
            GetThemeCommentsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThemeCommentsRequest)
                    return object;
                let message = new $root.dcnet.pb.GetThemeCommentsRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.startHeight != null)
                    message.startHeight = object.startHeight >>> 0;
                if (object.direction != null)
                    message.direction = object.direction >>> 0;
                if (object.offset != null)
                    message.offset = object.offset >>> 0;
                if (object.limit != null)
                    message.limit = object.limit >>> 0;
                if (object.seekKey != null)
                    if (typeof object.seekKey === "string")
                        $util.base64.decode(object.seekKey, message.seekKey = $util.newBuffer($util.base64.length(object.seekKey)), 0);
                    else if (object.seekKey.length >= 0)
                        message.seekKey = object.seekKey;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a GetThemeCommentsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @static
             * @param {dcnet.pb.GetThemeCommentsRequest} message GetThemeCommentsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThemeCommentsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.startHeight = 0;
                    object.direction = 0;
                    object.offset = 0;
                    object.limit = 0;
                    if (options.bytes === String)
                        object.seekKey = "";
                    else {
                        object.seekKey = [];
                        if (options.bytes !== Array)
                            object.seekKey = $util.newBuffer(object.seekKey);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    object.startHeight = message.startHeight;
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = message.direction;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    object.seekKey = options.bytes === String ? $util.base64.encode(message.seekKey, 0, message.seekKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.seekKey) : message.seekKey;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this GetThemeCommentsRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThemeCommentsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThemeCommentsRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThemeCommentsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThemeCommentsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThemeCommentsRequest";
            };

            return GetThemeCommentsRequest;
        })();

        pb.GetThemeCommentsReply = (function() {

            /**
             * Properties of a GetThemeCommentsReply.
             * @memberof dcnet.pb
             * @interface IGetThemeCommentsReply
             * @property {number|null} [flag] GetThemeCommentsReply flag
             * @property {Uint8Array|null} [commentsCid] GetThemeCommentsReply commentsCid
             */

            /**
             * Constructs a new GetThemeCommentsReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThemeCommentsReply.
             * @implements IGetThemeCommentsReply
             * @constructor
             * @param {dcnet.pb.IGetThemeCommentsReply=} [properties] Properties to set
             */
            function GetThemeCommentsReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThemeCommentsReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @instance
             */
            GetThemeCommentsReply.prototype.flag = 0;

            /**
             * GetThemeCommentsReply commentsCid.
             * @member {Uint8Array} commentsCid
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @instance
             */
            GetThemeCommentsReply.prototype.commentsCid = $util.newBuffer([]);

            /**
             * Creates a new GetThemeCommentsReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @static
             * @param {dcnet.pb.IGetThemeCommentsReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetThemeCommentsReply} GetThemeCommentsReply instance
             */
            GetThemeCommentsReply.create = function create(properties) {
                return new GetThemeCommentsReply(properties);
            };

            /**
             * Encodes the specified GetThemeCommentsReply message. Does not implicitly {@link dcnet.pb.GetThemeCommentsReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @static
             * @param {dcnet.pb.IGetThemeCommentsReply} message GetThemeCommentsReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeCommentsReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.commentsCid != null && Object.hasOwnProperty.call(message, "commentsCid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.commentsCid);
                return writer;
            };

            /**
             * Encodes the specified GetThemeCommentsReply message, length delimited. Does not implicitly {@link dcnet.pb.GetThemeCommentsReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @static
             * @param {dcnet.pb.IGetThemeCommentsReply} message GetThemeCommentsReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeCommentsReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThemeCommentsReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThemeCommentsReply} GetThemeCommentsReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeCommentsReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThemeCommentsReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.commentsCid = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThemeCommentsReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThemeCommentsReply} GetThemeCommentsReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeCommentsReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThemeCommentsReply message.
             * @function verify
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThemeCommentsReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.commentsCid != null && message.hasOwnProperty("commentsCid"))
                    if (!(message.commentsCid && typeof message.commentsCid.length === "number" || $util.isString(message.commentsCid)))
                        return "commentsCid: buffer expected";
                return null;
            };

            /**
             * Creates a GetThemeCommentsReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThemeCommentsReply} GetThemeCommentsReply
             */
            GetThemeCommentsReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThemeCommentsReply)
                    return object;
                let message = new $root.dcnet.pb.GetThemeCommentsReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.commentsCid != null)
                    if (typeof object.commentsCid === "string")
                        $util.base64.decode(object.commentsCid, message.commentsCid = $util.newBuffer($util.base64.length(object.commentsCid)), 0);
                    else if (object.commentsCid.length >= 0)
                        message.commentsCid = object.commentsCid;
                return message;
            };

            /**
             * Creates a plain object from a GetThemeCommentsReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @static
             * @param {dcnet.pb.GetThemeCommentsReply} message GetThemeCommentsReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThemeCommentsReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.commentsCid = "";
                    else {
                        object.commentsCid = [];
                        if (options.bytes !== Array)
                            object.commentsCid = $util.newBuffer(object.commentsCid);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.commentsCid != null && message.hasOwnProperty("commentsCid"))
                    object.commentsCid = options.bytes === String ? $util.base64.encode(message.commentsCid, 0, message.commentsCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.commentsCid) : message.commentsCid;
                return object;
            };

            /**
             * Converts this GetThemeCommentsReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThemeCommentsReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThemeCommentsReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThemeCommentsReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThemeCommentsReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThemeCommentsReply";
            };

            return GetThemeCommentsReply;
        })();

        pb.GetValuesWithIndexRequest = (function() {

            /**
             * Properties of a GetValuesWithIndexRequest.
             * @memberof dcnet.pb
             * @interface IGetValuesWithIndexRequest
             * @property {Uint8Array|null} [theme] GetValuesWithIndexRequest theme
             * @property {Uint8Array|null} [appId] GetValuesWithIndexRequest appId
             * @property {Uint8Array|null} [themeAuthor] GetValuesWithIndexRequest themeAuthor
             * @property {number|null} [startHeight] GetValuesWithIndexRequest startHeight
             * @property {number|null} [direction] GetValuesWithIndexRequest direction
             * @property {number|null} [offset] GetValuesWithIndexRequest offset
             * @property {number|null} [limit] GetValuesWithIndexRequest limit
             * @property {Uint8Array|null} [seekKey] GetValuesWithIndexRequest seekKey
             * @property {Uint8Array|null} [indexKey] GetValuesWithIndexRequest indexKey
             * @property {Uint8Array|null} [indexValue] GetValuesWithIndexRequest indexValue
             * @property {Uint8Array|null} [vaccount] GetValuesWithIndexRequest vaccount
             */

            /**
             * Constructs a new GetValuesWithIndexRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetValuesWithIndexRequest.
             * @implements IGetValuesWithIndexRequest
             * @constructor
             * @param {dcnet.pb.IGetValuesWithIndexRequest=} [properties] Properties to set
             */
            function GetValuesWithIndexRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetValuesWithIndexRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             */
            GetValuesWithIndexRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetValuesWithIndexRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             */
            GetValuesWithIndexRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetValuesWithIndexRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             */
            GetValuesWithIndexRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * GetValuesWithIndexRequest startHeight.
             * @member {number} startHeight
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             */
            GetValuesWithIndexRequest.prototype.startHeight = 0;

            /**
             * GetValuesWithIndexRequest direction.
             * @member {number} direction
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             */
            GetValuesWithIndexRequest.prototype.direction = 0;

            /**
             * GetValuesWithIndexRequest offset.
             * @member {number} offset
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             */
            GetValuesWithIndexRequest.prototype.offset = 0;

            /**
             * GetValuesWithIndexRequest limit.
             * @member {number} limit
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             */
            GetValuesWithIndexRequest.prototype.limit = 0;

            /**
             * GetValuesWithIndexRequest seekKey.
             * @member {Uint8Array} seekKey
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             */
            GetValuesWithIndexRequest.prototype.seekKey = $util.newBuffer([]);

            /**
             * GetValuesWithIndexRequest indexKey.
             * @member {Uint8Array} indexKey
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             */
            GetValuesWithIndexRequest.prototype.indexKey = $util.newBuffer([]);

            /**
             * GetValuesWithIndexRequest indexValue.
             * @member {Uint8Array} indexValue
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             */
            GetValuesWithIndexRequest.prototype.indexValue = $util.newBuffer([]);

            /**
             * GetValuesWithIndexRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             */
            GetValuesWithIndexRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new GetValuesWithIndexRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @static
             * @param {dcnet.pb.IGetValuesWithIndexRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetValuesWithIndexRequest} GetValuesWithIndexRequest instance
             */
            GetValuesWithIndexRequest.create = function create(properties) {
                return new GetValuesWithIndexRequest(properties);
            };

            /**
             * Encodes the specified GetValuesWithIndexRequest message. Does not implicitly {@link dcnet.pb.GetValuesWithIndexRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @static
             * @param {dcnet.pb.IGetValuesWithIndexRequest} message GetValuesWithIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValuesWithIndexRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.startHeight != null && Object.hasOwnProperty.call(message, "startHeight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.startHeight);
                if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.direction);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.offset);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.limit);
                if (message.seekKey != null && Object.hasOwnProperty.call(message, "seekKey"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.seekKey);
                if (message.indexKey != null && Object.hasOwnProperty.call(message, "indexKey"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.indexKey);
                if (message.indexValue != null && Object.hasOwnProperty.call(message, "indexValue"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.indexValue);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified GetValuesWithIndexRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetValuesWithIndexRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @static
             * @param {dcnet.pb.IGetValuesWithIndexRequest} message GetValuesWithIndexRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValuesWithIndexRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetValuesWithIndexRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetValuesWithIndexRequest} GetValuesWithIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValuesWithIndexRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetValuesWithIndexRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.startHeight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.direction = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.offset = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.limit = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.seekKey = reader.bytes();
                            break;
                        }
                    case 9: {
                            message.indexKey = reader.bytes();
                            break;
                        }
                    case 10: {
                            message.indexValue = reader.bytes();
                            break;
                        }
                    case 11: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetValuesWithIndexRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetValuesWithIndexRequest} GetValuesWithIndexRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValuesWithIndexRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetValuesWithIndexRequest message.
             * @function verify
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetValuesWithIndexRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    if (!$util.isInteger(message.startHeight))
                        return "startHeight: integer expected";
                if (message.direction != null && message.hasOwnProperty("direction"))
                    if (!$util.isInteger(message.direction))
                        return "direction: integer expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset))
                        return "offset: integer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    if (!(message.seekKey && typeof message.seekKey.length === "number" || $util.isString(message.seekKey)))
                        return "seekKey: buffer expected";
                if (message.indexKey != null && message.hasOwnProperty("indexKey"))
                    if (!(message.indexKey && typeof message.indexKey.length === "number" || $util.isString(message.indexKey)))
                        return "indexKey: buffer expected";
                if (message.indexValue != null && message.hasOwnProperty("indexValue"))
                    if (!(message.indexValue && typeof message.indexValue.length === "number" || $util.isString(message.indexValue)))
                        return "indexValue: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a GetValuesWithIndexRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetValuesWithIndexRequest} GetValuesWithIndexRequest
             */
            GetValuesWithIndexRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetValuesWithIndexRequest)
                    return object;
                let message = new $root.dcnet.pb.GetValuesWithIndexRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.startHeight != null)
                    message.startHeight = object.startHeight >>> 0;
                if (object.direction != null)
                    message.direction = object.direction >>> 0;
                if (object.offset != null)
                    message.offset = object.offset >>> 0;
                if (object.limit != null)
                    message.limit = object.limit >>> 0;
                if (object.seekKey != null)
                    if (typeof object.seekKey === "string")
                        $util.base64.decode(object.seekKey, message.seekKey = $util.newBuffer($util.base64.length(object.seekKey)), 0);
                    else if (object.seekKey.length >= 0)
                        message.seekKey = object.seekKey;
                if (object.indexKey != null)
                    if (typeof object.indexKey === "string")
                        $util.base64.decode(object.indexKey, message.indexKey = $util.newBuffer($util.base64.length(object.indexKey)), 0);
                    else if (object.indexKey.length >= 0)
                        message.indexKey = object.indexKey;
                if (object.indexValue != null)
                    if (typeof object.indexValue === "string")
                        $util.base64.decode(object.indexValue, message.indexValue = $util.newBuffer($util.base64.length(object.indexValue)), 0);
                    else if (object.indexValue.length >= 0)
                        message.indexValue = object.indexValue;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a GetValuesWithIndexRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @static
             * @param {dcnet.pb.GetValuesWithIndexRequest} message GetValuesWithIndexRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetValuesWithIndexRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.startHeight = 0;
                    object.direction = 0;
                    object.offset = 0;
                    object.limit = 0;
                    if (options.bytes === String)
                        object.seekKey = "";
                    else {
                        object.seekKey = [];
                        if (options.bytes !== Array)
                            object.seekKey = $util.newBuffer(object.seekKey);
                    }
                    if (options.bytes === String)
                        object.indexKey = "";
                    else {
                        object.indexKey = [];
                        if (options.bytes !== Array)
                            object.indexKey = $util.newBuffer(object.indexKey);
                    }
                    if (options.bytes === String)
                        object.indexValue = "";
                    else {
                        object.indexValue = [];
                        if (options.bytes !== Array)
                            object.indexValue = $util.newBuffer(object.indexValue);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    object.startHeight = message.startHeight;
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = message.direction;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    object.seekKey = options.bytes === String ? $util.base64.encode(message.seekKey, 0, message.seekKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.seekKey) : message.seekKey;
                if (message.indexKey != null && message.hasOwnProperty("indexKey"))
                    object.indexKey = options.bytes === String ? $util.base64.encode(message.indexKey, 0, message.indexKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.indexKey) : message.indexKey;
                if (message.indexValue != null && message.hasOwnProperty("indexValue"))
                    object.indexValue = options.bytes === String ? $util.base64.encode(message.indexValue, 0, message.indexValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.indexValue) : message.indexValue;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this GetValuesWithIndexRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetValuesWithIndexRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetValuesWithIndexRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetValuesWithIndexRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetValuesWithIndexRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetValuesWithIndexRequest";
            };

            return GetValuesWithIndexRequest;
        })();

        pb.GetValuesWithIndexReply = (function() {

            /**
             * Properties of a GetValuesWithIndexReply.
             * @memberof dcnet.pb
             * @interface IGetValuesWithIndexReply
             * @property {number|null} [flag] GetValuesWithIndexReply flag
             * @property {Uint8Array|null} [keyValues] GetValuesWithIndexReply keyValues
             */

            /**
             * Constructs a new GetValuesWithIndexReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetValuesWithIndexReply.
             * @implements IGetValuesWithIndexReply
             * @constructor
             * @param {dcnet.pb.IGetValuesWithIndexReply=} [properties] Properties to set
             */
            function GetValuesWithIndexReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetValuesWithIndexReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @instance
             */
            GetValuesWithIndexReply.prototype.flag = 0;

            /**
             * GetValuesWithIndexReply keyValues.
             * @member {Uint8Array} keyValues
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @instance
             */
            GetValuesWithIndexReply.prototype.keyValues = $util.newBuffer([]);

            /**
             * Creates a new GetValuesWithIndexReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @static
             * @param {dcnet.pb.IGetValuesWithIndexReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetValuesWithIndexReply} GetValuesWithIndexReply instance
             */
            GetValuesWithIndexReply.create = function create(properties) {
                return new GetValuesWithIndexReply(properties);
            };

            /**
             * Encodes the specified GetValuesWithIndexReply message. Does not implicitly {@link dcnet.pb.GetValuesWithIndexReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @static
             * @param {dcnet.pb.IGetValuesWithIndexReply} message GetValuesWithIndexReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValuesWithIndexReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.keyValues != null && Object.hasOwnProperty.call(message, "keyValues"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.keyValues);
                return writer;
            };

            /**
             * Encodes the specified GetValuesWithIndexReply message, length delimited. Does not implicitly {@link dcnet.pb.GetValuesWithIndexReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @static
             * @param {dcnet.pb.IGetValuesWithIndexReply} message GetValuesWithIndexReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValuesWithIndexReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetValuesWithIndexReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetValuesWithIndexReply} GetValuesWithIndexReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValuesWithIndexReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetValuesWithIndexReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.keyValues = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetValuesWithIndexReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetValuesWithIndexReply} GetValuesWithIndexReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValuesWithIndexReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetValuesWithIndexReply message.
             * @function verify
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetValuesWithIndexReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.keyValues != null && message.hasOwnProperty("keyValues"))
                    if (!(message.keyValues && typeof message.keyValues.length === "number" || $util.isString(message.keyValues)))
                        return "keyValues: buffer expected";
                return null;
            };

            /**
             * Creates a GetValuesWithIndexReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetValuesWithIndexReply} GetValuesWithIndexReply
             */
            GetValuesWithIndexReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetValuesWithIndexReply)
                    return object;
                let message = new $root.dcnet.pb.GetValuesWithIndexReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.keyValues != null)
                    if (typeof object.keyValues === "string")
                        $util.base64.decode(object.keyValues, message.keyValues = $util.newBuffer($util.base64.length(object.keyValues)), 0);
                    else if (object.keyValues.length >= 0)
                        message.keyValues = object.keyValues;
                return message;
            };

            /**
             * Creates a plain object from a GetValuesWithIndexReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @static
             * @param {dcnet.pb.GetValuesWithIndexReply} message GetValuesWithIndexReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetValuesWithIndexReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.keyValues = "";
                    else {
                        object.keyValues = [];
                        if (options.bytes !== Array)
                            object.keyValues = $util.newBuffer(object.keyValues);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.keyValues != null && message.hasOwnProperty("keyValues"))
                    object.keyValues = options.bytes === String ? $util.base64.encode(message.keyValues, 0, message.keyValues.length) : options.bytes === Array ? Array.prototype.slice.call(message.keyValues) : message.keyValues;
                return object;
            };

            /**
             * Converts this GetValuesWithIndexReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetValuesWithIndexReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetValuesWithIndexReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetValuesWithIndexReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetValuesWithIndexReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetValuesWithIndexReply";
            };

            return GetValuesWithIndexReply;
        })();

        pb.GetThemeAuthListRequest = (function() {

            /**
             * Properties of a GetThemeAuthListRequest.
             * @memberof dcnet.pb
             * @interface IGetThemeAuthListRequest
             * @property {Uint8Array|null} [theme] GetThemeAuthListRequest theme
             * @property {Uint8Array|null} [appId] GetThemeAuthListRequest appId
             * @property {Uint8Array|null} [themeAuthor] GetThemeAuthListRequest themeAuthor
             * @property {number|null} [startHeight] GetThemeAuthListRequest startHeight
             * @property {number|null} [direction] GetThemeAuthListRequest direction
             * @property {number|null} [offset] GetThemeAuthListRequest offset
             * @property {number|null} [limit] GetThemeAuthListRequest limit
             * @property {Uint8Array|null} [seekKey] GetThemeAuthListRequest seekKey
             * @property {Uint8Array|null} [vaccount] GetThemeAuthListRequest vaccount
             */

            /**
             * Constructs a new GetThemeAuthListRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThemeAuthListRequest.
             * @implements IGetThemeAuthListRequest
             * @constructor
             * @param {dcnet.pb.IGetThemeAuthListRequest=} [properties] Properties to set
             */
            function GetThemeAuthListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThemeAuthListRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @instance
             */
            GetThemeAuthListRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetThemeAuthListRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @instance
             */
            GetThemeAuthListRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetThemeAuthListRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @instance
             */
            GetThemeAuthListRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * GetThemeAuthListRequest startHeight.
             * @member {number} startHeight
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @instance
             */
            GetThemeAuthListRequest.prototype.startHeight = 0;

            /**
             * GetThemeAuthListRequest direction.
             * @member {number} direction
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @instance
             */
            GetThemeAuthListRequest.prototype.direction = 0;

            /**
             * GetThemeAuthListRequest offset.
             * @member {number} offset
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @instance
             */
            GetThemeAuthListRequest.prototype.offset = 0;

            /**
             * GetThemeAuthListRequest limit.
             * @member {number} limit
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @instance
             */
            GetThemeAuthListRequest.prototype.limit = 0;

            /**
             * GetThemeAuthListRequest seekKey.
             * @member {Uint8Array} seekKey
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @instance
             */
            GetThemeAuthListRequest.prototype.seekKey = $util.newBuffer([]);

            /**
             * GetThemeAuthListRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @instance
             */
            GetThemeAuthListRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new GetThemeAuthListRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @static
             * @param {dcnet.pb.IGetThemeAuthListRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetThemeAuthListRequest} GetThemeAuthListRequest instance
             */
            GetThemeAuthListRequest.create = function create(properties) {
                return new GetThemeAuthListRequest(properties);
            };

            /**
             * Encodes the specified GetThemeAuthListRequest message. Does not implicitly {@link dcnet.pb.GetThemeAuthListRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @static
             * @param {dcnet.pb.IGetThemeAuthListRequest} message GetThemeAuthListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeAuthListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.startHeight != null && Object.hasOwnProperty.call(message, "startHeight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.startHeight);
                if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.direction);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.offset);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.limit);
                if (message.seekKey != null && Object.hasOwnProperty.call(message, "seekKey"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.seekKey);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified GetThemeAuthListRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetThemeAuthListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @static
             * @param {dcnet.pb.IGetThemeAuthListRequest} message GetThemeAuthListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeAuthListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThemeAuthListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThemeAuthListRequest} GetThemeAuthListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeAuthListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThemeAuthListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.startHeight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.direction = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.offset = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.limit = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.seekKey = reader.bytes();
                            break;
                        }
                    case 9: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThemeAuthListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThemeAuthListRequest} GetThemeAuthListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeAuthListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThemeAuthListRequest message.
             * @function verify
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThemeAuthListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    if (!$util.isInteger(message.startHeight))
                        return "startHeight: integer expected";
                if (message.direction != null && message.hasOwnProperty("direction"))
                    if (!$util.isInteger(message.direction))
                        return "direction: integer expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset))
                        return "offset: integer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    if (!(message.seekKey && typeof message.seekKey.length === "number" || $util.isString(message.seekKey)))
                        return "seekKey: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a GetThemeAuthListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThemeAuthListRequest} GetThemeAuthListRequest
             */
            GetThemeAuthListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThemeAuthListRequest)
                    return object;
                let message = new $root.dcnet.pb.GetThemeAuthListRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.startHeight != null)
                    message.startHeight = object.startHeight >>> 0;
                if (object.direction != null)
                    message.direction = object.direction >>> 0;
                if (object.offset != null)
                    message.offset = object.offset >>> 0;
                if (object.limit != null)
                    message.limit = object.limit >>> 0;
                if (object.seekKey != null)
                    if (typeof object.seekKey === "string")
                        $util.base64.decode(object.seekKey, message.seekKey = $util.newBuffer($util.base64.length(object.seekKey)), 0);
                    else if (object.seekKey.length >= 0)
                        message.seekKey = object.seekKey;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a GetThemeAuthListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @static
             * @param {dcnet.pb.GetThemeAuthListRequest} message GetThemeAuthListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThemeAuthListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.startHeight = 0;
                    object.direction = 0;
                    object.offset = 0;
                    object.limit = 0;
                    if (options.bytes === String)
                        object.seekKey = "";
                    else {
                        object.seekKey = [];
                        if (options.bytes !== Array)
                            object.seekKey = $util.newBuffer(object.seekKey);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    object.startHeight = message.startHeight;
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = message.direction;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    object.seekKey = options.bytes === String ? $util.base64.encode(message.seekKey, 0, message.seekKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.seekKey) : message.seekKey;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this GetThemeAuthListRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThemeAuthListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThemeAuthListRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThemeAuthListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThemeAuthListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThemeAuthListRequest";
            };

            return GetThemeAuthListRequest;
        })();

        pb.GetThemeAuthListReply = (function() {

            /**
             * Properties of a GetThemeAuthListReply.
             * @memberof dcnet.pb
             * @interface IGetThemeAuthListReply
             * @property {number|null} [flag] GetThemeAuthListReply flag
             * @property {Uint8Array|null} [authListCid] GetThemeAuthListReply authListCid
             */

            /**
             * Constructs a new GetThemeAuthListReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThemeAuthListReply.
             * @implements IGetThemeAuthListReply
             * @constructor
             * @param {dcnet.pb.IGetThemeAuthListReply=} [properties] Properties to set
             */
            function GetThemeAuthListReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThemeAuthListReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @instance
             */
            GetThemeAuthListReply.prototype.flag = 0;

            /**
             * GetThemeAuthListReply authListCid.
             * @member {Uint8Array} authListCid
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @instance
             */
            GetThemeAuthListReply.prototype.authListCid = $util.newBuffer([]);

            /**
             * Creates a new GetThemeAuthListReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @static
             * @param {dcnet.pb.IGetThemeAuthListReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetThemeAuthListReply} GetThemeAuthListReply instance
             */
            GetThemeAuthListReply.create = function create(properties) {
                return new GetThemeAuthListReply(properties);
            };

            /**
             * Encodes the specified GetThemeAuthListReply message. Does not implicitly {@link dcnet.pb.GetThemeAuthListReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @static
             * @param {dcnet.pb.IGetThemeAuthListReply} message GetThemeAuthListReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeAuthListReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.authListCid != null && Object.hasOwnProperty.call(message, "authListCid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.authListCid);
                return writer;
            };

            /**
             * Encodes the specified GetThemeAuthListReply message, length delimited. Does not implicitly {@link dcnet.pb.GetThemeAuthListReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @static
             * @param {dcnet.pb.IGetThemeAuthListReply} message GetThemeAuthListReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeAuthListReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThemeAuthListReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThemeAuthListReply} GetThemeAuthListReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeAuthListReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThemeAuthListReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.authListCid = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThemeAuthListReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThemeAuthListReply} GetThemeAuthListReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeAuthListReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThemeAuthListReply message.
             * @function verify
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThemeAuthListReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.authListCid != null && message.hasOwnProperty("authListCid"))
                    if (!(message.authListCid && typeof message.authListCid.length === "number" || $util.isString(message.authListCid)))
                        return "authListCid: buffer expected";
                return null;
            };

            /**
             * Creates a GetThemeAuthListReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThemeAuthListReply} GetThemeAuthListReply
             */
            GetThemeAuthListReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThemeAuthListReply)
                    return object;
                let message = new $root.dcnet.pb.GetThemeAuthListReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.authListCid != null)
                    if (typeof object.authListCid === "string")
                        $util.base64.decode(object.authListCid, message.authListCid = $util.newBuffer($util.base64.length(object.authListCid)), 0);
                    else if (object.authListCid.length >= 0)
                        message.authListCid = object.authListCid;
                return message;
            };

            /**
             * Creates a plain object from a GetThemeAuthListReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @static
             * @param {dcnet.pb.GetThemeAuthListReply} message GetThemeAuthListReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThemeAuthListReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.authListCid = "";
                    else {
                        object.authListCid = [];
                        if (options.bytes !== Array)
                            object.authListCid = $util.newBuffer(object.authListCid);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.authListCid != null && message.hasOwnProperty("authListCid"))
                    object.authListCid = options.bytes === String ? $util.base64.encode(message.authListCid, 0, message.authListCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.authListCid) : message.authListCid;
                return object;
            };

            /**
             * Converts this GetThemeAuthListReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThemeAuthListReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThemeAuthListReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThemeAuthListReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThemeAuthListReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThemeAuthListReply";
            };

            return GetThemeAuthListReply;
        })();

        pb.GetUserCommentsRequest = (function() {

            /**
             * Properties of a GetUserCommentsRequest.
             * @memberof dcnet.pb
             * @interface IGetUserCommentsRequest
             * @property {Uint8Array|null} [appId] GetUserCommentsRequest appId
             * @property {Uint8Array|null} [UserPubkey] GetUserCommentsRequest UserPubkey
             * @property {number|null} [startHeight] GetUserCommentsRequest startHeight
             * @property {number|null} [direction] GetUserCommentsRequest direction
             * @property {number|null} [offset] GetUserCommentsRequest offset
             * @property {number|null} [limit] GetUserCommentsRequest limit
             * @property {Uint8Array|null} [seekKey] GetUserCommentsRequest seekKey
             * @property {Uint8Array|null} [vaccount] GetUserCommentsRequest vaccount
             */

            /**
             * Constructs a new GetUserCommentsRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetUserCommentsRequest.
             * @implements IGetUserCommentsRequest
             * @constructor
             * @param {dcnet.pb.IGetUserCommentsRequest=} [properties] Properties to set
             */
            function GetUserCommentsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUserCommentsRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @instance
             */
            GetUserCommentsRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetUserCommentsRequest UserPubkey.
             * @member {Uint8Array} UserPubkey
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @instance
             */
            GetUserCommentsRequest.prototype.UserPubkey = $util.newBuffer([]);

            /**
             * GetUserCommentsRequest startHeight.
             * @member {number} startHeight
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @instance
             */
            GetUserCommentsRequest.prototype.startHeight = 0;

            /**
             * GetUserCommentsRequest direction.
             * @member {number} direction
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @instance
             */
            GetUserCommentsRequest.prototype.direction = 0;

            /**
             * GetUserCommentsRequest offset.
             * @member {number} offset
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @instance
             */
            GetUserCommentsRequest.prototype.offset = 0;

            /**
             * GetUserCommentsRequest limit.
             * @member {number} limit
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @instance
             */
            GetUserCommentsRequest.prototype.limit = 0;

            /**
             * GetUserCommentsRequest seekKey.
             * @member {Uint8Array} seekKey
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @instance
             */
            GetUserCommentsRequest.prototype.seekKey = $util.newBuffer([]);

            /**
             * GetUserCommentsRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @instance
             */
            GetUserCommentsRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new GetUserCommentsRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @static
             * @param {dcnet.pb.IGetUserCommentsRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetUserCommentsRequest} GetUserCommentsRequest instance
             */
            GetUserCommentsRequest.create = function create(properties) {
                return new GetUserCommentsRequest(properties);
            };

            /**
             * Encodes the specified GetUserCommentsRequest message. Does not implicitly {@link dcnet.pb.GetUserCommentsRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @static
             * @param {dcnet.pb.IGetUserCommentsRequest} message GetUserCommentsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserCommentsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.appId);
                if (message.UserPubkey != null && Object.hasOwnProperty.call(message, "UserPubkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.UserPubkey);
                if (message.startHeight != null && Object.hasOwnProperty.call(message, "startHeight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.startHeight);
                if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.direction);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.offset);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.limit);
                if (message.seekKey != null && Object.hasOwnProperty.call(message, "seekKey"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.seekKey);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified GetUserCommentsRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetUserCommentsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @static
             * @param {dcnet.pb.IGetUserCommentsRequest} message GetUserCommentsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserCommentsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUserCommentsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetUserCommentsRequest} GetUserCommentsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserCommentsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetUserCommentsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.UserPubkey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.startHeight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.direction = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.offset = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.limit = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.seekKey = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUserCommentsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetUserCommentsRequest} GetUserCommentsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserCommentsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUserCommentsRequest message.
             * @function verify
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUserCommentsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.UserPubkey != null && message.hasOwnProperty("UserPubkey"))
                    if (!(message.UserPubkey && typeof message.UserPubkey.length === "number" || $util.isString(message.UserPubkey)))
                        return "UserPubkey: buffer expected";
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    if (!$util.isInteger(message.startHeight))
                        return "startHeight: integer expected";
                if (message.direction != null && message.hasOwnProperty("direction"))
                    if (!$util.isInteger(message.direction))
                        return "direction: integer expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset))
                        return "offset: integer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    if (!(message.seekKey && typeof message.seekKey.length === "number" || $util.isString(message.seekKey)))
                        return "seekKey: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a GetUserCommentsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetUserCommentsRequest} GetUserCommentsRequest
             */
            GetUserCommentsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetUserCommentsRequest)
                    return object;
                let message = new $root.dcnet.pb.GetUserCommentsRequest();
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.UserPubkey != null)
                    if (typeof object.UserPubkey === "string")
                        $util.base64.decode(object.UserPubkey, message.UserPubkey = $util.newBuffer($util.base64.length(object.UserPubkey)), 0);
                    else if (object.UserPubkey.length >= 0)
                        message.UserPubkey = object.UserPubkey;
                if (object.startHeight != null)
                    message.startHeight = object.startHeight >>> 0;
                if (object.direction != null)
                    message.direction = object.direction >>> 0;
                if (object.offset != null)
                    message.offset = object.offset >>> 0;
                if (object.limit != null)
                    message.limit = object.limit >>> 0;
                if (object.seekKey != null)
                    if (typeof object.seekKey === "string")
                        $util.base64.decode(object.seekKey, message.seekKey = $util.newBuffer($util.base64.length(object.seekKey)), 0);
                    else if (object.seekKey.length >= 0)
                        message.seekKey = object.seekKey;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a GetUserCommentsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @static
             * @param {dcnet.pb.GetUserCommentsRequest} message GetUserCommentsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUserCommentsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.UserPubkey = "";
                    else {
                        object.UserPubkey = [];
                        if (options.bytes !== Array)
                            object.UserPubkey = $util.newBuffer(object.UserPubkey);
                    }
                    object.startHeight = 0;
                    object.direction = 0;
                    object.offset = 0;
                    object.limit = 0;
                    if (options.bytes === String)
                        object.seekKey = "";
                    else {
                        object.seekKey = [];
                        if (options.bytes !== Array)
                            object.seekKey = $util.newBuffer(object.seekKey);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.UserPubkey != null && message.hasOwnProperty("UserPubkey"))
                    object.UserPubkey = options.bytes === String ? $util.base64.encode(message.UserPubkey, 0, message.UserPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.UserPubkey) : message.UserPubkey;
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    object.startHeight = message.startHeight;
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = message.direction;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    object.seekKey = options.bytes === String ? $util.base64.encode(message.seekKey, 0, message.seekKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.seekKey) : message.seekKey;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this GetUserCommentsRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUserCommentsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUserCommentsRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetUserCommentsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUserCommentsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetUserCommentsRequest";
            };

            return GetUserCommentsRequest;
        })();

        pb.GetUserCommentsReply = (function() {

            /**
             * Properties of a GetUserCommentsReply.
             * @memberof dcnet.pb
             * @interface IGetUserCommentsReply
             * @property {number|null} [flag] GetUserCommentsReply flag
             * @property {Uint8Array|null} [commentsCid] GetUserCommentsReply commentsCid
             */

            /**
             * Constructs a new GetUserCommentsReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetUserCommentsReply.
             * @implements IGetUserCommentsReply
             * @constructor
             * @param {dcnet.pb.IGetUserCommentsReply=} [properties] Properties to set
             */
            function GetUserCommentsReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUserCommentsReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetUserCommentsReply
             * @instance
             */
            GetUserCommentsReply.prototype.flag = 0;

            /**
             * GetUserCommentsReply commentsCid.
             * @member {Uint8Array} commentsCid
             * @memberof dcnet.pb.GetUserCommentsReply
             * @instance
             */
            GetUserCommentsReply.prototype.commentsCid = $util.newBuffer([]);

            /**
             * Creates a new GetUserCommentsReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetUserCommentsReply
             * @static
             * @param {dcnet.pb.IGetUserCommentsReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetUserCommentsReply} GetUserCommentsReply instance
             */
            GetUserCommentsReply.create = function create(properties) {
                return new GetUserCommentsReply(properties);
            };

            /**
             * Encodes the specified GetUserCommentsReply message. Does not implicitly {@link dcnet.pb.GetUserCommentsReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetUserCommentsReply
             * @static
             * @param {dcnet.pb.IGetUserCommentsReply} message GetUserCommentsReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserCommentsReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.commentsCid != null && Object.hasOwnProperty.call(message, "commentsCid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.commentsCid);
                return writer;
            };

            /**
             * Encodes the specified GetUserCommentsReply message, length delimited. Does not implicitly {@link dcnet.pb.GetUserCommentsReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetUserCommentsReply
             * @static
             * @param {dcnet.pb.IGetUserCommentsReply} message GetUserCommentsReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserCommentsReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUserCommentsReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetUserCommentsReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetUserCommentsReply} GetUserCommentsReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserCommentsReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetUserCommentsReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.commentsCid = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUserCommentsReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetUserCommentsReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetUserCommentsReply} GetUserCommentsReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserCommentsReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUserCommentsReply message.
             * @function verify
             * @memberof dcnet.pb.GetUserCommentsReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUserCommentsReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.commentsCid != null && message.hasOwnProperty("commentsCid"))
                    if (!(message.commentsCid && typeof message.commentsCid.length === "number" || $util.isString(message.commentsCid)))
                        return "commentsCid: buffer expected";
                return null;
            };

            /**
             * Creates a GetUserCommentsReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetUserCommentsReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetUserCommentsReply} GetUserCommentsReply
             */
            GetUserCommentsReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetUserCommentsReply)
                    return object;
                let message = new $root.dcnet.pb.GetUserCommentsReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.commentsCid != null)
                    if (typeof object.commentsCid === "string")
                        $util.base64.decode(object.commentsCid, message.commentsCid = $util.newBuffer($util.base64.length(object.commentsCid)), 0);
                    else if (object.commentsCid.length >= 0)
                        message.commentsCid = object.commentsCid;
                return message;
            };

            /**
             * Creates a plain object from a GetUserCommentsReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetUserCommentsReply
             * @static
             * @param {dcnet.pb.GetUserCommentsReply} message GetUserCommentsReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUserCommentsReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.commentsCid = "";
                    else {
                        object.commentsCid = [];
                        if (options.bytes !== Array)
                            object.commentsCid = $util.newBuffer(object.commentsCid);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.commentsCid != null && message.hasOwnProperty("commentsCid"))
                    object.commentsCid = options.bytes === String ? $util.base64.encode(message.commentsCid, 0, message.commentsCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.commentsCid) : message.commentsCid;
                return object;
            };

            /**
             * Converts this GetUserCommentsReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetUserCommentsReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUserCommentsReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUserCommentsReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetUserCommentsReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUserCommentsReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetUserCommentsReply";
            };

            return GetUserCommentsReply;
        })();

        pb.GetValueWithKeyRequest = (function() {

            /**
             * Properties of a GetValueWithKeyRequest.
             * @memberof dcnet.pb
             * @interface IGetValueWithKeyRequest
             * @property {Uint8Array|null} [theme] GetValueWithKeyRequest theme
             * @property {Uint8Array|null} [appId] GetValueWithKeyRequest appId
             * @property {Uint8Array|null} [themeAuthor] GetValueWithKeyRequest themeAuthor
             * @property {Uint8Array|null} [UserPubkey] GetValueWithKeyRequest UserPubkey
             * @property {Uint8Array|null} [Key] GetValueWithKeyRequest Key
             * @property {Uint8Array|null} [vaccount] GetValueWithKeyRequest vaccount
             */

            /**
             * Constructs a new GetValueWithKeyRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetValueWithKeyRequest.
             * @implements IGetValueWithKeyRequest
             * @constructor
             * @param {dcnet.pb.IGetValueWithKeyRequest=} [properties] Properties to set
             */
            function GetValueWithKeyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetValueWithKeyRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @instance
             */
            GetValueWithKeyRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetValueWithKeyRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @instance
             */
            GetValueWithKeyRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetValueWithKeyRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @instance
             */
            GetValueWithKeyRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * GetValueWithKeyRequest UserPubkey.
             * @member {Uint8Array} UserPubkey
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @instance
             */
            GetValueWithKeyRequest.prototype.UserPubkey = $util.newBuffer([]);

            /**
             * GetValueWithKeyRequest Key.
             * @member {Uint8Array} Key
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @instance
             */
            GetValueWithKeyRequest.prototype.Key = $util.newBuffer([]);

            /**
             * GetValueWithKeyRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @instance
             */
            GetValueWithKeyRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new GetValueWithKeyRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @static
             * @param {dcnet.pb.IGetValueWithKeyRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetValueWithKeyRequest} GetValueWithKeyRequest instance
             */
            GetValueWithKeyRequest.create = function create(properties) {
                return new GetValueWithKeyRequest(properties);
            };

            /**
             * Encodes the specified GetValueWithKeyRequest message. Does not implicitly {@link dcnet.pb.GetValueWithKeyRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @static
             * @param {dcnet.pb.IGetValueWithKeyRequest} message GetValueWithKeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValueWithKeyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.UserPubkey != null && Object.hasOwnProperty.call(message, "UserPubkey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.UserPubkey);
                if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Key);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified GetValueWithKeyRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetValueWithKeyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @static
             * @param {dcnet.pb.IGetValueWithKeyRequest} message GetValueWithKeyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValueWithKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetValueWithKeyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetValueWithKeyRequest} GetValueWithKeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValueWithKeyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetValueWithKeyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.UserPubkey = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.Key = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetValueWithKeyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetValueWithKeyRequest} GetValueWithKeyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValueWithKeyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetValueWithKeyRequest message.
             * @function verify
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetValueWithKeyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.UserPubkey != null && message.hasOwnProperty("UserPubkey"))
                    if (!(message.UserPubkey && typeof message.UserPubkey.length === "number" || $util.isString(message.UserPubkey)))
                        return "UserPubkey: buffer expected";
                if (message.Key != null && message.hasOwnProperty("Key"))
                    if (!(message.Key && typeof message.Key.length === "number" || $util.isString(message.Key)))
                        return "Key: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a GetValueWithKeyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetValueWithKeyRequest} GetValueWithKeyRequest
             */
            GetValueWithKeyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetValueWithKeyRequest)
                    return object;
                let message = new $root.dcnet.pb.GetValueWithKeyRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.UserPubkey != null)
                    if (typeof object.UserPubkey === "string")
                        $util.base64.decode(object.UserPubkey, message.UserPubkey = $util.newBuffer($util.base64.length(object.UserPubkey)), 0);
                    else if (object.UserPubkey.length >= 0)
                        message.UserPubkey = object.UserPubkey;
                if (object.Key != null)
                    if (typeof object.Key === "string")
                        $util.base64.decode(object.Key, message.Key = $util.newBuffer($util.base64.length(object.Key)), 0);
                    else if (object.Key.length >= 0)
                        message.Key = object.Key;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a GetValueWithKeyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @static
             * @param {dcnet.pb.GetValueWithKeyRequest} message GetValueWithKeyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetValueWithKeyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    if (options.bytes === String)
                        object.UserPubkey = "";
                    else {
                        object.UserPubkey = [];
                        if (options.bytes !== Array)
                            object.UserPubkey = $util.newBuffer(object.UserPubkey);
                    }
                    if (options.bytes === String)
                        object.Key = "";
                    else {
                        object.Key = [];
                        if (options.bytes !== Array)
                            object.Key = $util.newBuffer(object.Key);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.UserPubkey != null && message.hasOwnProperty("UserPubkey"))
                    object.UserPubkey = options.bytes === String ? $util.base64.encode(message.UserPubkey, 0, message.UserPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.UserPubkey) : message.UserPubkey;
                if (message.Key != null && message.hasOwnProperty("Key"))
                    object.Key = options.bytes === String ? $util.base64.encode(message.Key, 0, message.Key.length) : options.bytes === Array ? Array.prototype.slice.call(message.Key) : message.Key;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this GetValueWithKeyRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetValueWithKeyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetValueWithKeyRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetValueWithKeyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetValueWithKeyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetValueWithKeyRequest";
            };

            return GetValueWithKeyRequest;
        })();

        pb.GetValueWithKeyReply = (function() {

            /**
             * Properties of a GetValueWithKeyReply.
             * @memberof dcnet.pb
             * @interface IGetValueWithKeyReply
             * @property {number|null} [flag] GetValueWithKeyReply flag
             * @property {Uint8Array|null} [value] GetValueWithKeyReply value
             */

            /**
             * Constructs a new GetValueWithKeyReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetValueWithKeyReply.
             * @implements IGetValueWithKeyReply
             * @constructor
             * @param {dcnet.pb.IGetValueWithKeyReply=} [properties] Properties to set
             */
            function GetValueWithKeyReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetValueWithKeyReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @instance
             */
            GetValueWithKeyReply.prototype.flag = 0;

            /**
             * GetValueWithKeyReply value.
             * @member {Uint8Array} value
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @instance
             */
            GetValueWithKeyReply.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new GetValueWithKeyReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @static
             * @param {dcnet.pb.IGetValueWithKeyReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetValueWithKeyReply} GetValueWithKeyReply instance
             */
            GetValueWithKeyReply.create = function create(properties) {
                return new GetValueWithKeyReply(properties);
            };

            /**
             * Encodes the specified GetValueWithKeyReply message. Does not implicitly {@link dcnet.pb.GetValueWithKeyReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @static
             * @param {dcnet.pb.IGetValueWithKeyReply} message GetValueWithKeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValueWithKeyReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified GetValueWithKeyReply message, length delimited. Does not implicitly {@link dcnet.pb.GetValueWithKeyReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @static
             * @param {dcnet.pb.IGetValueWithKeyReply} message GetValueWithKeyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValueWithKeyReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetValueWithKeyReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetValueWithKeyReply} GetValueWithKeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValueWithKeyReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetValueWithKeyReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.value = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetValueWithKeyReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetValueWithKeyReply} GetValueWithKeyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValueWithKeyReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetValueWithKeyReply message.
             * @function verify
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetValueWithKeyReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a GetValueWithKeyReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetValueWithKeyReply} GetValueWithKeyReply
             */
            GetValueWithKeyReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetValueWithKeyReply)
                    return object;
                let message = new $root.dcnet.pb.GetValueWithKeyReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length >= 0)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a GetValueWithKeyReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @static
             * @param {dcnet.pb.GetValueWithKeyReply} message GetValueWithKeyReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetValueWithKeyReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this GetValueWithKeyReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetValueWithKeyReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetValueWithKeyReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetValueWithKeyReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetValueWithKeyReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetValueWithKeyReply";
            };

            return GetValueWithKeyReply;
        })();

        pb.GetValuesWithKeysRequest = (function() {

            /**
             * Properties of a GetValuesWithKeysRequest.
             * @memberof dcnet.pb
             * @interface IGetValuesWithKeysRequest
             * @property {Uint8Array|null} [theme] GetValuesWithKeysRequest theme
             * @property {Uint8Array|null} [appId] GetValuesWithKeysRequest appId
             * @property {Uint8Array|null} [themeAuthor] GetValuesWithKeysRequest themeAuthor
             * @property {Uint8Array|null} [UserPubkey] GetValuesWithKeysRequest UserPubkey
             * @property {Uint8Array|null} [Keys] GetValuesWithKeysRequest Keys
             * @property {Uint8Array|null} [vaccount] GetValuesWithKeysRequest vaccount
             */

            /**
             * Constructs a new GetValuesWithKeysRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetValuesWithKeysRequest.
             * @implements IGetValuesWithKeysRequest
             * @constructor
             * @param {dcnet.pb.IGetValuesWithKeysRequest=} [properties] Properties to set
             */
            function GetValuesWithKeysRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetValuesWithKeysRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @instance
             */
            GetValuesWithKeysRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetValuesWithKeysRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @instance
             */
            GetValuesWithKeysRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetValuesWithKeysRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @instance
             */
            GetValuesWithKeysRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * GetValuesWithKeysRequest UserPubkey.
             * @member {Uint8Array} UserPubkey
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @instance
             */
            GetValuesWithKeysRequest.prototype.UserPubkey = $util.newBuffer([]);

            /**
             * GetValuesWithKeysRequest Keys.
             * @member {Uint8Array} Keys
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @instance
             */
            GetValuesWithKeysRequest.prototype.Keys = $util.newBuffer([]);

            /**
             * GetValuesWithKeysRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @instance
             */
            GetValuesWithKeysRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new GetValuesWithKeysRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @static
             * @param {dcnet.pb.IGetValuesWithKeysRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetValuesWithKeysRequest} GetValuesWithKeysRequest instance
             */
            GetValuesWithKeysRequest.create = function create(properties) {
                return new GetValuesWithKeysRequest(properties);
            };

            /**
             * Encodes the specified GetValuesWithKeysRequest message. Does not implicitly {@link dcnet.pb.GetValuesWithKeysRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @static
             * @param {dcnet.pb.IGetValuesWithKeysRequest} message GetValuesWithKeysRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValuesWithKeysRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.UserPubkey != null && Object.hasOwnProperty.call(message, "UserPubkey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.UserPubkey);
                if (message.Keys != null && Object.hasOwnProperty.call(message, "Keys"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.Keys);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified GetValuesWithKeysRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetValuesWithKeysRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @static
             * @param {dcnet.pb.IGetValuesWithKeysRequest} message GetValuesWithKeysRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValuesWithKeysRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetValuesWithKeysRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetValuesWithKeysRequest} GetValuesWithKeysRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValuesWithKeysRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetValuesWithKeysRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.UserPubkey = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.Keys = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetValuesWithKeysRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetValuesWithKeysRequest} GetValuesWithKeysRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValuesWithKeysRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetValuesWithKeysRequest message.
             * @function verify
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetValuesWithKeysRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.UserPubkey != null && message.hasOwnProperty("UserPubkey"))
                    if (!(message.UserPubkey && typeof message.UserPubkey.length === "number" || $util.isString(message.UserPubkey)))
                        return "UserPubkey: buffer expected";
                if (message.Keys != null && message.hasOwnProperty("Keys"))
                    if (!(message.Keys && typeof message.Keys.length === "number" || $util.isString(message.Keys)))
                        return "Keys: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a GetValuesWithKeysRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetValuesWithKeysRequest} GetValuesWithKeysRequest
             */
            GetValuesWithKeysRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetValuesWithKeysRequest)
                    return object;
                let message = new $root.dcnet.pb.GetValuesWithKeysRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.UserPubkey != null)
                    if (typeof object.UserPubkey === "string")
                        $util.base64.decode(object.UserPubkey, message.UserPubkey = $util.newBuffer($util.base64.length(object.UserPubkey)), 0);
                    else if (object.UserPubkey.length >= 0)
                        message.UserPubkey = object.UserPubkey;
                if (object.Keys != null)
                    if (typeof object.Keys === "string")
                        $util.base64.decode(object.Keys, message.Keys = $util.newBuffer($util.base64.length(object.Keys)), 0);
                    else if (object.Keys.length >= 0)
                        message.Keys = object.Keys;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a GetValuesWithKeysRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @static
             * @param {dcnet.pb.GetValuesWithKeysRequest} message GetValuesWithKeysRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetValuesWithKeysRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    if (options.bytes === String)
                        object.UserPubkey = "";
                    else {
                        object.UserPubkey = [];
                        if (options.bytes !== Array)
                            object.UserPubkey = $util.newBuffer(object.UserPubkey);
                    }
                    if (options.bytes === String)
                        object.Keys = "";
                    else {
                        object.Keys = [];
                        if (options.bytes !== Array)
                            object.Keys = $util.newBuffer(object.Keys);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.UserPubkey != null && message.hasOwnProperty("UserPubkey"))
                    object.UserPubkey = options.bytes === String ? $util.base64.encode(message.UserPubkey, 0, message.UserPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.UserPubkey) : message.UserPubkey;
                if (message.Keys != null && message.hasOwnProperty("Keys"))
                    object.Keys = options.bytes === String ? $util.base64.encode(message.Keys, 0, message.Keys.length) : options.bytes === Array ? Array.prototype.slice.call(message.Keys) : message.Keys;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this GetValuesWithKeysRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetValuesWithKeysRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetValuesWithKeysRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetValuesWithKeysRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetValuesWithKeysRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetValuesWithKeysRequest";
            };

            return GetValuesWithKeysRequest;
        })();

        pb.GetValuesWithKeysReply = (function() {

            /**
             * Properties of a GetValuesWithKeysReply.
             * @memberof dcnet.pb
             * @interface IGetValuesWithKeysReply
             * @property {number|null} [flag] GetValuesWithKeysReply flag
             * @property {Uint8Array|null} [keyValues] GetValuesWithKeysReply keyValues
             */

            /**
             * Constructs a new GetValuesWithKeysReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetValuesWithKeysReply.
             * @implements IGetValuesWithKeysReply
             * @constructor
             * @param {dcnet.pb.IGetValuesWithKeysReply=} [properties] Properties to set
             */
            function GetValuesWithKeysReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetValuesWithKeysReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @instance
             */
            GetValuesWithKeysReply.prototype.flag = 0;

            /**
             * GetValuesWithKeysReply keyValues.
             * @member {Uint8Array} keyValues
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @instance
             */
            GetValuesWithKeysReply.prototype.keyValues = $util.newBuffer([]);

            /**
             * Creates a new GetValuesWithKeysReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @static
             * @param {dcnet.pb.IGetValuesWithKeysReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetValuesWithKeysReply} GetValuesWithKeysReply instance
             */
            GetValuesWithKeysReply.create = function create(properties) {
                return new GetValuesWithKeysReply(properties);
            };

            /**
             * Encodes the specified GetValuesWithKeysReply message. Does not implicitly {@link dcnet.pb.GetValuesWithKeysReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @static
             * @param {dcnet.pb.IGetValuesWithKeysReply} message GetValuesWithKeysReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValuesWithKeysReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.keyValues != null && Object.hasOwnProperty.call(message, "keyValues"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.keyValues);
                return writer;
            };

            /**
             * Encodes the specified GetValuesWithKeysReply message, length delimited. Does not implicitly {@link dcnet.pb.GetValuesWithKeysReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @static
             * @param {dcnet.pb.IGetValuesWithKeysReply} message GetValuesWithKeysReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetValuesWithKeysReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetValuesWithKeysReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetValuesWithKeysReply} GetValuesWithKeysReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValuesWithKeysReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetValuesWithKeysReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.keyValues = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetValuesWithKeysReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetValuesWithKeysReply} GetValuesWithKeysReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetValuesWithKeysReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetValuesWithKeysReply message.
             * @function verify
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetValuesWithKeysReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.keyValues != null && message.hasOwnProperty("keyValues"))
                    if (!(message.keyValues && typeof message.keyValues.length === "number" || $util.isString(message.keyValues)))
                        return "keyValues: buffer expected";
                return null;
            };

            /**
             * Creates a GetValuesWithKeysReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetValuesWithKeysReply} GetValuesWithKeysReply
             */
            GetValuesWithKeysReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetValuesWithKeysReply)
                    return object;
                let message = new $root.dcnet.pb.GetValuesWithKeysReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.keyValues != null)
                    if (typeof object.keyValues === "string")
                        $util.base64.decode(object.keyValues, message.keyValues = $util.newBuffer($util.base64.length(object.keyValues)), 0);
                    else if (object.keyValues.length >= 0)
                        message.keyValues = object.keyValues;
                return message;
            };

            /**
             * Creates a plain object from a GetValuesWithKeysReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @static
             * @param {dcnet.pb.GetValuesWithKeysReply} message GetValuesWithKeysReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetValuesWithKeysReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.keyValues = "";
                    else {
                        object.keyValues = [];
                        if (options.bytes !== Array)
                            object.keyValues = $util.newBuffer(object.keyValues);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.keyValues != null && message.hasOwnProperty("keyValues"))
                    object.keyValues = options.bytes === String ? $util.base64.encode(message.keyValues, 0, message.keyValues.length) : options.bytes === Array ? Array.prototype.slice.call(message.keyValues) : message.keyValues;
                return object;
            };

            /**
             * Converts this GetValuesWithKeysReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetValuesWithKeysReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetValuesWithKeysReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetValuesWithKeysReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetValuesWithKeysReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetValuesWithKeysReply";
            };

            return GetValuesWithKeysReply;
        })();

        pb.PushThemeFunOptRequest = (function() {

            /**
             * Properties of a PushThemeFunOptRequest.
             * @memberof dcnet.pb
             * @interface IPushThemeFunOptRequest
             * @property {dcnet.pb.ICommentFunOpt|null} [opt] PushThemeFunOptRequest opt
             */

            /**
             * Constructs a new PushThemeFunOptRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a PushThemeFunOptRequest.
             * @implements IPushThemeFunOptRequest
             * @constructor
             * @param {dcnet.pb.IPushThemeFunOptRequest=} [properties] Properties to set
             */
            function PushThemeFunOptRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PushThemeFunOptRequest opt.
             * @member {dcnet.pb.ICommentFunOpt|null|undefined} opt
             * @memberof dcnet.pb.PushThemeFunOptRequest
             * @instance
             */
            PushThemeFunOptRequest.prototype.opt = null;

            /**
             * Creates a new PushThemeFunOptRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.PushThemeFunOptRequest
             * @static
             * @param {dcnet.pb.IPushThemeFunOptRequest=} [properties] Properties to set
             * @returns {dcnet.pb.PushThemeFunOptRequest} PushThemeFunOptRequest instance
             */
            PushThemeFunOptRequest.create = function create(properties) {
                return new PushThemeFunOptRequest(properties);
            };

            /**
             * Encodes the specified PushThemeFunOptRequest message. Does not implicitly {@link dcnet.pb.PushThemeFunOptRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.PushThemeFunOptRequest
             * @static
             * @param {dcnet.pb.IPushThemeFunOptRequest} message PushThemeFunOptRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushThemeFunOptRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    $root.dcnet.pb.CommentFunOpt.encode(message.opt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PushThemeFunOptRequest message, length delimited. Does not implicitly {@link dcnet.pb.PushThemeFunOptRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.PushThemeFunOptRequest
             * @static
             * @param {dcnet.pb.IPushThemeFunOptRequest} message PushThemeFunOptRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushThemeFunOptRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PushThemeFunOptRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.PushThemeFunOptRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.PushThemeFunOptRequest} PushThemeFunOptRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushThemeFunOptRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.PushThemeFunOptRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.opt = $root.dcnet.pb.CommentFunOpt.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PushThemeFunOptRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.PushThemeFunOptRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.PushThemeFunOptRequest} PushThemeFunOptRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushThemeFunOptRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PushThemeFunOptRequest message.
             * @function verify
             * @memberof dcnet.pb.PushThemeFunOptRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PushThemeFunOptRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.opt != null && message.hasOwnProperty("opt")) {
                    let error = $root.dcnet.pb.CommentFunOpt.verify(message.opt);
                    if (error)
                        return "opt." + error;
                }
                return null;
            };

            /**
             * Creates a PushThemeFunOptRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.PushThemeFunOptRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.PushThemeFunOptRequest} PushThemeFunOptRequest
             */
            PushThemeFunOptRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.PushThemeFunOptRequest)
                    return object;
                let message = new $root.dcnet.pb.PushThemeFunOptRequest();
                if (object.opt != null) {
                    if (typeof object.opt !== "object")
                        throw TypeError(".dcnet.pb.PushThemeFunOptRequest.opt: object expected");
                    message.opt = $root.dcnet.pb.CommentFunOpt.fromObject(object.opt);
                }
                return message;
            };

            /**
             * Creates a plain object from a PushThemeFunOptRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.PushThemeFunOptRequest
             * @static
             * @param {dcnet.pb.PushThemeFunOptRequest} message PushThemeFunOptRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PushThemeFunOptRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.opt = null;
                if (message.opt != null && message.hasOwnProperty("opt"))
                    object.opt = $root.dcnet.pb.CommentFunOpt.toObject(message.opt, options);
                return object;
            };

            /**
             * Converts this PushThemeFunOptRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.PushThemeFunOptRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PushThemeFunOptRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PushThemeFunOptRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.PushThemeFunOptRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PushThemeFunOptRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.PushThemeFunOptRequest";
            };

            return PushThemeFunOptRequest;
        })();

        pb.PushThemeFunOptReply = (function() {

            /**
             * Properties of a PushThemeFunOptReply.
             * @memberof dcnet.pb
             * @interface IPushThemeFunOptReply
             */

            /**
             * Constructs a new PushThemeFunOptReply.
             * @memberof dcnet.pb
             * @classdesc Represents a PushThemeFunOptReply.
             * @implements IPushThemeFunOptReply
             * @constructor
             * @param {dcnet.pb.IPushThemeFunOptReply=} [properties] Properties to set
             */
            function PushThemeFunOptReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PushThemeFunOptReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.PushThemeFunOptReply
             * @static
             * @param {dcnet.pb.IPushThemeFunOptReply=} [properties] Properties to set
             * @returns {dcnet.pb.PushThemeFunOptReply} PushThemeFunOptReply instance
             */
            PushThemeFunOptReply.create = function create(properties) {
                return new PushThemeFunOptReply(properties);
            };

            /**
             * Encodes the specified PushThemeFunOptReply message. Does not implicitly {@link dcnet.pb.PushThemeFunOptReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.PushThemeFunOptReply
             * @static
             * @param {dcnet.pb.IPushThemeFunOptReply} message PushThemeFunOptReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushThemeFunOptReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PushThemeFunOptReply message, length delimited. Does not implicitly {@link dcnet.pb.PushThemeFunOptReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.PushThemeFunOptReply
             * @static
             * @param {dcnet.pb.IPushThemeFunOptReply} message PushThemeFunOptReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushThemeFunOptReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PushThemeFunOptReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.PushThemeFunOptReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.PushThemeFunOptReply} PushThemeFunOptReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushThemeFunOptReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.PushThemeFunOptReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PushThemeFunOptReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.PushThemeFunOptReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.PushThemeFunOptReply} PushThemeFunOptReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushThemeFunOptReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PushThemeFunOptReply message.
             * @function verify
             * @memberof dcnet.pb.PushThemeFunOptReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PushThemeFunOptReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a PushThemeFunOptReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.PushThemeFunOptReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.PushThemeFunOptReply} PushThemeFunOptReply
             */
            PushThemeFunOptReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.PushThemeFunOptReply)
                    return object;
                return new $root.dcnet.pb.PushThemeFunOptReply();
            };

            /**
             * Creates a plain object from a PushThemeFunOptReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.PushThemeFunOptReply
             * @static
             * @param {dcnet.pb.PushThemeFunOptReply} message PushThemeFunOptReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PushThemeFunOptReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this PushThemeFunOptReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.PushThemeFunOptReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PushThemeFunOptReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PushThemeFunOptReply
             * @function getTypeUrl
             * @memberof dcnet.pb.PushThemeFunOptReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PushThemeFunOptReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.PushThemeFunOptReply";
            };

            return PushThemeFunOptReply;
        })();

        pb.PullCommentFunOptsRequest = (function() {

            /**
             * Properties of a PullCommentFunOptsRequest.
             * @memberof dcnet.pb
             * @interface IPullCommentFunOptsRequest
             * @property {Uint8Array|null} [userPubkey] PullCommentFunOptsRequest userPubkey
             * @property {number|null} [limit] PullCommentFunOptsRequest limit
             * @property {Array.<dcnet.pb.IpeerSeqno>|null} [seqs] PullCommentFunOptsRequest seqs
             */

            /**
             * Constructs a new PullCommentFunOptsRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a PullCommentFunOptsRequest.
             * @implements IPullCommentFunOptsRequest
             * @constructor
             * @param {dcnet.pb.IPullCommentFunOptsRequest=} [properties] Properties to set
             */
            function PullCommentFunOptsRequest(properties) {
                this.seqs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PullCommentFunOptsRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @instance
             */
            PullCommentFunOptsRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * PullCommentFunOptsRequest limit.
             * @member {number} limit
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @instance
             */
            PullCommentFunOptsRequest.prototype.limit = 0;

            /**
             * PullCommentFunOptsRequest seqs.
             * @member {Array.<dcnet.pb.IpeerSeqno>} seqs
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @instance
             */
            PullCommentFunOptsRequest.prototype.seqs = $util.emptyArray;

            /**
             * Creates a new PullCommentFunOptsRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @static
             * @param {dcnet.pb.IPullCommentFunOptsRequest=} [properties] Properties to set
             * @returns {dcnet.pb.PullCommentFunOptsRequest} PullCommentFunOptsRequest instance
             */
            PullCommentFunOptsRequest.create = function create(properties) {
                return new PullCommentFunOptsRequest(properties);
            };

            /**
             * Encodes the specified PullCommentFunOptsRequest message. Does not implicitly {@link dcnet.pb.PullCommentFunOptsRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @static
             * @param {dcnet.pb.IPullCommentFunOptsRequest} message PullCommentFunOptsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullCommentFunOptsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.limit);
                if (message.seqs != null && message.seqs.length)
                    for (let i = 0; i < message.seqs.length; ++i)
                        $root.dcnet.pb.peerSeqno.encode(message.seqs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PullCommentFunOptsRequest message, length delimited. Does not implicitly {@link dcnet.pb.PullCommentFunOptsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @static
             * @param {dcnet.pb.IPullCommentFunOptsRequest} message PullCommentFunOptsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullCommentFunOptsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PullCommentFunOptsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.PullCommentFunOptsRequest} PullCommentFunOptsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullCommentFunOptsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.PullCommentFunOptsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.limit = reader.uint32();
                            break;
                        }
                    case 3: {
                            if (!(message.seqs && message.seqs.length))
                                message.seqs = [];
                            message.seqs.push($root.dcnet.pb.peerSeqno.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PullCommentFunOptsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.PullCommentFunOptsRequest} PullCommentFunOptsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullCommentFunOptsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PullCommentFunOptsRequest message.
             * @function verify
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PullCommentFunOptsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.seqs != null && message.hasOwnProperty("seqs")) {
                    if (!Array.isArray(message.seqs))
                        return "seqs: array expected";
                    for (let i = 0; i < message.seqs.length; ++i) {
                        let error = $root.dcnet.pb.peerSeqno.verify(message.seqs[i]);
                        if (error)
                            return "seqs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PullCommentFunOptsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.PullCommentFunOptsRequest} PullCommentFunOptsRequest
             */
            PullCommentFunOptsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.PullCommentFunOptsRequest)
                    return object;
                let message = new $root.dcnet.pb.PullCommentFunOptsRequest();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.limit != null)
                    message.limit = object.limit >>> 0;
                if (object.seqs) {
                    if (!Array.isArray(object.seqs))
                        throw TypeError(".dcnet.pb.PullCommentFunOptsRequest.seqs: array expected");
                    message.seqs = [];
                    for (let i = 0; i < object.seqs.length; ++i) {
                        if (typeof object.seqs[i] !== "object")
                            throw TypeError(".dcnet.pb.PullCommentFunOptsRequest.seqs: object expected");
                        message.seqs[i] = $root.dcnet.pb.peerSeqno.fromObject(object.seqs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PullCommentFunOptsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @static
             * @param {dcnet.pb.PullCommentFunOptsRequest} message PullCommentFunOptsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PullCommentFunOptsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.seqs = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    object.limit = 0;
                }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.seqs && message.seqs.length) {
                    object.seqs = [];
                    for (let j = 0; j < message.seqs.length; ++j)
                        object.seqs[j] = $root.dcnet.pb.peerSeqno.toObject(message.seqs[j], options);
                }
                return object;
            };

            /**
             * Converts this PullCommentFunOptsRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PullCommentFunOptsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PullCommentFunOptsRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.PullCommentFunOptsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PullCommentFunOptsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.PullCommentFunOptsRequest";
            };

            return PullCommentFunOptsRequest;
        })();

        pb.peerSeqno = (function() {

            /**
             * Properties of a peerSeqno.
             * @memberof dcnet.pb
             * @interface IpeerSeqno
             * @property {Uint8Array|null} [peerid] peerSeqno peerid
             * @property {number|Long|null} [seqno] peerSeqno seqno
             */

            /**
             * Constructs a new peerSeqno.
             * @memberof dcnet.pb
             * @classdesc Represents a peerSeqno.
             * @implements IpeerSeqno
             * @constructor
             * @param {dcnet.pb.IpeerSeqno=} [properties] Properties to set
             */
            function peerSeqno(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * peerSeqno peerid.
             * @member {Uint8Array} peerid
             * @memberof dcnet.pb.peerSeqno
             * @instance
             */
            peerSeqno.prototype.peerid = $util.newBuffer([]);

            /**
             * peerSeqno seqno.
             * @member {number|Long} seqno
             * @memberof dcnet.pb.peerSeqno
             * @instance
             */
            peerSeqno.prototype.seqno = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new peerSeqno instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.peerSeqno
             * @static
             * @param {dcnet.pb.IpeerSeqno=} [properties] Properties to set
             * @returns {dcnet.pb.peerSeqno} peerSeqno instance
             */
            peerSeqno.create = function create(properties) {
                return new peerSeqno(properties);
            };

            /**
             * Encodes the specified peerSeqno message. Does not implicitly {@link dcnet.pb.peerSeqno.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.peerSeqno
             * @static
             * @param {dcnet.pb.IpeerSeqno} message peerSeqno message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            peerSeqno.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.peerid);
                if (message.seqno != null && Object.hasOwnProperty.call(message, "seqno"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.seqno);
                return writer;
            };

            /**
             * Encodes the specified peerSeqno message, length delimited. Does not implicitly {@link dcnet.pb.peerSeqno.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.peerSeqno
             * @static
             * @param {dcnet.pb.IpeerSeqno} message peerSeqno message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            peerSeqno.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a peerSeqno message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.peerSeqno
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.peerSeqno} peerSeqno
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            peerSeqno.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.peerSeqno();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.peerid = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.seqno = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a peerSeqno message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.peerSeqno
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.peerSeqno} peerSeqno
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            peerSeqno.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a peerSeqno message.
             * @function verify
             * @memberof dcnet.pb.peerSeqno
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            peerSeqno.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                        return "peerid: buffer expected";
                if (message.seqno != null && message.hasOwnProperty("seqno"))
                    if (!$util.isInteger(message.seqno) && !(message.seqno && $util.isInteger(message.seqno.low) && $util.isInteger(message.seqno.high)))
                        return "seqno: integer|Long expected";
                return null;
            };

            /**
             * Creates a peerSeqno message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.peerSeqno
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.peerSeqno} peerSeqno
             */
            peerSeqno.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.peerSeqno)
                    return object;
                let message = new $root.dcnet.pb.peerSeqno();
                if (object.peerid != null)
                    if (typeof object.peerid === "string")
                        $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                    else if (object.peerid.length >= 0)
                        message.peerid = object.peerid;
                if (object.seqno != null)
                    if ($util.Long)
                        (message.seqno = $util.Long.fromValue(object.seqno)).unsigned = true;
                    else if (typeof object.seqno === "string")
                        message.seqno = parseInt(object.seqno, 10);
                    else if (typeof object.seqno === "number")
                        message.seqno = object.seqno;
                    else if (typeof object.seqno === "object")
                        message.seqno = new $util.LongBits(object.seqno.low >>> 0, object.seqno.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a peerSeqno message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.peerSeqno
             * @static
             * @param {dcnet.pb.peerSeqno} message peerSeqno
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            peerSeqno.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.peerid = "";
                    else {
                        object.peerid = [];
                        if (options.bytes !== Array)
                            object.peerid = $util.newBuffer(object.peerid);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.seqno = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seqno = options.longs === String ? "0" : 0;
                }
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                if (message.seqno != null && message.hasOwnProperty("seqno"))
                    if (typeof message.seqno === "number")
                        object.seqno = options.longs === String ? String(message.seqno) : message.seqno;
                    else
                        object.seqno = options.longs === String ? $util.Long.prototype.toString.call(message.seqno) : options.longs === Number ? new $util.LongBits(message.seqno.low >>> 0, message.seqno.high >>> 0).toNumber(true) : message.seqno;
                return object;
            };

            /**
             * Converts this peerSeqno to JSON.
             * @function toJSON
             * @memberof dcnet.pb.peerSeqno
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            peerSeqno.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for peerSeqno
             * @function getTypeUrl
             * @memberof dcnet.pb.peerSeqno
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            peerSeqno.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.peerSeqno";
            };

            return peerSeqno;
        })();

        pb.PullCommentFunOptsReply = (function() {

            /**
             * Properties of a PullCommentFunOptsReply.
             * @memberof dcnet.pb
             * @interface IPullCommentFunOptsReply
             * @property {number|null} [flag] PullCommentFunOptsReply flag
             * @property {Uint8Array|null} [funcOptsCid] PullCommentFunOptsReply funcOptsCid
             */

            /**
             * Constructs a new PullCommentFunOptsReply.
             * @memberof dcnet.pb
             * @classdesc Represents a PullCommentFunOptsReply.
             * @implements IPullCommentFunOptsReply
             * @constructor
             * @param {dcnet.pb.IPullCommentFunOptsReply=} [properties] Properties to set
             */
            function PullCommentFunOptsReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PullCommentFunOptsReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @instance
             */
            PullCommentFunOptsReply.prototype.flag = 0;

            /**
             * PullCommentFunOptsReply funcOptsCid.
             * @member {Uint8Array} funcOptsCid
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @instance
             */
            PullCommentFunOptsReply.prototype.funcOptsCid = $util.newBuffer([]);

            /**
             * Creates a new PullCommentFunOptsReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @static
             * @param {dcnet.pb.IPullCommentFunOptsReply=} [properties] Properties to set
             * @returns {dcnet.pb.PullCommentFunOptsReply} PullCommentFunOptsReply instance
             */
            PullCommentFunOptsReply.create = function create(properties) {
                return new PullCommentFunOptsReply(properties);
            };

            /**
             * Encodes the specified PullCommentFunOptsReply message. Does not implicitly {@link dcnet.pb.PullCommentFunOptsReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @static
             * @param {dcnet.pb.IPullCommentFunOptsReply} message PullCommentFunOptsReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullCommentFunOptsReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.funcOptsCid != null && Object.hasOwnProperty.call(message, "funcOptsCid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.funcOptsCid);
                return writer;
            };

            /**
             * Encodes the specified PullCommentFunOptsReply message, length delimited. Does not implicitly {@link dcnet.pb.PullCommentFunOptsReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @static
             * @param {dcnet.pb.IPullCommentFunOptsReply} message PullCommentFunOptsReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PullCommentFunOptsReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PullCommentFunOptsReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.PullCommentFunOptsReply} PullCommentFunOptsReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullCommentFunOptsReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.PullCommentFunOptsReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.funcOptsCid = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PullCommentFunOptsReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.PullCommentFunOptsReply} PullCommentFunOptsReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PullCommentFunOptsReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PullCommentFunOptsReply message.
             * @function verify
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PullCommentFunOptsReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.funcOptsCid != null && message.hasOwnProperty("funcOptsCid"))
                    if (!(message.funcOptsCid && typeof message.funcOptsCid.length === "number" || $util.isString(message.funcOptsCid)))
                        return "funcOptsCid: buffer expected";
                return null;
            };

            /**
             * Creates a PullCommentFunOptsReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.PullCommentFunOptsReply} PullCommentFunOptsReply
             */
            PullCommentFunOptsReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.PullCommentFunOptsReply)
                    return object;
                let message = new $root.dcnet.pb.PullCommentFunOptsReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.funcOptsCid != null)
                    if (typeof object.funcOptsCid === "string")
                        $util.base64.decode(object.funcOptsCid, message.funcOptsCid = $util.newBuffer($util.base64.length(object.funcOptsCid)), 0);
                    else if (object.funcOptsCid.length >= 0)
                        message.funcOptsCid = object.funcOptsCid;
                return message;
            };

            /**
             * Creates a plain object from a PullCommentFunOptsReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @static
             * @param {dcnet.pb.PullCommentFunOptsReply} message PullCommentFunOptsReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PullCommentFunOptsReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.funcOptsCid = "";
                    else {
                        object.funcOptsCid = [];
                        if (options.bytes !== Array)
                            object.funcOptsCid = $util.newBuffer(object.funcOptsCid);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.funcOptsCid != null && message.hasOwnProperty("funcOptsCid"))
                    object.funcOptsCid = options.bytes === String ? $util.base64.encode(message.funcOptsCid, 0, message.funcOptsCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.funcOptsCid) : message.funcOptsCid;
                return object;
            };

            /**
             * Converts this PullCommentFunOptsReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PullCommentFunOptsReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PullCommentFunOptsReply
             * @function getTypeUrl
             * @memberof dcnet.pb.PullCommentFunOptsReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PullCommentFunOptsReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.PullCommentFunOptsReply";
            };

            return PullCommentFunOptsReply;
        })();

        pb.CommentFunOpt = (function() {

            /**
             * Properties of a CommentFunOpt.
             * @memberof dcnet.pb
             * @interface ICommentFunOpt
             * @property {Uint8Array|null} [userPubkey] CommentFunOpt userPubkey
             * @property {number|Long|null} [seqno] CommentFunOpt seqno
             * @property {Uint8Array|null} [peerid] CommentFunOpt peerid
             * @property {number|null} [opType] CommentFunOpt opType
             * @property {Uint8Array|null} [opReq] CommentFunOpt opReq
             */

            /**
             * Constructs a new CommentFunOpt.
             * @memberof dcnet.pb
             * @classdesc Represents a CommentFunOpt.
             * @implements ICommentFunOpt
             * @constructor
             * @param {dcnet.pb.ICommentFunOpt=} [properties] Properties to set
             */
            function CommentFunOpt(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CommentFunOpt userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.CommentFunOpt
             * @instance
             */
            CommentFunOpt.prototype.userPubkey = $util.newBuffer([]);

            /**
             * CommentFunOpt seqno.
             * @member {number|Long} seqno
             * @memberof dcnet.pb.CommentFunOpt
             * @instance
             */
            CommentFunOpt.prototype.seqno = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CommentFunOpt peerid.
             * @member {Uint8Array} peerid
             * @memberof dcnet.pb.CommentFunOpt
             * @instance
             */
            CommentFunOpt.prototype.peerid = $util.newBuffer([]);

            /**
             * CommentFunOpt opType.
             * @member {number} opType
             * @memberof dcnet.pb.CommentFunOpt
             * @instance
             */
            CommentFunOpt.prototype.opType = 0;

            /**
             * CommentFunOpt opReq.
             * @member {Uint8Array} opReq
             * @memberof dcnet.pb.CommentFunOpt
             * @instance
             */
            CommentFunOpt.prototype.opReq = $util.newBuffer([]);

            /**
             * Creates a new CommentFunOpt instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.CommentFunOpt
             * @static
             * @param {dcnet.pb.ICommentFunOpt=} [properties] Properties to set
             * @returns {dcnet.pb.CommentFunOpt} CommentFunOpt instance
             */
            CommentFunOpt.create = function create(properties) {
                return new CommentFunOpt(properties);
            };

            /**
             * Encodes the specified CommentFunOpt message. Does not implicitly {@link dcnet.pb.CommentFunOpt.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.CommentFunOpt
             * @static
             * @param {dcnet.pb.ICommentFunOpt} message CommentFunOpt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommentFunOpt.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                if (message.seqno != null && Object.hasOwnProperty.call(message, "seqno"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.seqno);
                if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.peerid);
                if (message.opType != null && Object.hasOwnProperty.call(message, "opType"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.opType);
                if (message.opReq != null && Object.hasOwnProperty.call(message, "opReq"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.opReq);
                return writer;
            };

            /**
             * Encodes the specified CommentFunOpt message, length delimited. Does not implicitly {@link dcnet.pb.CommentFunOpt.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.CommentFunOpt
             * @static
             * @param {dcnet.pb.ICommentFunOpt} message CommentFunOpt message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommentFunOpt.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommentFunOpt message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.CommentFunOpt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.CommentFunOpt} CommentFunOpt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommentFunOpt.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.CommentFunOpt();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.seqno = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.peerid = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.opType = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.opReq = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CommentFunOpt message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.CommentFunOpt
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.CommentFunOpt} CommentFunOpt
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommentFunOpt.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommentFunOpt message.
             * @function verify
             * @memberof dcnet.pb.CommentFunOpt
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommentFunOpt.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.seqno != null && message.hasOwnProperty("seqno"))
                    if (!$util.isInteger(message.seqno) && !(message.seqno && $util.isInteger(message.seqno.low) && $util.isInteger(message.seqno.high)))
                        return "seqno: integer|Long expected";
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                        return "peerid: buffer expected";
                if (message.opType != null && message.hasOwnProperty("opType"))
                    if (!$util.isInteger(message.opType))
                        return "opType: integer expected";
                if (message.opReq != null && message.hasOwnProperty("opReq"))
                    if (!(message.opReq && typeof message.opReq.length === "number" || $util.isString(message.opReq)))
                        return "opReq: buffer expected";
                return null;
            };

            /**
             * Creates a CommentFunOpt message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.CommentFunOpt
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.CommentFunOpt} CommentFunOpt
             */
            CommentFunOpt.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.CommentFunOpt)
                    return object;
                let message = new $root.dcnet.pb.CommentFunOpt();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.seqno != null)
                    if ($util.Long)
                        (message.seqno = $util.Long.fromValue(object.seqno)).unsigned = true;
                    else if (typeof object.seqno === "string")
                        message.seqno = parseInt(object.seqno, 10);
                    else if (typeof object.seqno === "number")
                        message.seqno = object.seqno;
                    else if (typeof object.seqno === "object")
                        message.seqno = new $util.LongBits(object.seqno.low >>> 0, object.seqno.high >>> 0).toNumber(true);
                if (object.peerid != null)
                    if (typeof object.peerid === "string")
                        $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                    else if (object.peerid.length >= 0)
                        message.peerid = object.peerid;
                if (object.opType != null)
                    message.opType = object.opType >>> 0;
                if (object.opReq != null)
                    if (typeof object.opReq === "string")
                        $util.base64.decode(object.opReq, message.opReq = $util.newBuffer($util.base64.length(object.opReq)), 0);
                    else if (object.opReq.length >= 0)
                        message.opReq = object.opReq;
                return message;
            };

            /**
             * Creates a plain object from a CommentFunOpt message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.CommentFunOpt
             * @static
             * @param {dcnet.pb.CommentFunOpt} message CommentFunOpt
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommentFunOpt.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.seqno = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seqno = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.peerid = "";
                    else {
                        object.peerid = [];
                        if (options.bytes !== Array)
                            object.peerid = $util.newBuffer(object.peerid);
                    }
                    object.opType = 0;
                    if (options.bytes === String)
                        object.opReq = "";
                    else {
                        object.opReq = [];
                        if (options.bytes !== Array)
                            object.opReq = $util.newBuffer(object.opReq);
                    }
                }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.seqno != null && message.hasOwnProperty("seqno"))
                    if (typeof message.seqno === "number")
                        object.seqno = options.longs === String ? String(message.seqno) : message.seqno;
                    else
                        object.seqno = options.longs === String ? $util.Long.prototype.toString.call(message.seqno) : options.longs === Number ? new $util.LongBits(message.seqno.low >>> 0, message.seqno.high >>> 0).toNumber(true) : message.seqno;
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                if (message.opType != null && message.hasOwnProperty("opType"))
                    object.opType = message.opType;
                if (message.opReq != null && message.hasOwnProperty("opReq"))
                    object.opReq = options.bytes === String ? $util.base64.encode(message.opReq, 0, message.opReq.length) : options.bytes === Array ? Array.prototype.slice.call(message.opReq) : message.opReq;
                return object;
            };

            /**
             * Converts this CommentFunOpt to JSON.
             * @function toJSON
             * @memberof dcnet.pb.CommentFunOpt
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommentFunOpt.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CommentFunOpt
             * @function getTypeUrl
             * @memberof dcnet.pb.CommentFunOpt
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CommentFunOpt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.CommentFunOpt";
            };

            return CommentFunOpt;
        })();

        pb.ExchangeThemeEdgesRequest = (function() {

            /**
             * Properties of an ExchangeThemeEdgesRequest.
             * @memberof dcnet.pb
             * @interface IExchangeThemeEdgesRequest
             * @property {Array.<dcnet.pb.IUserCommentSeqEdge>|null} [userSeqEdges] ExchangeThemeEdgesRequest userSeqEdges
             */

            /**
             * Constructs a new ExchangeThemeEdgesRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an ExchangeThemeEdgesRequest.
             * @implements IExchangeThemeEdgesRequest
             * @constructor
             * @param {dcnet.pb.IExchangeThemeEdgesRequest=} [properties] Properties to set
             */
            function ExchangeThemeEdgesRequest(properties) {
                this.userSeqEdges = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExchangeThemeEdgesRequest userSeqEdges.
             * @member {Array.<dcnet.pb.IUserCommentSeqEdge>} userSeqEdges
             * @memberof dcnet.pb.ExchangeThemeEdgesRequest
             * @instance
             */
            ExchangeThemeEdgesRequest.prototype.userSeqEdges = $util.emptyArray;

            /**
             * Creates a new ExchangeThemeEdgesRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ExchangeThemeEdgesRequest
             * @static
             * @param {dcnet.pb.IExchangeThemeEdgesRequest=} [properties] Properties to set
             * @returns {dcnet.pb.ExchangeThemeEdgesRequest} ExchangeThemeEdgesRequest instance
             */
            ExchangeThemeEdgesRequest.create = function create(properties) {
                return new ExchangeThemeEdgesRequest(properties);
            };

            /**
             * Encodes the specified ExchangeThemeEdgesRequest message. Does not implicitly {@link dcnet.pb.ExchangeThemeEdgesRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ExchangeThemeEdgesRequest
             * @static
             * @param {dcnet.pb.IExchangeThemeEdgesRequest} message ExchangeThemeEdgesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExchangeThemeEdgesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userSeqEdges != null && message.userSeqEdges.length)
                    for (let i = 0; i < message.userSeqEdges.length; ++i)
                        $root.dcnet.pb.UserCommentSeqEdge.encode(message.userSeqEdges[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExchangeThemeEdgesRequest message, length delimited. Does not implicitly {@link dcnet.pb.ExchangeThemeEdgesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ExchangeThemeEdgesRequest
             * @static
             * @param {dcnet.pb.IExchangeThemeEdgesRequest} message ExchangeThemeEdgesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExchangeThemeEdgesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExchangeThemeEdgesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ExchangeThemeEdgesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ExchangeThemeEdgesRequest} ExchangeThemeEdgesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExchangeThemeEdgesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ExchangeThemeEdgesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.userSeqEdges && message.userSeqEdges.length))
                                message.userSeqEdges = [];
                            message.userSeqEdges.push($root.dcnet.pb.UserCommentSeqEdge.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExchangeThemeEdgesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ExchangeThemeEdgesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ExchangeThemeEdgesRequest} ExchangeThemeEdgesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExchangeThemeEdgesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExchangeThemeEdgesRequest message.
             * @function verify
             * @memberof dcnet.pb.ExchangeThemeEdgesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExchangeThemeEdgesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userSeqEdges != null && message.hasOwnProperty("userSeqEdges")) {
                    if (!Array.isArray(message.userSeqEdges))
                        return "userSeqEdges: array expected";
                    for (let i = 0; i < message.userSeqEdges.length; ++i) {
                        let error = $root.dcnet.pb.UserCommentSeqEdge.verify(message.userSeqEdges[i]);
                        if (error)
                            return "userSeqEdges." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an ExchangeThemeEdgesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ExchangeThemeEdgesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ExchangeThemeEdgesRequest} ExchangeThemeEdgesRequest
             */
            ExchangeThemeEdgesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ExchangeThemeEdgesRequest)
                    return object;
                let message = new $root.dcnet.pb.ExchangeThemeEdgesRequest();
                if (object.userSeqEdges) {
                    if (!Array.isArray(object.userSeqEdges))
                        throw TypeError(".dcnet.pb.ExchangeThemeEdgesRequest.userSeqEdges: array expected");
                    message.userSeqEdges = [];
                    for (let i = 0; i < object.userSeqEdges.length; ++i) {
                        if (typeof object.userSeqEdges[i] !== "object")
                            throw TypeError(".dcnet.pb.ExchangeThemeEdgesRequest.userSeqEdges: object expected");
                        message.userSeqEdges[i] = $root.dcnet.pb.UserCommentSeqEdge.fromObject(object.userSeqEdges[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an ExchangeThemeEdgesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ExchangeThemeEdgesRequest
             * @static
             * @param {dcnet.pb.ExchangeThemeEdgesRequest} message ExchangeThemeEdgesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExchangeThemeEdgesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.userSeqEdges = [];
                if (message.userSeqEdges && message.userSeqEdges.length) {
                    object.userSeqEdges = [];
                    for (let j = 0; j < message.userSeqEdges.length; ++j)
                        object.userSeqEdges[j] = $root.dcnet.pb.UserCommentSeqEdge.toObject(message.userSeqEdges[j], options);
                }
                return object;
            };

            /**
             * Converts this ExchangeThemeEdgesRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ExchangeThemeEdgesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExchangeThemeEdgesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExchangeThemeEdgesRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.ExchangeThemeEdgesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExchangeThemeEdgesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ExchangeThemeEdgesRequest";
            };

            return ExchangeThemeEdgesRequest;
        })();

        pb.ExchangeThemeEdgesReply = (function() {

            /**
             * Properties of an ExchangeThemeEdgesReply.
             * @memberof dcnet.pb
             * @interface IExchangeThemeEdgesReply
             * @property {Array.<dcnet.pb.IUserCommentSeqEdge>|null} [userSeqEdges] ExchangeThemeEdgesReply userSeqEdges
             */

            /**
             * Constructs a new ExchangeThemeEdgesReply.
             * @memberof dcnet.pb
             * @classdesc Represents an ExchangeThemeEdgesReply.
             * @implements IExchangeThemeEdgesReply
             * @constructor
             * @param {dcnet.pb.IExchangeThemeEdgesReply=} [properties] Properties to set
             */
            function ExchangeThemeEdgesReply(properties) {
                this.userSeqEdges = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExchangeThemeEdgesReply userSeqEdges.
             * @member {Array.<dcnet.pb.IUserCommentSeqEdge>} userSeqEdges
             * @memberof dcnet.pb.ExchangeThemeEdgesReply
             * @instance
             */
            ExchangeThemeEdgesReply.prototype.userSeqEdges = $util.emptyArray;

            /**
             * Creates a new ExchangeThemeEdgesReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ExchangeThemeEdgesReply
             * @static
             * @param {dcnet.pb.IExchangeThemeEdgesReply=} [properties] Properties to set
             * @returns {dcnet.pb.ExchangeThemeEdgesReply} ExchangeThemeEdgesReply instance
             */
            ExchangeThemeEdgesReply.create = function create(properties) {
                return new ExchangeThemeEdgesReply(properties);
            };

            /**
             * Encodes the specified ExchangeThemeEdgesReply message. Does not implicitly {@link dcnet.pb.ExchangeThemeEdgesReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ExchangeThemeEdgesReply
             * @static
             * @param {dcnet.pb.IExchangeThemeEdgesReply} message ExchangeThemeEdgesReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExchangeThemeEdgesReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userSeqEdges != null && message.userSeqEdges.length)
                    for (let i = 0; i < message.userSeqEdges.length; ++i)
                        $root.dcnet.pb.UserCommentSeqEdge.encode(message.userSeqEdges[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExchangeThemeEdgesReply message, length delimited. Does not implicitly {@link dcnet.pb.ExchangeThemeEdgesReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ExchangeThemeEdgesReply
             * @static
             * @param {dcnet.pb.IExchangeThemeEdgesReply} message ExchangeThemeEdgesReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExchangeThemeEdgesReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExchangeThemeEdgesReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ExchangeThemeEdgesReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ExchangeThemeEdgesReply} ExchangeThemeEdgesReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExchangeThemeEdgesReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ExchangeThemeEdgesReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.userSeqEdges && message.userSeqEdges.length))
                                message.userSeqEdges = [];
                            message.userSeqEdges.push($root.dcnet.pb.UserCommentSeqEdge.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExchangeThemeEdgesReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ExchangeThemeEdgesReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ExchangeThemeEdgesReply} ExchangeThemeEdgesReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExchangeThemeEdgesReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExchangeThemeEdgesReply message.
             * @function verify
             * @memberof dcnet.pb.ExchangeThemeEdgesReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExchangeThemeEdgesReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userSeqEdges != null && message.hasOwnProperty("userSeqEdges")) {
                    if (!Array.isArray(message.userSeqEdges))
                        return "userSeqEdges: array expected";
                    for (let i = 0; i < message.userSeqEdges.length; ++i) {
                        let error = $root.dcnet.pb.UserCommentSeqEdge.verify(message.userSeqEdges[i]);
                        if (error)
                            return "userSeqEdges." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an ExchangeThemeEdgesReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ExchangeThemeEdgesReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ExchangeThemeEdgesReply} ExchangeThemeEdgesReply
             */
            ExchangeThemeEdgesReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ExchangeThemeEdgesReply)
                    return object;
                let message = new $root.dcnet.pb.ExchangeThemeEdgesReply();
                if (object.userSeqEdges) {
                    if (!Array.isArray(object.userSeqEdges))
                        throw TypeError(".dcnet.pb.ExchangeThemeEdgesReply.userSeqEdges: array expected");
                    message.userSeqEdges = [];
                    for (let i = 0; i < object.userSeqEdges.length; ++i) {
                        if (typeof object.userSeqEdges[i] !== "object")
                            throw TypeError(".dcnet.pb.ExchangeThemeEdgesReply.userSeqEdges: object expected");
                        message.userSeqEdges[i] = $root.dcnet.pb.UserCommentSeqEdge.fromObject(object.userSeqEdges[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an ExchangeThemeEdgesReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ExchangeThemeEdgesReply
             * @static
             * @param {dcnet.pb.ExchangeThemeEdgesReply} message ExchangeThemeEdgesReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExchangeThemeEdgesReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.userSeqEdges = [];
                if (message.userSeqEdges && message.userSeqEdges.length) {
                    object.userSeqEdges = [];
                    for (let j = 0; j < message.userSeqEdges.length; ++j)
                        object.userSeqEdges[j] = $root.dcnet.pb.UserCommentSeqEdge.toObject(message.userSeqEdges[j], options);
                }
                return object;
            };

            /**
             * Converts this ExchangeThemeEdgesReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ExchangeThemeEdgesReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExchangeThemeEdgesReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExchangeThemeEdgesReply
             * @function getTypeUrl
             * @memberof dcnet.pb.ExchangeThemeEdgesReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExchangeThemeEdgesReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ExchangeThemeEdgesReply";
            };

            return ExchangeThemeEdgesReply;
        })();

        pb.UserCommentSeqEdge = (function() {

            /**
             * Properties of a UserCommentSeqEdge.
             * @memberof dcnet.pb
             * @interface IUserCommentSeqEdge
             * @property {Uint8Array|null} [userPubkey] UserCommentSeqEdge userPubkey
             * @property {number|Long|null} [seqedge] UserCommentSeqEdge seqedge
             */

            /**
             * Constructs a new UserCommentSeqEdge.
             * @memberof dcnet.pb
             * @classdesc Represents a UserCommentSeqEdge.
             * @implements IUserCommentSeqEdge
             * @constructor
             * @param {dcnet.pb.IUserCommentSeqEdge=} [properties] Properties to set
             */
            function UserCommentSeqEdge(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UserCommentSeqEdge userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @instance
             */
            UserCommentSeqEdge.prototype.userPubkey = $util.newBuffer([]);

            /**
             * UserCommentSeqEdge seqedge.
             * @member {number|Long} seqedge
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @instance
             */
            UserCommentSeqEdge.prototype.seqedge = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new UserCommentSeqEdge instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @static
             * @param {dcnet.pb.IUserCommentSeqEdge=} [properties] Properties to set
             * @returns {dcnet.pb.UserCommentSeqEdge} UserCommentSeqEdge instance
             */
            UserCommentSeqEdge.create = function create(properties) {
                return new UserCommentSeqEdge(properties);
            };

            /**
             * Encodes the specified UserCommentSeqEdge message. Does not implicitly {@link dcnet.pb.UserCommentSeqEdge.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @static
             * @param {dcnet.pb.IUserCommentSeqEdge} message UserCommentSeqEdge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserCommentSeqEdge.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                if (message.seqedge != null && Object.hasOwnProperty.call(message, "seqedge"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.seqedge);
                return writer;
            };

            /**
             * Encodes the specified UserCommentSeqEdge message, length delimited. Does not implicitly {@link dcnet.pb.UserCommentSeqEdge.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @static
             * @param {dcnet.pb.IUserCommentSeqEdge} message UserCommentSeqEdge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserCommentSeqEdge.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UserCommentSeqEdge message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.UserCommentSeqEdge} UserCommentSeqEdge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserCommentSeqEdge.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.UserCommentSeqEdge();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.seqedge = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UserCommentSeqEdge message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.UserCommentSeqEdge} UserCommentSeqEdge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserCommentSeqEdge.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UserCommentSeqEdge message.
             * @function verify
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UserCommentSeqEdge.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.seqedge != null && message.hasOwnProperty("seqedge"))
                    if (!$util.isInteger(message.seqedge) && !(message.seqedge && $util.isInteger(message.seqedge.low) && $util.isInteger(message.seqedge.high)))
                        return "seqedge: integer|Long expected";
                return null;
            };

            /**
             * Creates a UserCommentSeqEdge message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.UserCommentSeqEdge} UserCommentSeqEdge
             */
            UserCommentSeqEdge.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.UserCommentSeqEdge)
                    return object;
                let message = new $root.dcnet.pb.UserCommentSeqEdge();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.seqedge != null)
                    if ($util.Long)
                        (message.seqedge = $util.Long.fromValue(object.seqedge)).unsigned = true;
                    else if (typeof object.seqedge === "string")
                        message.seqedge = parseInt(object.seqedge, 10);
                    else if (typeof object.seqedge === "number")
                        message.seqedge = object.seqedge;
                    else if (typeof object.seqedge === "object")
                        message.seqedge = new $util.LongBits(object.seqedge.low >>> 0, object.seqedge.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a UserCommentSeqEdge message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @static
             * @param {dcnet.pb.UserCommentSeqEdge} message UserCommentSeqEdge
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UserCommentSeqEdge.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.seqedge = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seqedge = options.longs === String ? "0" : 0;
                }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.seqedge != null && message.hasOwnProperty("seqedge"))
                    if (typeof message.seqedge === "number")
                        object.seqedge = options.longs === String ? String(message.seqedge) : message.seqedge;
                    else
                        object.seqedge = options.longs === String ? $util.Long.prototype.toString.call(message.seqedge) : options.longs === Number ? new $util.LongBits(message.seqedge.low >>> 0, message.seqedge.high >>> 0).toNumber(true) : message.seqedge;
                return object;
            };

            /**
             * Converts this UserCommentSeqEdge to JSON.
             * @function toJSON
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UserCommentSeqEdge.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UserCommentSeqEdge
             * @function getTypeUrl
             * @memberof dcnet.pb.UserCommentSeqEdge
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UserCommentSeqEdge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.UserCommentSeqEdge";
            };

            return UserCommentSeqEdge;
        })();

        pb.DownloadUserCommentsRequest = (function() {

            /**
             * Properties of a DownloadUserCommentsRequest.
             * @memberof dcnet.pb
             * @interface IDownloadUserCommentsRequest
             * @property {Uint8Array|null} [userPubkey] DownloadUserCommentsRequest userPubkey
             * @property {number|null} [blockheight] DownloadUserCommentsRequest blockheight
             * @property {Uint8Array|null} [teereport] DownloadUserCommentsRequest teereport
             */

            /**
             * Constructs a new DownloadUserCommentsRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a DownloadUserCommentsRequest.
             * @implements IDownloadUserCommentsRequest
             * @constructor
             * @param {dcnet.pb.IDownloadUserCommentsRequest=} [properties] Properties to set
             */
            function DownloadUserCommentsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadUserCommentsRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @instance
             */
            DownloadUserCommentsRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * DownloadUserCommentsRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @instance
             */
            DownloadUserCommentsRequest.prototype.blockheight = 0;

            /**
             * DownloadUserCommentsRequest teereport.
             * @member {Uint8Array} teereport
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @instance
             */
            DownloadUserCommentsRequest.prototype.teereport = $util.newBuffer([]);

            /**
             * Creates a new DownloadUserCommentsRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @static
             * @param {dcnet.pb.IDownloadUserCommentsRequest=} [properties] Properties to set
             * @returns {dcnet.pb.DownloadUserCommentsRequest} DownloadUserCommentsRequest instance
             */
            DownloadUserCommentsRequest.create = function create(properties) {
                return new DownloadUserCommentsRequest(properties);
            };

            /**
             * Encodes the specified DownloadUserCommentsRequest message. Does not implicitly {@link dcnet.pb.DownloadUserCommentsRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @static
             * @param {dcnet.pb.IDownloadUserCommentsRequest} message DownloadUserCommentsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadUserCommentsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.teereport != null && Object.hasOwnProperty.call(message, "teereport"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.teereport);
                return writer;
            };

            /**
             * Encodes the specified DownloadUserCommentsRequest message, length delimited. Does not implicitly {@link dcnet.pb.DownloadUserCommentsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @static
             * @param {dcnet.pb.IDownloadUserCommentsRequest} message DownloadUserCommentsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadUserCommentsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadUserCommentsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DownloadUserCommentsRequest} DownloadUserCommentsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadUserCommentsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DownloadUserCommentsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.teereport = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadUserCommentsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DownloadUserCommentsRequest} DownloadUserCommentsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadUserCommentsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadUserCommentsRequest message.
             * @function verify
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadUserCommentsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    if (!(message.teereport && typeof message.teereport.length === "number" || $util.isString(message.teereport)))
                        return "teereport: buffer expected";
                return null;
            };

            /**
             * Creates a DownloadUserCommentsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DownloadUserCommentsRequest} DownloadUserCommentsRequest
             */
            DownloadUserCommentsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DownloadUserCommentsRequest)
                    return object;
                let message = new $root.dcnet.pb.DownloadUserCommentsRequest();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.teereport != null)
                    if (typeof object.teereport === "string")
                        $util.base64.decode(object.teereport, message.teereport = $util.newBuffer($util.base64.length(object.teereport)), 0);
                    else if (object.teereport.length >= 0)
                        message.teereport = object.teereport;
                return message;
            };

            /**
             * Creates a plain object from a DownloadUserCommentsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @static
             * @param {dcnet.pb.DownloadUserCommentsRequest} message DownloadUserCommentsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadUserCommentsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.teereport = "";
                    else {
                        object.teereport = [];
                        if (options.bytes !== Array)
                            object.teereport = $util.newBuffer(object.teereport);
                    }
                }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    object.teereport = options.bytes === String ? $util.base64.encode(message.teereport, 0, message.teereport.length) : options.bytes === Array ? Array.prototype.slice.call(message.teereport) : message.teereport;
                return object;
            };

            /**
             * Converts this DownloadUserCommentsRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadUserCommentsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadUserCommentsRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.DownloadUserCommentsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadUserCommentsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DownloadUserCommentsRequest";
            };

            return DownloadUserCommentsRequest;
        })();

        pb.DownloadUserCommentsReply = (function() {

            /**
             * Properties of a DownloadUserCommentsReply.
             * @memberof dcnet.pb
             * @interface IDownloadUserCommentsReply
             * @property {number|null} [flag] DownloadUserCommentsReply flag
             */

            /**
             * Constructs a new DownloadUserCommentsReply.
             * @memberof dcnet.pb
             * @classdesc Represents a DownloadUserCommentsReply.
             * @implements IDownloadUserCommentsReply
             * @constructor
             * @param {dcnet.pb.IDownloadUserCommentsReply=} [properties] Properties to set
             */
            function DownloadUserCommentsReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadUserCommentsReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.DownloadUserCommentsReply
             * @instance
             */
            DownloadUserCommentsReply.prototype.flag = 0;

            /**
             * Creates a new DownloadUserCommentsReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DownloadUserCommentsReply
             * @static
             * @param {dcnet.pb.IDownloadUserCommentsReply=} [properties] Properties to set
             * @returns {dcnet.pb.DownloadUserCommentsReply} DownloadUserCommentsReply instance
             */
            DownloadUserCommentsReply.create = function create(properties) {
                return new DownloadUserCommentsReply(properties);
            };

            /**
             * Encodes the specified DownloadUserCommentsReply message. Does not implicitly {@link dcnet.pb.DownloadUserCommentsReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DownloadUserCommentsReply
             * @static
             * @param {dcnet.pb.IDownloadUserCommentsReply} message DownloadUserCommentsReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadUserCommentsReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified DownloadUserCommentsReply message, length delimited. Does not implicitly {@link dcnet.pb.DownloadUserCommentsReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DownloadUserCommentsReply
             * @static
             * @param {dcnet.pb.IDownloadUserCommentsReply} message DownloadUserCommentsReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadUserCommentsReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadUserCommentsReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DownloadUserCommentsReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DownloadUserCommentsReply} DownloadUserCommentsReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadUserCommentsReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DownloadUserCommentsReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadUserCommentsReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DownloadUserCommentsReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DownloadUserCommentsReply} DownloadUserCommentsReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadUserCommentsReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadUserCommentsReply message.
             * @function verify
             * @memberof dcnet.pb.DownloadUserCommentsReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadUserCommentsReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a DownloadUserCommentsReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DownloadUserCommentsReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DownloadUserCommentsReply} DownloadUserCommentsReply
             */
            DownloadUserCommentsReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DownloadUserCommentsReply)
                    return object;
                let message = new $root.dcnet.pb.DownloadUserCommentsReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DownloadUserCommentsReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DownloadUserCommentsReply
             * @static
             * @param {dcnet.pb.DownloadUserCommentsReply} message DownloadUserCommentsReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadUserCommentsReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this DownloadUserCommentsReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DownloadUserCommentsReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadUserCommentsReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadUserCommentsReply
             * @function getTypeUrl
             * @memberof dcnet.pb.DownloadUserCommentsReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadUserCommentsReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DownloadUserCommentsReply";
            };

            return DownloadUserCommentsReply;
        })();

        pb.UserCommentsDownloadReadyRequest = (function() {

            /**
             * Properties of a UserCommentsDownloadReadyRequest.
             * @memberof dcnet.pb
             * @interface IUserCommentsDownloadReadyRequest
             * @property {Uint8Array|null} [userPubkey] UserCommentsDownloadReadyRequest userPubkey
             * @property {Uint8Array|null} [commentsCid] UserCommentsDownloadReadyRequest commentsCid
             * @property {number|null} [blockheight] UserCommentsDownloadReadyRequest blockheight
             * @property {Uint8Array|null} [teereport] UserCommentsDownloadReadyRequest teereport
             */

            /**
             * Constructs a new UserCommentsDownloadReadyRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a UserCommentsDownloadReadyRequest.
             * @implements IUserCommentsDownloadReadyRequest
             * @constructor
             * @param {dcnet.pb.IUserCommentsDownloadReadyRequest=} [properties] Properties to set
             */
            function UserCommentsDownloadReadyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UserCommentsDownloadReadyRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @instance
             */
            UserCommentsDownloadReadyRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * UserCommentsDownloadReadyRequest commentsCid.
             * @member {Uint8Array} commentsCid
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @instance
             */
            UserCommentsDownloadReadyRequest.prototype.commentsCid = $util.newBuffer([]);

            /**
             * UserCommentsDownloadReadyRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @instance
             */
            UserCommentsDownloadReadyRequest.prototype.blockheight = 0;

            /**
             * UserCommentsDownloadReadyRequest teereport.
             * @member {Uint8Array} teereport
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @instance
             */
            UserCommentsDownloadReadyRequest.prototype.teereport = $util.newBuffer([]);

            /**
             * Creates a new UserCommentsDownloadReadyRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @static
             * @param {dcnet.pb.IUserCommentsDownloadReadyRequest=} [properties] Properties to set
             * @returns {dcnet.pb.UserCommentsDownloadReadyRequest} UserCommentsDownloadReadyRequest instance
             */
            UserCommentsDownloadReadyRequest.create = function create(properties) {
                return new UserCommentsDownloadReadyRequest(properties);
            };

            /**
             * Encodes the specified UserCommentsDownloadReadyRequest message. Does not implicitly {@link dcnet.pb.UserCommentsDownloadReadyRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @static
             * @param {dcnet.pb.IUserCommentsDownloadReadyRequest} message UserCommentsDownloadReadyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserCommentsDownloadReadyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                if (message.commentsCid != null && Object.hasOwnProperty.call(message, "commentsCid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.commentsCid);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.blockheight);
                if (message.teereport != null && Object.hasOwnProperty.call(message, "teereport"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.teereport);
                return writer;
            };

            /**
             * Encodes the specified UserCommentsDownloadReadyRequest message, length delimited. Does not implicitly {@link dcnet.pb.UserCommentsDownloadReadyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @static
             * @param {dcnet.pb.IUserCommentsDownloadReadyRequest} message UserCommentsDownloadReadyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserCommentsDownloadReadyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UserCommentsDownloadReadyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.UserCommentsDownloadReadyRequest} UserCommentsDownloadReadyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserCommentsDownloadReadyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.UserCommentsDownloadReadyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.commentsCid = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.teereport = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UserCommentsDownloadReadyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.UserCommentsDownloadReadyRequest} UserCommentsDownloadReadyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserCommentsDownloadReadyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UserCommentsDownloadReadyRequest message.
             * @function verify
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UserCommentsDownloadReadyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.commentsCid != null && message.hasOwnProperty("commentsCid"))
                    if (!(message.commentsCid && typeof message.commentsCid.length === "number" || $util.isString(message.commentsCid)))
                        return "commentsCid: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    if (!(message.teereport && typeof message.teereport.length === "number" || $util.isString(message.teereport)))
                        return "teereport: buffer expected";
                return null;
            };

            /**
             * Creates a UserCommentsDownloadReadyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.UserCommentsDownloadReadyRequest} UserCommentsDownloadReadyRequest
             */
            UserCommentsDownloadReadyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.UserCommentsDownloadReadyRequest)
                    return object;
                let message = new $root.dcnet.pb.UserCommentsDownloadReadyRequest();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.commentsCid != null)
                    if (typeof object.commentsCid === "string")
                        $util.base64.decode(object.commentsCid, message.commentsCid = $util.newBuffer($util.base64.length(object.commentsCid)), 0);
                    else if (object.commentsCid.length >= 0)
                        message.commentsCid = object.commentsCid;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.teereport != null)
                    if (typeof object.teereport === "string")
                        $util.base64.decode(object.teereport, message.teereport = $util.newBuffer($util.base64.length(object.teereport)), 0);
                    else if (object.teereport.length >= 0)
                        message.teereport = object.teereport;
                return message;
            };

            /**
             * Creates a plain object from a UserCommentsDownloadReadyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @static
             * @param {dcnet.pb.UserCommentsDownloadReadyRequest} message UserCommentsDownloadReadyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UserCommentsDownloadReadyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.commentsCid = "";
                    else {
                        object.commentsCid = [];
                        if (options.bytes !== Array)
                            object.commentsCid = $util.newBuffer(object.commentsCid);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.teereport = "";
                    else {
                        object.teereport = [];
                        if (options.bytes !== Array)
                            object.teereport = $util.newBuffer(object.teereport);
                    }
                }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.commentsCid != null && message.hasOwnProperty("commentsCid"))
                    object.commentsCid = options.bytes === String ? $util.base64.encode(message.commentsCid, 0, message.commentsCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.commentsCid) : message.commentsCid;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.teereport != null && message.hasOwnProperty("teereport"))
                    object.teereport = options.bytes === String ? $util.base64.encode(message.teereport, 0, message.teereport.length) : options.bytes === Array ? Array.prototype.slice.call(message.teereport) : message.teereport;
                return object;
            };

            /**
             * Converts this UserCommentsDownloadReadyRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UserCommentsDownloadReadyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UserCommentsDownloadReadyRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.UserCommentsDownloadReadyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UserCommentsDownloadReadyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.UserCommentsDownloadReadyRequest";
            };

            return UserCommentsDownloadReadyRequest;
        })();

        pb.UserCommentsDownloadReadyReply = (function() {

            /**
             * Properties of a UserCommentsDownloadReadyReply.
             * @memberof dcnet.pb
             * @interface IUserCommentsDownloadReadyReply
             */

            /**
             * Constructs a new UserCommentsDownloadReadyReply.
             * @memberof dcnet.pb
             * @classdesc Represents a UserCommentsDownloadReadyReply.
             * @implements IUserCommentsDownloadReadyReply
             * @constructor
             * @param {dcnet.pb.IUserCommentsDownloadReadyReply=} [properties] Properties to set
             */
            function UserCommentsDownloadReadyReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new UserCommentsDownloadReadyReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.UserCommentsDownloadReadyReply
             * @static
             * @param {dcnet.pb.IUserCommentsDownloadReadyReply=} [properties] Properties to set
             * @returns {dcnet.pb.UserCommentsDownloadReadyReply} UserCommentsDownloadReadyReply instance
             */
            UserCommentsDownloadReadyReply.create = function create(properties) {
                return new UserCommentsDownloadReadyReply(properties);
            };

            /**
             * Encodes the specified UserCommentsDownloadReadyReply message. Does not implicitly {@link dcnet.pb.UserCommentsDownloadReadyReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.UserCommentsDownloadReadyReply
             * @static
             * @param {dcnet.pb.IUserCommentsDownloadReadyReply} message UserCommentsDownloadReadyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserCommentsDownloadReadyReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified UserCommentsDownloadReadyReply message, length delimited. Does not implicitly {@link dcnet.pb.UserCommentsDownloadReadyReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.UserCommentsDownloadReadyReply
             * @static
             * @param {dcnet.pb.IUserCommentsDownloadReadyReply} message UserCommentsDownloadReadyReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserCommentsDownloadReadyReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a UserCommentsDownloadReadyReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.UserCommentsDownloadReadyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.UserCommentsDownloadReadyReply} UserCommentsDownloadReadyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserCommentsDownloadReadyReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.UserCommentsDownloadReadyReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a UserCommentsDownloadReadyReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.UserCommentsDownloadReadyReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.UserCommentsDownloadReadyReply} UserCommentsDownloadReadyReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserCommentsDownloadReadyReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a UserCommentsDownloadReadyReply message.
             * @function verify
             * @memberof dcnet.pb.UserCommentsDownloadReadyReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UserCommentsDownloadReadyReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a UserCommentsDownloadReadyReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.UserCommentsDownloadReadyReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.UserCommentsDownloadReadyReply} UserCommentsDownloadReadyReply
             */
            UserCommentsDownloadReadyReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.UserCommentsDownloadReadyReply)
                    return object;
                return new $root.dcnet.pb.UserCommentsDownloadReadyReply();
            };

            /**
             * Creates a plain object from a UserCommentsDownloadReadyReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.UserCommentsDownloadReadyReply
             * @static
             * @param {dcnet.pb.UserCommentsDownloadReadyReply} message UserCommentsDownloadReadyReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UserCommentsDownloadReadyReply.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this UserCommentsDownloadReadyReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.UserCommentsDownloadReadyReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UserCommentsDownloadReadyReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UserCommentsDownloadReadyReply
             * @function getTypeUrl
             * @memberof dcnet.pb.UserCommentsDownloadReadyReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UserCommentsDownloadReadyReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.UserCommentsDownloadReadyReply";
            };

            return UserCommentsDownloadReadyReply;
        })();

        pb.DeviceStatusReportRequest = (function() {

            /**
             * Properties of a DeviceStatusReportRequest.
             * @memberof dcnet.pb
             * @interface IDeviceStatusReportRequest
             * @property {number|null} [seqno] DeviceStatusReportRequest seqno
             * @property {Uint8Array|null} [deviceID] DeviceStatusReportRequest deviceID
             * @property {Uint8Array|null} [theme] DeviceStatusReportRequest theme
             * @property {Uint8Array|null} [appId] DeviceStatusReportRequest appId
             * @property {Uint8Array|null} [themeAuthor] DeviceStatusReportRequest themeAuthor
             * @property {Uint8Array|null} [userPubkey] DeviceStatusReportRequest userPubkey
             * @property {number|null} [type] DeviceStatusReportRequest type
             * @property {Uint8Array|null} [contentHash] DeviceStatusReportRequest contentHash
             * @property {Uint8Array|null} [content] DeviceStatusReportRequest content
             * @property {number|null} [contentSize] DeviceStatusReportRequest contentSize
             * @property {number|null} [blockheight] DeviceStatusReportRequest blockheight
             * @property {Uint8Array|null} [groups] DeviceStatusReportRequest groups
             * @property {Uint8Array|null} [signature] DeviceStatusReportRequest signature
             * @property {Uint8Array|null} [rawReq] DeviceStatusReportRequest rawReq
             * @property {number|null} [resendcount] DeviceStatusReportRequest resendcount
             */

            /**
             * Constructs a new DeviceStatusReportRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a DeviceStatusReportRequest.
             * @implements IDeviceStatusReportRequest
             * @constructor
             * @param {dcnet.pb.IDeviceStatusReportRequest=} [properties] Properties to set
             */
            function DeviceStatusReportRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeviceStatusReportRequest seqno.
             * @member {number} seqno
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.seqno = 0;

            /**
             * DeviceStatusReportRequest deviceID.
             * @member {Uint8Array} deviceID
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.deviceID = $util.newBuffer([]);

            /**
             * DeviceStatusReportRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.theme = $util.newBuffer([]);

            /**
             * DeviceStatusReportRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.appId = $util.newBuffer([]);

            /**
             * DeviceStatusReportRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * DeviceStatusReportRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * DeviceStatusReportRequest type.
             * @member {number} type
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.type = 0;

            /**
             * DeviceStatusReportRequest contentHash.
             * @member {Uint8Array} contentHash
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.contentHash = $util.newBuffer([]);

            /**
             * DeviceStatusReportRequest content.
             * @member {Uint8Array} content
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.content = $util.newBuffer([]);

            /**
             * DeviceStatusReportRequest contentSize.
             * @member {number} contentSize
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.contentSize = 0;

            /**
             * DeviceStatusReportRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.blockheight = 0;

            /**
             * DeviceStatusReportRequest groups.
             * @member {Uint8Array} groups
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.groups = $util.newBuffer([]);

            /**
             * DeviceStatusReportRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.signature = $util.newBuffer([]);

            /**
             * DeviceStatusReportRequest rawReq.
             * @member {Uint8Array} rawReq
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.rawReq = $util.newBuffer([]);

            /**
             * DeviceStatusReportRequest resendcount.
             * @member {number} resendcount
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             */
            DeviceStatusReportRequest.prototype.resendcount = 0;

            /**
             * Creates a new DeviceStatusReportRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @static
             * @param {dcnet.pb.IDeviceStatusReportRequest=} [properties] Properties to set
             * @returns {dcnet.pb.DeviceStatusReportRequest} DeviceStatusReportRequest instance
             */
            DeviceStatusReportRequest.create = function create(properties) {
                return new DeviceStatusReportRequest(properties);
            };

            /**
             * Encodes the specified DeviceStatusReportRequest message. Does not implicitly {@link dcnet.pb.DeviceStatusReportRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @static
             * @param {dcnet.pb.IDeviceStatusReportRequest} message DeviceStatusReportRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceStatusReportRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seqno != null && Object.hasOwnProperty.call(message, "seqno"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.seqno);
                if (message.deviceID != null && Object.hasOwnProperty.call(message, "deviceID"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.deviceID);
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.themeAuthor);
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.userPubkey);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.type);
                if (message.contentHash != null && Object.hasOwnProperty.call(message, "contentHash"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.contentHash);
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.content);
                if (message.contentSize != null && Object.hasOwnProperty.call(message, "contentSize"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.contentSize);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.blockheight);
                if (message.groups != null && Object.hasOwnProperty.call(message, "groups"))
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.groups);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.signature);
                if (message.rawReq != null && Object.hasOwnProperty.call(message, "rawReq"))
                    writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.rawReq);
                if (message.resendcount != null && Object.hasOwnProperty.call(message, "resendcount"))
                    writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.resendcount);
                return writer;
            };

            /**
             * Encodes the specified DeviceStatusReportRequest message, length delimited. Does not implicitly {@link dcnet.pb.DeviceStatusReportRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @static
             * @param {dcnet.pb.IDeviceStatusReportRequest} message DeviceStatusReportRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceStatusReportRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeviceStatusReportRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeviceStatusReportRequest} DeviceStatusReportRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceStatusReportRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeviceStatusReportRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.seqno = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.deviceID = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.type = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.contentHash = reader.bytes();
                            break;
                        }
                    case 9: {
                            message.content = reader.bytes();
                            break;
                        }
                    case 10: {
                            message.contentSize = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 12: {
                            message.groups = reader.bytes();
                            break;
                        }
                    case 13: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 14: {
                            message.rawReq = reader.bytes();
                            break;
                        }
                    case 15: {
                            message.resendcount = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeviceStatusReportRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeviceStatusReportRequest} DeviceStatusReportRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceStatusReportRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeviceStatusReportRequest message.
             * @function verify
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeviceStatusReportRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seqno != null && message.hasOwnProperty("seqno"))
                    if (!$util.isInteger(message.seqno))
                        return "seqno: integer expected";
                if (message.deviceID != null && message.hasOwnProperty("deviceID"))
                    if (!(message.deviceID && typeof message.deviceID.length === "number" || $util.isString(message.deviceID)))
                        return "deviceID: buffer expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.contentHash != null && message.hasOwnProperty("contentHash"))
                    if (!(message.contentHash && typeof message.contentHash.length === "number" || $util.isString(message.contentHash)))
                        return "contentHash: buffer expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                        return "content: buffer expected";
                if (message.contentSize != null && message.hasOwnProperty("contentSize"))
                    if (!$util.isInteger(message.contentSize))
                        return "contentSize: integer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.groups != null && message.hasOwnProperty("groups"))
                    if (!(message.groups && typeof message.groups.length === "number" || $util.isString(message.groups)))
                        return "groups: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.rawReq != null && message.hasOwnProperty("rawReq"))
                    if (!(message.rawReq && typeof message.rawReq.length === "number" || $util.isString(message.rawReq)))
                        return "rawReq: buffer expected";
                if (message.resendcount != null && message.hasOwnProperty("resendcount"))
                    if (!$util.isInteger(message.resendcount))
                        return "resendcount: integer expected";
                return null;
            };

            /**
             * Creates a DeviceStatusReportRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeviceStatusReportRequest} DeviceStatusReportRequest
             */
            DeviceStatusReportRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeviceStatusReportRequest)
                    return object;
                let message = new $root.dcnet.pb.DeviceStatusReportRequest();
                if (object.seqno != null)
                    message.seqno = object.seqno >>> 0;
                if (object.deviceID != null)
                    if (typeof object.deviceID === "string")
                        $util.base64.decode(object.deviceID, message.deviceID = $util.newBuffer($util.base64.length(object.deviceID)), 0);
                    else if (object.deviceID.length >= 0)
                        message.deviceID = object.deviceID;
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.type != null)
                    message.type = object.type >>> 0;
                if (object.contentHash != null)
                    if (typeof object.contentHash === "string")
                        $util.base64.decode(object.contentHash, message.contentHash = $util.newBuffer($util.base64.length(object.contentHash)), 0);
                    else if (object.contentHash.length >= 0)
                        message.contentHash = object.contentHash;
                if (object.content != null)
                    if (typeof object.content === "string")
                        $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                    else if (object.content.length >= 0)
                        message.content = object.content;
                if (object.contentSize != null)
                    message.contentSize = object.contentSize >>> 0;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.groups != null)
                    if (typeof object.groups === "string")
                        $util.base64.decode(object.groups, message.groups = $util.newBuffer($util.base64.length(object.groups)), 0);
                    else if (object.groups.length >= 0)
                        message.groups = object.groups;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.rawReq != null)
                    if (typeof object.rawReq === "string")
                        $util.base64.decode(object.rawReq, message.rawReq = $util.newBuffer($util.base64.length(object.rawReq)), 0);
                    else if (object.rawReq.length >= 0)
                        message.rawReq = object.rawReq;
                if (object.resendcount != null)
                    message.resendcount = object.resendcount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DeviceStatusReportRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @static
             * @param {dcnet.pb.DeviceStatusReportRequest} message DeviceStatusReportRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeviceStatusReportRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.seqno = 0;
                    if (options.bytes === String)
                        object.deviceID = "";
                    else {
                        object.deviceID = [];
                        if (options.bytes !== Array)
                            object.deviceID = $util.newBuffer(object.deviceID);
                    }
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    object.type = 0;
                    if (options.bytes === String)
                        object.contentHash = "";
                    else {
                        object.contentHash = [];
                        if (options.bytes !== Array)
                            object.contentHash = $util.newBuffer(object.contentHash);
                    }
                    if (options.bytes === String)
                        object.content = "";
                    else {
                        object.content = [];
                        if (options.bytes !== Array)
                            object.content = $util.newBuffer(object.content);
                    }
                    object.contentSize = 0;
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.groups = "";
                    else {
                        object.groups = [];
                        if (options.bytes !== Array)
                            object.groups = $util.newBuffer(object.groups);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.rawReq = "";
                    else {
                        object.rawReq = [];
                        if (options.bytes !== Array)
                            object.rawReq = $util.newBuffer(object.rawReq);
                    }
                    object.resendcount = 0;
                }
                if (message.seqno != null && message.hasOwnProperty("seqno"))
                    object.seqno = message.seqno;
                if (message.deviceID != null && message.hasOwnProperty("deviceID"))
                    object.deviceID = options.bytes === String ? $util.base64.encode(message.deviceID, 0, message.deviceID.length) : options.bytes === Array ? Array.prototype.slice.call(message.deviceID) : message.deviceID;
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.contentHash != null && message.hasOwnProperty("contentHash"))
                    object.contentHash = options.bytes === String ? $util.base64.encode(message.contentHash, 0, message.contentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.contentHash) : message.contentHash;
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                if (message.contentSize != null && message.hasOwnProperty("contentSize"))
                    object.contentSize = message.contentSize;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.groups != null && message.hasOwnProperty("groups"))
                    object.groups = options.bytes === String ? $util.base64.encode(message.groups, 0, message.groups.length) : options.bytes === Array ? Array.prototype.slice.call(message.groups) : message.groups;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.rawReq != null && message.hasOwnProperty("rawReq"))
                    object.rawReq = options.bytes === String ? $util.base64.encode(message.rawReq, 0, message.rawReq.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawReq) : message.rawReq;
                if (message.resendcount != null && message.hasOwnProperty("resendcount"))
                    object.resendcount = message.resendcount;
                return object;
            };

            /**
             * Converts this DeviceStatusReportRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeviceStatusReportRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeviceStatusReportRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.DeviceStatusReportRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeviceStatusReportRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeviceStatusReportRequest";
            };

            return DeviceStatusReportRequest;
        })();

        pb.DeviceStatusReportReply = (function() {

            /**
             * Properties of a DeviceStatusReportReply.
             * @memberof dcnet.pb
             * @interface IDeviceStatusReportReply
             * @property {number|null} [flag] DeviceStatusReportReply flag
             */

            /**
             * Constructs a new DeviceStatusReportReply.
             * @memberof dcnet.pb
             * @classdesc Represents a DeviceStatusReportReply.
             * @implements IDeviceStatusReportReply
             * @constructor
             * @param {dcnet.pb.IDeviceStatusReportReply=} [properties] Properties to set
             */
            function DeviceStatusReportReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeviceStatusReportReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.DeviceStatusReportReply
             * @instance
             */
            DeviceStatusReportReply.prototype.flag = 0;

            /**
             * Creates a new DeviceStatusReportReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeviceStatusReportReply
             * @static
             * @param {dcnet.pb.IDeviceStatusReportReply=} [properties] Properties to set
             * @returns {dcnet.pb.DeviceStatusReportReply} DeviceStatusReportReply instance
             */
            DeviceStatusReportReply.create = function create(properties) {
                return new DeviceStatusReportReply(properties);
            };

            /**
             * Encodes the specified DeviceStatusReportReply message. Does not implicitly {@link dcnet.pb.DeviceStatusReportReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeviceStatusReportReply
             * @static
             * @param {dcnet.pb.IDeviceStatusReportReply} message DeviceStatusReportReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceStatusReportReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified DeviceStatusReportReply message, length delimited. Does not implicitly {@link dcnet.pb.DeviceStatusReportReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeviceStatusReportReply
             * @static
             * @param {dcnet.pb.IDeviceStatusReportReply} message DeviceStatusReportReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceStatusReportReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeviceStatusReportReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeviceStatusReportReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeviceStatusReportReply} DeviceStatusReportReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceStatusReportReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeviceStatusReportReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeviceStatusReportReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeviceStatusReportReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeviceStatusReportReply} DeviceStatusReportReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceStatusReportReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeviceStatusReportReply message.
             * @function verify
             * @memberof dcnet.pb.DeviceStatusReportReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeviceStatusReportReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a DeviceStatusReportReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeviceStatusReportReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeviceStatusReportReply} DeviceStatusReportReply
             */
            DeviceStatusReportReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeviceStatusReportReply)
                    return object;
                let message = new $root.dcnet.pb.DeviceStatusReportReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DeviceStatusReportReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeviceStatusReportReply
             * @static
             * @param {dcnet.pb.DeviceStatusReportReply} message DeviceStatusReportReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeviceStatusReportReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this DeviceStatusReportReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeviceStatusReportReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeviceStatusReportReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeviceStatusReportReply
             * @function getTypeUrl
             * @memberof dcnet.pb.DeviceStatusReportReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeviceStatusReportReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeviceStatusReportReply";
            };

            return DeviceStatusReportReply;
        })();

        pb.GetThemeDevicesStatusRequest = (function() {

            /**
             * Properties of a GetThemeDevicesStatusRequest.
             * @memberof dcnet.pb
             * @interface IGetThemeDevicesStatusRequest
             * @property {Uint8Array|null} [theme] GetThemeDevicesStatusRequest theme
             * @property {Uint8Array|null} [appId] GetThemeDevicesStatusRequest appId
             * @property {Uint8Array|null} [themeAuthor] GetThemeDevicesStatusRequest themeAuthor
             * @property {number|null} [direction] GetThemeDevicesStatusRequest direction
             * @property {number|null} [offset] GetThemeDevicesStatusRequest offset
             * @property {number|null} [limit] GetThemeDevicesStatusRequest limit
             * @property {Uint8Array|null} [seekKey] GetThemeDevicesStatusRequest seekKey
             * @property {Uint8Array|null} [groups] GetThemeDevicesStatusRequest groups
             */

            /**
             * Constructs a new GetThemeDevicesStatusRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThemeDevicesStatusRequest.
             * @implements IGetThemeDevicesStatusRequest
             * @constructor
             * @param {dcnet.pb.IGetThemeDevicesStatusRequest=} [properties] Properties to set
             */
            function GetThemeDevicesStatusRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThemeDevicesStatusRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @instance
             */
            GetThemeDevicesStatusRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetThemeDevicesStatusRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @instance
             */
            GetThemeDevicesStatusRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetThemeDevicesStatusRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @instance
             */
            GetThemeDevicesStatusRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * GetThemeDevicesStatusRequest direction.
             * @member {number} direction
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @instance
             */
            GetThemeDevicesStatusRequest.prototype.direction = 0;

            /**
             * GetThemeDevicesStatusRequest offset.
             * @member {number} offset
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @instance
             */
            GetThemeDevicesStatusRequest.prototype.offset = 0;

            /**
             * GetThemeDevicesStatusRequest limit.
             * @member {number} limit
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @instance
             */
            GetThemeDevicesStatusRequest.prototype.limit = 0;

            /**
             * GetThemeDevicesStatusRequest seekKey.
             * @member {Uint8Array} seekKey
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @instance
             */
            GetThemeDevicesStatusRequest.prototype.seekKey = $util.newBuffer([]);

            /**
             * GetThemeDevicesStatusRequest groups.
             * @member {Uint8Array} groups
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @instance
             */
            GetThemeDevicesStatusRequest.prototype.groups = $util.newBuffer([]);

            /**
             * Creates a new GetThemeDevicesStatusRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @static
             * @param {dcnet.pb.IGetThemeDevicesStatusRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetThemeDevicesStatusRequest} GetThemeDevicesStatusRequest instance
             */
            GetThemeDevicesStatusRequest.create = function create(properties) {
                return new GetThemeDevicesStatusRequest(properties);
            };

            /**
             * Encodes the specified GetThemeDevicesStatusRequest message. Does not implicitly {@link dcnet.pb.GetThemeDevicesStatusRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @static
             * @param {dcnet.pb.IGetThemeDevicesStatusRequest} message GetThemeDevicesStatusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeDevicesStatusRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.direction);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.offset);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.limit);
                if (message.seekKey != null && Object.hasOwnProperty.call(message, "seekKey"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.seekKey);
                if (message.groups != null && Object.hasOwnProperty.call(message, "groups"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.groups);
                return writer;
            };

            /**
             * Encodes the specified GetThemeDevicesStatusRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetThemeDevicesStatusRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @static
             * @param {dcnet.pb.IGetThemeDevicesStatusRequest} message GetThemeDevicesStatusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeDevicesStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThemeDevicesStatusRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThemeDevicesStatusRequest} GetThemeDevicesStatusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeDevicesStatusRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThemeDevicesStatusRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.direction = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.offset = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.limit = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.seekKey = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.groups = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThemeDevicesStatusRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThemeDevicesStatusRequest} GetThemeDevicesStatusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeDevicesStatusRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThemeDevicesStatusRequest message.
             * @function verify
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThemeDevicesStatusRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.direction != null && message.hasOwnProperty("direction"))
                    if (!$util.isInteger(message.direction))
                        return "direction: integer expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset))
                        return "offset: integer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    if (!(message.seekKey && typeof message.seekKey.length === "number" || $util.isString(message.seekKey)))
                        return "seekKey: buffer expected";
                if (message.groups != null && message.hasOwnProperty("groups"))
                    if (!(message.groups && typeof message.groups.length === "number" || $util.isString(message.groups)))
                        return "groups: buffer expected";
                return null;
            };

            /**
             * Creates a GetThemeDevicesStatusRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThemeDevicesStatusRequest} GetThemeDevicesStatusRequest
             */
            GetThemeDevicesStatusRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThemeDevicesStatusRequest)
                    return object;
                let message = new $root.dcnet.pb.GetThemeDevicesStatusRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.direction != null)
                    message.direction = object.direction >>> 0;
                if (object.offset != null)
                    message.offset = object.offset >>> 0;
                if (object.limit != null)
                    message.limit = object.limit >>> 0;
                if (object.seekKey != null)
                    if (typeof object.seekKey === "string")
                        $util.base64.decode(object.seekKey, message.seekKey = $util.newBuffer($util.base64.length(object.seekKey)), 0);
                    else if (object.seekKey.length >= 0)
                        message.seekKey = object.seekKey;
                if (object.groups != null)
                    if (typeof object.groups === "string")
                        $util.base64.decode(object.groups, message.groups = $util.newBuffer($util.base64.length(object.groups)), 0);
                    else if (object.groups.length >= 0)
                        message.groups = object.groups;
                return message;
            };

            /**
             * Creates a plain object from a GetThemeDevicesStatusRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @static
             * @param {dcnet.pb.GetThemeDevicesStatusRequest} message GetThemeDevicesStatusRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThemeDevicesStatusRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.direction = 0;
                    object.offset = 0;
                    object.limit = 0;
                    if (options.bytes === String)
                        object.seekKey = "";
                    else {
                        object.seekKey = [];
                        if (options.bytes !== Array)
                            object.seekKey = $util.newBuffer(object.seekKey);
                    }
                    if (options.bytes === String)
                        object.groups = "";
                    else {
                        object.groups = [];
                        if (options.bytes !== Array)
                            object.groups = $util.newBuffer(object.groups);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = message.direction;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    object.seekKey = options.bytes === String ? $util.base64.encode(message.seekKey, 0, message.seekKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.seekKey) : message.seekKey;
                if (message.groups != null && message.hasOwnProperty("groups"))
                    object.groups = options.bytes === String ? $util.base64.encode(message.groups, 0, message.groups.length) : options.bytes === Array ? Array.prototype.slice.call(message.groups) : message.groups;
                return object;
            };

            /**
             * Converts this GetThemeDevicesStatusRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThemeDevicesStatusRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThemeDevicesStatusRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThemeDevicesStatusRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThemeDevicesStatusRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThemeDevicesStatusRequest";
            };

            return GetThemeDevicesStatusRequest;
        })();

        pb.GetThemeDevicesStatusReply = (function() {

            /**
             * Properties of a GetThemeDevicesStatusReply.
             * @memberof dcnet.pb
             * @interface IGetThemeDevicesStatusReply
             * @property {number|null} [flag] GetThemeDevicesStatusReply flag
             * @property {Uint8Array|null} [statuslistCid] GetThemeDevicesStatusReply statuslistCid
             */

            /**
             * Constructs a new GetThemeDevicesStatusReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetThemeDevicesStatusReply.
             * @implements IGetThemeDevicesStatusReply
             * @constructor
             * @param {dcnet.pb.IGetThemeDevicesStatusReply=} [properties] Properties to set
             */
            function GetThemeDevicesStatusReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetThemeDevicesStatusReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @instance
             */
            GetThemeDevicesStatusReply.prototype.flag = 0;

            /**
             * GetThemeDevicesStatusReply statuslistCid.
             * @member {Uint8Array} statuslistCid
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @instance
             */
            GetThemeDevicesStatusReply.prototype.statuslistCid = $util.newBuffer([]);

            /**
             * Creates a new GetThemeDevicesStatusReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @static
             * @param {dcnet.pb.IGetThemeDevicesStatusReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetThemeDevicesStatusReply} GetThemeDevicesStatusReply instance
             */
            GetThemeDevicesStatusReply.create = function create(properties) {
                return new GetThemeDevicesStatusReply(properties);
            };

            /**
             * Encodes the specified GetThemeDevicesStatusReply message. Does not implicitly {@link dcnet.pb.GetThemeDevicesStatusReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @static
             * @param {dcnet.pb.IGetThemeDevicesStatusReply} message GetThemeDevicesStatusReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeDevicesStatusReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.statuslistCid != null && Object.hasOwnProperty.call(message, "statuslistCid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.statuslistCid);
                return writer;
            };

            /**
             * Encodes the specified GetThemeDevicesStatusReply message, length delimited. Does not implicitly {@link dcnet.pb.GetThemeDevicesStatusReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @static
             * @param {dcnet.pb.IGetThemeDevicesStatusReply} message GetThemeDevicesStatusReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetThemeDevicesStatusReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetThemeDevicesStatusReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetThemeDevicesStatusReply} GetThemeDevicesStatusReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeDevicesStatusReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetThemeDevicesStatusReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.statuslistCid = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetThemeDevicesStatusReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetThemeDevicesStatusReply} GetThemeDevicesStatusReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetThemeDevicesStatusReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetThemeDevicesStatusReply message.
             * @function verify
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetThemeDevicesStatusReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.statuslistCid != null && message.hasOwnProperty("statuslistCid"))
                    if (!(message.statuslistCid && typeof message.statuslistCid.length === "number" || $util.isString(message.statuslistCid)))
                        return "statuslistCid: buffer expected";
                return null;
            };

            /**
             * Creates a GetThemeDevicesStatusReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetThemeDevicesStatusReply} GetThemeDevicesStatusReply
             */
            GetThemeDevicesStatusReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetThemeDevicesStatusReply)
                    return object;
                let message = new $root.dcnet.pb.GetThemeDevicesStatusReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.statuslistCid != null)
                    if (typeof object.statuslistCid === "string")
                        $util.base64.decode(object.statuslistCid, message.statuslistCid = $util.newBuffer($util.base64.length(object.statuslistCid)), 0);
                    else if (object.statuslistCid.length >= 0)
                        message.statuslistCid = object.statuslistCid;
                return message;
            };

            /**
             * Creates a plain object from a GetThemeDevicesStatusReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @static
             * @param {dcnet.pb.GetThemeDevicesStatusReply} message GetThemeDevicesStatusReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetThemeDevicesStatusReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.statuslistCid = "";
                    else {
                        object.statuslistCid = [];
                        if (options.bytes !== Array)
                            object.statuslistCid = $util.newBuffer(object.statuslistCid);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.statuslistCid != null && message.hasOwnProperty("statuslistCid"))
                    object.statuslistCid = options.bytes === String ? $util.base64.encode(message.statuslistCid, 0, message.statuslistCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.statuslistCid) : message.statuslistCid;
                return object;
            };

            /**
             * Converts this GetThemeDevicesStatusReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetThemeDevicesStatusReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetThemeDevicesStatusReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetThemeDevicesStatusReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetThemeDevicesStatusReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetThemeDevicesStatusReply";
            };

            return GetThemeDevicesStatusReply;
        })();

        pb.GetDeviceAuthRequest = (function() {

            /**
             * Properties of a GetDeviceAuthRequest.
             * @memberof dcnet.pb
             * @interface IGetDeviceAuthRequest
             * @property {Uint8Array|null} [theme] GetDeviceAuthRequest theme
             * @property {Uint8Array|null} [appId] GetDeviceAuthRequest appId
             * @property {Uint8Array|null} [themeAuthor] GetDeviceAuthRequest themeAuthor
             */

            /**
             * Constructs a new GetDeviceAuthRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetDeviceAuthRequest.
             * @implements IGetDeviceAuthRequest
             * @constructor
             * @param {dcnet.pb.IGetDeviceAuthRequest=} [properties] Properties to set
             */
            function GetDeviceAuthRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDeviceAuthRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @instance
             */
            GetDeviceAuthRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetDeviceAuthRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @instance
             */
            GetDeviceAuthRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetDeviceAuthRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @instance
             */
            GetDeviceAuthRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * Creates a new GetDeviceAuthRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @static
             * @param {dcnet.pb.IGetDeviceAuthRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetDeviceAuthRequest} GetDeviceAuthRequest instance
             */
            GetDeviceAuthRequest.create = function create(properties) {
                return new GetDeviceAuthRequest(properties);
            };

            /**
             * Encodes the specified GetDeviceAuthRequest message. Does not implicitly {@link dcnet.pb.GetDeviceAuthRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @static
             * @param {dcnet.pb.IGetDeviceAuthRequest} message GetDeviceAuthRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceAuthRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                return writer;
            };

            /**
             * Encodes the specified GetDeviceAuthRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetDeviceAuthRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @static
             * @param {dcnet.pb.IGetDeviceAuthRequest} message GetDeviceAuthRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceAuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDeviceAuthRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetDeviceAuthRequest} GetDeviceAuthRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceAuthRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetDeviceAuthRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDeviceAuthRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetDeviceAuthRequest} GetDeviceAuthRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceAuthRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDeviceAuthRequest message.
             * @function verify
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDeviceAuthRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                return null;
            };

            /**
             * Creates a GetDeviceAuthRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetDeviceAuthRequest} GetDeviceAuthRequest
             */
            GetDeviceAuthRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetDeviceAuthRequest)
                    return object;
                let message = new $root.dcnet.pb.GetDeviceAuthRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                return message;
            };

            /**
             * Creates a plain object from a GetDeviceAuthRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @static
             * @param {dcnet.pb.GetDeviceAuthRequest} message GetDeviceAuthRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDeviceAuthRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                return object;
            };

            /**
             * Converts this GetDeviceAuthRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDeviceAuthRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDeviceAuthRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetDeviceAuthRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDeviceAuthRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetDeviceAuthRequest";
            };

            return GetDeviceAuthRequest;
        })();

        pb.GetDeviceAuthReply = (function() {

            /**
             * Properties of a GetDeviceAuthReply.
             * @memberof dcnet.pb
             * @interface IGetDeviceAuthReply
             * @property {number|null} [flag] GetDeviceAuthReply flag
             * @property {number|null} [blockheight] GetDeviceAuthReply blockheight
             * @property {Uint8Array|null} [authGroups] GetDeviceAuthReply authGroups
             * @property {Uint8Array|null} [signature] GetDeviceAuthReply signature
             */

            /**
             * Constructs a new GetDeviceAuthReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetDeviceAuthReply.
             * @implements IGetDeviceAuthReply
             * @constructor
             * @param {dcnet.pb.IGetDeviceAuthReply=} [properties] Properties to set
             */
            function GetDeviceAuthReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDeviceAuthReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @instance
             */
            GetDeviceAuthReply.prototype.flag = 0;

            /**
             * GetDeviceAuthReply blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @instance
             */
            GetDeviceAuthReply.prototype.blockheight = 0;

            /**
             * GetDeviceAuthReply authGroups.
             * @member {Uint8Array} authGroups
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @instance
             */
            GetDeviceAuthReply.prototype.authGroups = $util.newBuffer([]);

            /**
             * GetDeviceAuthReply signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @instance
             */
            GetDeviceAuthReply.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new GetDeviceAuthReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @static
             * @param {dcnet.pb.IGetDeviceAuthReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetDeviceAuthReply} GetDeviceAuthReply instance
             */
            GetDeviceAuthReply.create = function create(properties) {
                return new GetDeviceAuthReply(properties);
            };

            /**
             * Encodes the specified GetDeviceAuthReply message. Does not implicitly {@link dcnet.pb.GetDeviceAuthReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @static
             * @param {dcnet.pb.IGetDeviceAuthReply} message GetDeviceAuthReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceAuthReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.authGroups != null && Object.hasOwnProperty.call(message, "authGroups"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.authGroups);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified GetDeviceAuthReply message, length delimited. Does not implicitly {@link dcnet.pb.GetDeviceAuthReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @static
             * @param {dcnet.pb.IGetDeviceAuthReply} message GetDeviceAuthReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceAuthReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDeviceAuthReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetDeviceAuthReply} GetDeviceAuthReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceAuthReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetDeviceAuthReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.authGroups = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDeviceAuthReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetDeviceAuthReply} GetDeviceAuthReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceAuthReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDeviceAuthReply message.
             * @function verify
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDeviceAuthReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.authGroups != null && message.hasOwnProperty("authGroups"))
                    if (!(message.authGroups && typeof message.authGroups.length === "number" || $util.isString(message.authGroups)))
                        return "authGroups: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a GetDeviceAuthReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetDeviceAuthReply} GetDeviceAuthReply
             */
            GetDeviceAuthReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetDeviceAuthReply)
                    return object;
                let message = new $root.dcnet.pb.GetDeviceAuthReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.authGroups != null)
                    if (typeof object.authGroups === "string")
                        $util.base64.decode(object.authGroups, message.authGroups = $util.newBuffer($util.base64.length(object.authGroups)), 0);
                    else if (object.authGroups.length >= 0)
                        message.authGroups = object.authGroups;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a GetDeviceAuthReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @static
             * @param {dcnet.pb.GetDeviceAuthReply} message GetDeviceAuthReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDeviceAuthReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.authGroups = "";
                    else {
                        object.authGroups = [];
                        if (options.bytes !== Array)
                            object.authGroups = $util.newBuffer(object.authGroups);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.authGroups != null && message.hasOwnProperty("authGroups"))
                    object.authGroups = options.bytes === String ? $util.base64.encode(message.authGroups, 0, message.authGroups.length) : options.bytes === Array ? Array.prototype.slice.call(message.authGroups) : message.authGroups;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this GetDeviceAuthReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDeviceAuthReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDeviceAuthReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetDeviceAuthReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDeviceAuthReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetDeviceAuthReply";
            };

            return GetDeviceAuthReply;
        })();

        pb.GetDeviceStatusListRequest = (function() {

            /**
             * Properties of a GetDeviceStatusListRequest.
             * @memberof dcnet.pb
             * @interface IGetDeviceStatusListRequest
             * @property {Uint8Array|null} [theme] GetDeviceStatusListRequest theme
             * @property {Uint8Array|null} [appId] GetDeviceStatusListRequest appId
             * @property {Uint8Array|null} [deviceId] GetDeviceStatusListRequest deviceId
             * @property {Uint8Array|null} [themeAuthor] GetDeviceStatusListRequest themeAuthor
             * @property {Uint8Array|null} [UserPubkey] GetDeviceStatusListRequest UserPubkey
             * @property {number|null} [seqno] GetDeviceStatusListRequest seqno
             * @property {number|null} [startHeight] GetDeviceStatusListRequest startHeight
             * @property {number|null} [direction] GetDeviceStatusListRequest direction
             * @property {number|null} [offset] GetDeviceStatusListRequest offset
             * @property {number|null} [limit] GetDeviceStatusListRequest limit
             * @property {Uint8Array|null} [seekKey] GetDeviceStatusListRequest seekKey
             * @property {Uint8Array|null} [authgroupspermission] GetDeviceStatusListRequest authgroupspermission
             * @property {number|null} [authBlockheight] GetDeviceStatusListRequest authBlockheight
             * @property {Uint8Array|null} [authPeerid] GetDeviceStatusListRequest authPeerid
             * @property {Uint8Array|null} [authSignature] GetDeviceStatusListRequest authSignature
             */

            /**
             * Constructs a new GetDeviceStatusListRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetDeviceStatusListRequest.
             * @implements IGetDeviceStatusListRequest
             * @constructor
             * @param {dcnet.pb.IGetDeviceStatusListRequest=} [properties] Properties to set
             */
            function GetDeviceStatusListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDeviceStatusListRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetDeviceStatusListRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetDeviceStatusListRequest deviceId.
             * @member {Uint8Array} deviceId
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.deviceId = $util.newBuffer([]);

            /**
             * GetDeviceStatusListRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * GetDeviceStatusListRequest UserPubkey.
             * @member {Uint8Array} UserPubkey
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.UserPubkey = $util.newBuffer([]);

            /**
             * GetDeviceStatusListRequest seqno.
             * @member {number} seqno
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.seqno = 0;

            /**
             * GetDeviceStatusListRequest startHeight.
             * @member {number} startHeight
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.startHeight = 0;

            /**
             * GetDeviceStatusListRequest direction.
             * @member {number} direction
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.direction = 0;

            /**
             * GetDeviceStatusListRequest offset.
             * @member {number} offset
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.offset = 0;

            /**
             * GetDeviceStatusListRequest limit.
             * @member {number} limit
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.limit = 0;

            /**
             * GetDeviceStatusListRequest seekKey.
             * @member {Uint8Array} seekKey
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.seekKey = $util.newBuffer([]);

            /**
             * GetDeviceStatusListRequest authgroupspermission.
             * @member {Uint8Array} authgroupspermission
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.authgroupspermission = $util.newBuffer([]);

            /**
             * GetDeviceStatusListRequest authBlockheight.
             * @member {number} authBlockheight
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.authBlockheight = 0;

            /**
             * GetDeviceStatusListRequest authPeerid.
             * @member {Uint8Array} authPeerid
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.authPeerid = $util.newBuffer([]);

            /**
             * GetDeviceStatusListRequest authSignature.
             * @member {Uint8Array} authSignature
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             */
            GetDeviceStatusListRequest.prototype.authSignature = $util.newBuffer([]);

            /**
             * Creates a new GetDeviceStatusListRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @static
             * @param {dcnet.pb.IGetDeviceStatusListRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetDeviceStatusListRequest} GetDeviceStatusListRequest instance
             */
            GetDeviceStatusListRequest.create = function create(properties) {
                return new GetDeviceStatusListRequest(properties);
            };

            /**
             * Encodes the specified GetDeviceStatusListRequest message. Does not implicitly {@link dcnet.pb.GetDeviceStatusListRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @static
             * @param {dcnet.pb.IGetDeviceStatusListRequest} message GetDeviceStatusListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceStatusListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.deviceId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.themeAuthor);
                if (message.UserPubkey != null && Object.hasOwnProperty.call(message, "UserPubkey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.UserPubkey);
                if (message.seqno != null && Object.hasOwnProperty.call(message, "seqno"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.seqno);
                if (message.startHeight != null && Object.hasOwnProperty.call(message, "startHeight"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.startHeight);
                if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.direction);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.offset);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.limit);
                if (message.seekKey != null && Object.hasOwnProperty.call(message, "seekKey"))
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.seekKey);
                if (message.authgroupspermission != null && Object.hasOwnProperty.call(message, "authgroupspermission"))
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.authgroupspermission);
                if (message.authBlockheight != null && Object.hasOwnProperty.call(message, "authBlockheight"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.authBlockheight);
                if (message.authPeerid != null && Object.hasOwnProperty.call(message, "authPeerid"))
                    writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.authPeerid);
                if (message.authSignature != null && Object.hasOwnProperty.call(message, "authSignature"))
                    writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.authSignature);
                return writer;
            };

            /**
             * Encodes the specified GetDeviceStatusListRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetDeviceStatusListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @static
             * @param {dcnet.pb.IGetDeviceStatusListRequest} message GetDeviceStatusListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceStatusListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDeviceStatusListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetDeviceStatusListRequest} GetDeviceStatusListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceStatusListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetDeviceStatusListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.deviceId = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.UserPubkey = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.seqno = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.startHeight = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.direction = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.offset = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.limit = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.seekKey = reader.bytes();
                            break;
                        }
                    case 12: {
                            message.authgroupspermission = reader.bytes();
                            break;
                        }
                    case 13: {
                            message.authBlockheight = reader.uint32();
                            break;
                        }
                    case 14: {
                            message.authPeerid = reader.bytes();
                            break;
                        }
                    case 15: {
                            message.authSignature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDeviceStatusListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetDeviceStatusListRequest} GetDeviceStatusListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceStatusListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDeviceStatusListRequest message.
             * @function verify
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDeviceStatusListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                    if (!(message.deviceId && typeof message.deviceId.length === "number" || $util.isString(message.deviceId)))
                        return "deviceId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.UserPubkey != null && message.hasOwnProperty("UserPubkey"))
                    if (!(message.UserPubkey && typeof message.UserPubkey.length === "number" || $util.isString(message.UserPubkey)))
                        return "UserPubkey: buffer expected";
                if (message.seqno != null && message.hasOwnProperty("seqno"))
                    if (!$util.isInteger(message.seqno))
                        return "seqno: integer expected";
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    if (!$util.isInteger(message.startHeight))
                        return "startHeight: integer expected";
                if (message.direction != null && message.hasOwnProperty("direction"))
                    if (!$util.isInteger(message.direction))
                        return "direction: integer expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset))
                        return "offset: integer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    if (!(message.seekKey && typeof message.seekKey.length === "number" || $util.isString(message.seekKey)))
                        return "seekKey: buffer expected";
                if (message.authgroupspermission != null && message.hasOwnProperty("authgroupspermission"))
                    if (!(message.authgroupspermission && typeof message.authgroupspermission.length === "number" || $util.isString(message.authgroupspermission)))
                        return "authgroupspermission: buffer expected";
                if (message.authBlockheight != null && message.hasOwnProperty("authBlockheight"))
                    if (!$util.isInteger(message.authBlockheight))
                        return "authBlockheight: integer expected";
                if (message.authPeerid != null && message.hasOwnProperty("authPeerid"))
                    if (!(message.authPeerid && typeof message.authPeerid.length === "number" || $util.isString(message.authPeerid)))
                        return "authPeerid: buffer expected";
                if (message.authSignature != null && message.hasOwnProperty("authSignature"))
                    if (!(message.authSignature && typeof message.authSignature.length === "number" || $util.isString(message.authSignature)))
                        return "authSignature: buffer expected";
                return null;
            };

            /**
             * Creates a GetDeviceStatusListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetDeviceStatusListRequest} GetDeviceStatusListRequest
             */
            GetDeviceStatusListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetDeviceStatusListRequest)
                    return object;
                let message = new $root.dcnet.pb.GetDeviceStatusListRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.deviceId != null)
                    if (typeof object.deviceId === "string")
                        $util.base64.decode(object.deviceId, message.deviceId = $util.newBuffer($util.base64.length(object.deviceId)), 0);
                    else if (object.deviceId.length >= 0)
                        message.deviceId = object.deviceId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.UserPubkey != null)
                    if (typeof object.UserPubkey === "string")
                        $util.base64.decode(object.UserPubkey, message.UserPubkey = $util.newBuffer($util.base64.length(object.UserPubkey)), 0);
                    else if (object.UserPubkey.length >= 0)
                        message.UserPubkey = object.UserPubkey;
                if (object.seqno != null)
                    message.seqno = object.seqno >>> 0;
                if (object.startHeight != null)
                    message.startHeight = object.startHeight >>> 0;
                if (object.direction != null)
                    message.direction = object.direction >>> 0;
                if (object.offset != null)
                    message.offset = object.offset >>> 0;
                if (object.limit != null)
                    message.limit = object.limit >>> 0;
                if (object.seekKey != null)
                    if (typeof object.seekKey === "string")
                        $util.base64.decode(object.seekKey, message.seekKey = $util.newBuffer($util.base64.length(object.seekKey)), 0);
                    else if (object.seekKey.length >= 0)
                        message.seekKey = object.seekKey;
                if (object.authgroupspermission != null)
                    if (typeof object.authgroupspermission === "string")
                        $util.base64.decode(object.authgroupspermission, message.authgroupspermission = $util.newBuffer($util.base64.length(object.authgroupspermission)), 0);
                    else if (object.authgroupspermission.length >= 0)
                        message.authgroupspermission = object.authgroupspermission;
                if (object.authBlockheight != null)
                    message.authBlockheight = object.authBlockheight >>> 0;
                if (object.authPeerid != null)
                    if (typeof object.authPeerid === "string")
                        $util.base64.decode(object.authPeerid, message.authPeerid = $util.newBuffer($util.base64.length(object.authPeerid)), 0);
                    else if (object.authPeerid.length >= 0)
                        message.authPeerid = object.authPeerid;
                if (object.authSignature != null)
                    if (typeof object.authSignature === "string")
                        $util.base64.decode(object.authSignature, message.authSignature = $util.newBuffer($util.base64.length(object.authSignature)), 0);
                    else if (object.authSignature.length >= 0)
                        message.authSignature = object.authSignature;
                return message;
            };

            /**
             * Creates a plain object from a GetDeviceStatusListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @static
             * @param {dcnet.pb.GetDeviceStatusListRequest} message GetDeviceStatusListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDeviceStatusListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.deviceId = "";
                    else {
                        object.deviceId = [];
                        if (options.bytes !== Array)
                            object.deviceId = $util.newBuffer(object.deviceId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    if (options.bytes === String)
                        object.UserPubkey = "";
                    else {
                        object.UserPubkey = [];
                        if (options.bytes !== Array)
                            object.UserPubkey = $util.newBuffer(object.UserPubkey);
                    }
                    object.seqno = 0;
                    object.startHeight = 0;
                    object.direction = 0;
                    object.offset = 0;
                    object.limit = 0;
                    if (options.bytes === String)
                        object.seekKey = "";
                    else {
                        object.seekKey = [];
                        if (options.bytes !== Array)
                            object.seekKey = $util.newBuffer(object.seekKey);
                    }
                    if (options.bytes === String)
                        object.authgroupspermission = "";
                    else {
                        object.authgroupspermission = [];
                        if (options.bytes !== Array)
                            object.authgroupspermission = $util.newBuffer(object.authgroupspermission);
                    }
                    object.authBlockheight = 0;
                    if (options.bytes === String)
                        object.authPeerid = "";
                    else {
                        object.authPeerid = [];
                        if (options.bytes !== Array)
                            object.authPeerid = $util.newBuffer(object.authPeerid);
                    }
                    if (options.bytes === String)
                        object.authSignature = "";
                    else {
                        object.authSignature = [];
                        if (options.bytes !== Array)
                            object.authSignature = $util.newBuffer(object.authSignature);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                    object.deviceId = options.bytes === String ? $util.base64.encode(message.deviceId, 0, message.deviceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.deviceId) : message.deviceId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.UserPubkey != null && message.hasOwnProperty("UserPubkey"))
                    object.UserPubkey = options.bytes === String ? $util.base64.encode(message.UserPubkey, 0, message.UserPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.UserPubkey) : message.UserPubkey;
                if (message.seqno != null && message.hasOwnProperty("seqno"))
                    object.seqno = message.seqno;
                if (message.startHeight != null && message.hasOwnProperty("startHeight"))
                    object.startHeight = message.startHeight;
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = message.direction;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.seekKey != null && message.hasOwnProperty("seekKey"))
                    object.seekKey = options.bytes === String ? $util.base64.encode(message.seekKey, 0, message.seekKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.seekKey) : message.seekKey;
                if (message.authgroupspermission != null && message.hasOwnProperty("authgroupspermission"))
                    object.authgroupspermission = options.bytes === String ? $util.base64.encode(message.authgroupspermission, 0, message.authgroupspermission.length) : options.bytes === Array ? Array.prototype.slice.call(message.authgroupspermission) : message.authgroupspermission;
                if (message.authBlockheight != null && message.hasOwnProperty("authBlockheight"))
                    object.authBlockheight = message.authBlockheight;
                if (message.authPeerid != null && message.hasOwnProperty("authPeerid"))
                    object.authPeerid = options.bytes === String ? $util.base64.encode(message.authPeerid, 0, message.authPeerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.authPeerid) : message.authPeerid;
                if (message.authSignature != null && message.hasOwnProperty("authSignature"))
                    object.authSignature = options.bytes === String ? $util.base64.encode(message.authSignature, 0, message.authSignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.authSignature) : message.authSignature;
                return object;
            };

            /**
             * Converts this GetDeviceStatusListRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDeviceStatusListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDeviceStatusListRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetDeviceStatusListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDeviceStatusListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetDeviceStatusListRequest";
            };

            return GetDeviceStatusListRequest;
        })();

        pb.GetDeviceStatusListReply = (function() {

            /**
             * Properties of a GetDeviceStatusListReply.
             * @memberof dcnet.pb
             * @interface IGetDeviceStatusListReply
             * @property {number|null} [flag] GetDeviceStatusListReply flag
             * @property {Uint8Array|null} [statuslistCid] GetDeviceStatusListReply statuslistCid
             */

            /**
             * Constructs a new GetDeviceStatusListReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetDeviceStatusListReply.
             * @implements IGetDeviceStatusListReply
             * @constructor
             * @param {dcnet.pb.IGetDeviceStatusListReply=} [properties] Properties to set
             */
            function GetDeviceStatusListReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDeviceStatusListReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @instance
             */
            GetDeviceStatusListReply.prototype.flag = 0;

            /**
             * GetDeviceStatusListReply statuslistCid.
             * @member {Uint8Array} statuslistCid
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @instance
             */
            GetDeviceStatusListReply.prototype.statuslistCid = $util.newBuffer([]);

            /**
             * Creates a new GetDeviceStatusListReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @static
             * @param {dcnet.pb.IGetDeviceStatusListReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetDeviceStatusListReply} GetDeviceStatusListReply instance
             */
            GetDeviceStatusListReply.create = function create(properties) {
                return new GetDeviceStatusListReply(properties);
            };

            /**
             * Encodes the specified GetDeviceStatusListReply message. Does not implicitly {@link dcnet.pb.GetDeviceStatusListReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @static
             * @param {dcnet.pb.IGetDeviceStatusListReply} message GetDeviceStatusListReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceStatusListReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.statuslistCid != null && Object.hasOwnProperty.call(message, "statuslistCid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.statuslistCid);
                return writer;
            };

            /**
             * Encodes the specified GetDeviceStatusListReply message, length delimited. Does not implicitly {@link dcnet.pb.GetDeviceStatusListReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @static
             * @param {dcnet.pb.IGetDeviceStatusListReply} message GetDeviceStatusListReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceStatusListReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDeviceStatusListReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetDeviceStatusListReply} GetDeviceStatusListReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceStatusListReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetDeviceStatusListReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.statuslistCid = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDeviceStatusListReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetDeviceStatusListReply} GetDeviceStatusListReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceStatusListReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDeviceStatusListReply message.
             * @function verify
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDeviceStatusListReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.statuslistCid != null && message.hasOwnProperty("statuslistCid"))
                    if (!(message.statuslistCid && typeof message.statuslistCid.length === "number" || $util.isString(message.statuslistCid)))
                        return "statuslistCid: buffer expected";
                return null;
            };

            /**
             * Creates a GetDeviceStatusListReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetDeviceStatusListReply} GetDeviceStatusListReply
             */
            GetDeviceStatusListReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetDeviceStatusListReply)
                    return object;
                let message = new $root.dcnet.pb.GetDeviceStatusListReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.statuslistCid != null)
                    if (typeof object.statuslistCid === "string")
                        $util.base64.decode(object.statuslistCid, message.statuslistCid = $util.newBuffer($util.base64.length(object.statuslistCid)), 0);
                    else if (object.statuslistCid.length >= 0)
                        message.statuslistCid = object.statuslistCid;
                return message;
            };

            /**
             * Creates a plain object from a GetDeviceStatusListReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @static
             * @param {dcnet.pb.GetDeviceStatusListReply} message GetDeviceStatusListReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDeviceStatusListReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.statuslistCid = "";
                    else {
                        object.statuslistCid = [];
                        if (options.bytes !== Array)
                            object.statuslistCid = $util.newBuffer(object.statuslistCid);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.statuslistCid != null && message.hasOwnProperty("statuslistCid"))
                    object.statuslistCid = options.bytes === String ? $util.base64.encode(message.statuslistCid, 0, message.statuslistCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.statuslistCid) : message.statuslistCid;
                return object;
            };

            /**
             * Converts this GetDeviceStatusListReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDeviceStatusListReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDeviceStatusListReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetDeviceStatusListReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDeviceStatusListReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetDeviceStatusListReply";
            };

            return GetDeviceStatusListReply;
        })();

        pb.ReEncryptFileRequest = (function() {

            /**
             * Properties of a ReEncryptFileRequest.
             * @memberof dcnet.pb
             * @interface IReEncryptFileRequest
             * @property {Uint8Array|null} [cid] ReEncryptFileRequest cid
             * @property {Uint8Array|null} [encDecryptKey] ReEncryptFileRequest encDecryptKey
             * @property {Uint8Array|null} [encSecretkey] ReEncryptFileRequest encSecretkey
             * @property {number|null} [blockheight] ReEncryptFileRequest blockheight
             * @property {Uint8Array|null} [signature] ReEncryptFileRequest signature
             * @property {Uint8Array|null} [vaccount] ReEncryptFileRequest vaccount
             */

            /**
             * Constructs a new ReEncryptFileRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a ReEncryptFileRequest.
             * @implements IReEncryptFileRequest
             * @constructor
             * @param {dcnet.pb.IReEncryptFileRequest=} [properties] Properties to set
             */
            function ReEncryptFileRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReEncryptFileRequest cid.
             * @member {Uint8Array} cid
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @instance
             */
            ReEncryptFileRequest.prototype.cid = $util.newBuffer([]);

            /**
             * ReEncryptFileRequest encDecryptKey.
             * @member {Uint8Array} encDecryptKey
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @instance
             */
            ReEncryptFileRequest.prototype.encDecryptKey = $util.newBuffer([]);

            /**
             * ReEncryptFileRequest encSecretkey.
             * @member {Uint8Array} encSecretkey
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @instance
             */
            ReEncryptFileRequest.prototype.encSecretkey = $util.newBuffer([]);

            /**
             * ReEncryptFileRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @instance
             */
            ReEncryptFileRequest.prototype.blockheight = 0;

            /**
             * ReEncryptFileRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @instance
             */
            ReEncryptFileRequest.prototype.signature = $util.newBuffer([]);

            /**
             * ReEncryptFileRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @instance
             */
            ReEncryptFileRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new ReEncryptFileRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @static
             * @param {dcnet.pb.IReEncryptFileRequest=} [properties] Properties to set
             * @returns {dcnet.pb.ReEncryptFileRequest} ReEncryptFileRequest instance
             */
            ReEncryptFileRequest.create = function create(properties) {
                return new ReEncryptFileRequest(properties);
            };

            /**
             * Encodes the specified ReEncryptFileRequest message. Does not implicitly {@link dcnet.pb.ReEncryptFileRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @static
             * @param {dcnet.pb.IReEncryptFileRequest} message ReEncryptFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReEncryptFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cid != null && Object.hasOwnProperty.call(message, "cid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.cid);
                if (message.encDecryptKey != null && Object.hasOwnProperty.call(message, "encDecryptKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encDecryptKey);
                if (message.encSecretkey != null && Object.hasOwnProperty.call(message, "encSecretkey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encSecretkey);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockheight);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified ReEncryptFileRequest message, length delimited. Does not implicitly {@link dcnet.pb.ReEncryptFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @static
             * @param {dcnet.pb.IReEncryptFileRequest} message ReEncryptFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReEncryptFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReEncryptFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ReEncryptFileRequest} ReEncryptFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReEncryptFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ReEncryptFileRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cid = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.encDecryptKey = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.encSecretkey = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReEncryptFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ReEncryptFileRequest} ReEncryptFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReEncryptFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReEncryptFileRequest message.
             * @function verify
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReEncryptFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cid != null && message.hasOwnProperty("cid"))
                    if (!(message.cid && typeof message.cid.length === "number" || $util.isString(message.cid)))
                        return "cid: buffer expected";
                if (message.encDecryptKey != null && message.hasOwnProperty("encDecryptKey"))
                    if (!(message.encDecryptKey && typeof message.encDecryptKey.length === "number" || $util.isString(message.encDecryptKey)))
                        return "encDecryptKey: buffer expected";
                if (message.encSecretkey != null && message.hasOwnProperty("encSecretkey"))
                    if (!(message.encSecretkey && typeof message.encSecretkey.length === "number" || $util.isString(message.encSecretkey)))
                        return "encSecretkey: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a ReEncryptFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ReEncryptFileRequest} ReEncryptFileRequest
             */
            ReEncryptFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ReEncryptFileRequest)
                    return object;
                let message = new $root.dcnet.pb.ReEncryptFileRequest();
                if (object.cid != null)
                    if (typeof object.cid === "string")
                        $util.base64.decode(object.cid, message.cid = $util.newBuffer($util.base64.length(object.cid)), 0);
                    else if (object.cid.length >= 0)
                        message.cid = object.cid;
                if (object.encDecryptKey != null)
                    if (typeof object.encDecryptKey === "string")
                        $util.base64.decode(object.encDecryptKey, message.encDecryptKey = $util.newBuffer($util.base64.length(object.encDecryptKey)), 0);
                    else if (object.encDecryptKey.length >= 0)
                        message.encDecryptKey = object.encDecryptKey;
                if (object.encSecretkey != null)
                    if (typeof object.encSecretkey === "string")
                        $util.base64.decode(object.encSecretkey, message.encSecretkey = $util.newBuffer($util.base64.length(object.encSecretkey)), 0);
                    else if (object.encSecretkey.length >= 0)
                        message.encSecretkey = object.encSecretkey;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a ReEncryptFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @static
             * @param {dcnet.pb.ReEncryptFileRequest} message ReEncryptFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReEncryptFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.cid = "";
                    else {
                        object.cid = [];
                        if (options.bytes !== Array)
                            object.cid = $util.newBuffer(object.cid);
                    }
                    if (options.bytes === String)
                        object.encDecryptKey = "";
                    else {
                        object.encDecryptKey = [];
                        if (options.bytes !== Array)
                            object.encDecryptKey = $util.newBuffer(object.encDecryptKey);
                    }
                    if (options.bytes === String)
                        object.encSecretkey = "";
                    else {
                        object.encSecretkey = [];
                        if (options.bytes !== Array)
                            object.encSecretkey = $util.newBuffer(object.encSecretkey);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.cid != null && message.hasOwnProperty("cid"))
                    object.cid = options.bytes === String ? $util.base64.encode(message.cid, 0, message.cid.length) : options.bytes === Array ? Array.prototype.slice.call(message.cid) : message.cid;
                if (message.encDecryptKey != null && message.hasOwnProperty("encDecryptKey"))
                    object.encDecryptKey = options.bytes === String ? $util.base64.encode(message.encDecryptKey, 0, message.encDecryptKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encDecryptKey) : message.encDecryptKey;
                if (message.encSecretkey != null && message.hasOwnProperty("encSecretkey"))
                    object.encSecretkey = options.bytes === String ? $util.base64.encode(message.encSecretkey, 0, message.encSecretkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encSecretkey) : message.encSecretkey;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this ReEncryptFileRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReEncryptFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReEncryptFileRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.ReEncryptFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReEncryptFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ReEncryptFileRequest";
            };

            return ReEncryptFileRequest;
        })();

        pb.ReEncryptFileReply = (function() {

            /**
             * Properties of a ReEncryptFileReply.
             * @memberof dcnet.pb
             * @interface IReEncryptFileReply
             * @property {Uint8Array|null} [cid] ReEncryptFileReply cid
             * @property {number|Long|null} [fileSize] ReEncryptFileReply fileSize
             */

            /**
             * Constructs a new ReEncryptFileReply.
             * @memberof dcnet.pb
             * @classdesc Represents a ReEncryptFileReply.
             * @implements IReEncryptFileReply
             * @constructor
             * @param {dcnet.pb.IReEncryptFileReply=} [properties] Properties to set
             */
            function ReEncryptFileReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReEncryptFileReply cid.
             * @member {Uint8Array} cid
             * @memberof dcnet.pb.ReEncryptFileReply
             * @instance
             */
            ReEncryptFileReply.prototype.cid = $util.newBuffer([]);

            /**
             * ReEncryptFileReply fileSize.
             * @member {number|Long} fileSize
             * @memberof dcnet.pb.ReEncryptFileReply
             * @instance
             */
            ReEncryptFileReply.prototype.fileSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ReEncryptFileReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ReEncryptFileReply
             * @static
             * @param {dcnet.pb.IReEncryptFileReply=} [properties] Properties to set
             * @returns {dcnet.pb.ReEncryptFileReply} ReEncryptFileReply instance
             */
            ReEncryptFileReply.create = function create(properties) {
                return new ReEncryptFileReply(properties);
            };

            /**
             * Encodes the specified ReEncryptFileReply message. Does not implicitly {@link dcnet.pb.ReEncryptFileReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ReEncryptFileReply
             * @static
             * @param {dcnet.pb.IReEncryptFileReply} message ReEncryptFileReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReEncryptFileReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cid != null && Object.hasOwnProperty.call(message, "cid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.cid);
                if (message.fileSize != null && Object.hasOwnProperty.call(message, "fileSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.fileSize);
                return writer;
            };

            /**
             * Encodes the specified ReEncryptFileReply message, length delimited. Does not implicitly {@link dcnet.pb.ReEncryptFileReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ReEncryptFileReply
             * @static
             * @param {dcnet.pb.IReEncryptFileReply} message ReEncryptFileReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReEncryptFileReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReEncryptFileReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ReEncryptFileReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ReEncryptFileReply} ReEncryptFileReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReEncryptFileReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ReEncryptFileReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cid = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.fileSize = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReEncryptFileReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ReEncryptFileReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ReEncryptFileReply} ReEncryptFileReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReEncryptFileReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReEncryptFileReply message.
             * @function verify
             * @memberof dcnet.pb.ReEncryptFileReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReEncryptFileReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cid != null && message.hasOwnProperty("cid"))
                    if (!(message.cid && typeof message.cid.length === "number" || $util.isString(message.cid)))
                        return "cid: buffer expected";
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (!$util.isInteger(message.fileSize) && !(message.fileSize && $util.isInteger(message.fileSize.low) && $util.isInteger(message.fileSize.high)))
                        return "fileSize: integer|Long expected";
                return null;
            };

            /**
             * Creates a ReEncryptFileReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ReEncryptFileReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ReEncryptFileReply} ReEncryptFileReply
             */
            ReEncryptFileReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ReEncryptFileReply)
                    return object;
                let message = new $root.dcnet.pb.ReEncryptFileReply();
                if (object.cid != null)
                    if (typeof object.cid === "string")
                        $util.base64.decode(object.cid, message.cid = $util.newBuffer($util.base64.length(object.cid)), 0);
                    else if (object.cid.length >= 0)
                        message.cid = object.cid;
                if (object.fileSize != null)
                    if ($util.Long)
                        (message.fileSize = $util.Long.fromValue(object.fileSize)).unsigned = true;
                    else if (typeof object.fileSize === "string")
                        message.fileSize = parseInt(object.fileSize, 10);
                    else if (typeof object.fileSize === "number")
                        message.fileSize = object.fileSize;
                    else if (typeof object.fileSize === "object")
                        message.fileSize = new $util.LongBits(object.fileSize.low >>> 0, object.fileSize.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ReEncryptFileReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ReEncryptFileReply
             * @static
             * @param {dcnet.pb.ReEncryptFileReply} message ReEncryptFileReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReEncryptFileReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.cid = "";
                    else {
                        object.cid = [];
                        if (options.bytes !== Array)
                            object.cid = $util.newBuffer(object.cid);
                    }
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.fileSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileSize = options.longs === String ? "0" : 0;
                }
                if (message.cid != null && message.hasOwnProperty("cid"))
                    object.cid = options.bytes === String ? $util.base64.encode(message.cid, 0, message.cid.length) : options.bytes === Array ? Array.prototype.slice.call(message.cid) : message.cid;
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (typeof message.fileSize === "number")
                        object.fileSize = options.longs === String ? String(message.fileSize) : message.fileSize;
                    else
                        object.fileSize = options.longs === String ? $util.Long.prototype.toString.call(message.fileSize) : options.longs === Number ? new $util.LongBits(message.fileSize.low >>> 0, message.fileSize.high >>> 0).toNumber(true) : message.fileSize;
                return object;
            };

            /**
             * Converts this ReEncryptFileReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ReEncryptFileReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReEncryptFileReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReEncryptFileReply
             * @function getTypeUrl
             * @memberof dcnet.pb.ReEncryptFileReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReEncryptFileReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ReEncryptFileReply";
            };

            return ReEncryptFileReply;
        })();

        pb.RequestRandDataRequest = (function() {

            /**
             * Properties of a RequestRandDataRequest.
             * @memberof dcnet.pb
             * @interface IRequestRandDataRequest
             * @property {Uint8Array|null} [userPubkey] RequestRandDataRequest userPubkey
             * @property {number|null} [blockheight] RequestRandDataRequest blockheight
             * @property {Uint8Array|null} [extradata] RequestRandDataRequest extradata
             * @property {Uint8Array|null} [signature] RequestRandDataRequest signature
             */

            /**
             * Constructs a new RequestRandDataRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a RequestRandDataRequest.
             * @implements IRequestRandDataRequest
             * @constructor
             * @param {dcnet.pb.IRequestRandDataRequest=} [properties] Properties to set
             */
            function RequestRandDataRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestRandDataRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.RequestRandDataRequest
             * @instance
             */
            RequestRandDataRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * RequestRandDataRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.RequestRandDataRequest
             * @instance
             */
            RequestRandDataRequest.prototype.blockheight = 0;

            /**
             * RequestRandDataRequest extradata.
             * @member {Uint8Array} extradata
             * @memberof dcnet.pb.RequestRandDataRequest
             * @instance
             */
            RequestRandDataRequest.prototype.extradata = $util.newBuffer([]);

            /**
             * RequestRandDataRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.RequestRandDataRequest
             * @instance
             */
            RequestRandDataRequest.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new RequestRandDataRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.RequestRandDataRequest
             * @static
             * @param {dcnet.pb.IRequestRandDataRequest=} [properties] Properties to set
             * @returns {dcnet.pb.RequestRandDataRequest} RequestRandDataRequest instance
             */
            RequestRandDataRequest.create = function create(properties) {
                return new RequestRandDataRequest(properties);
            };

            /**
             * Encodes the specified RequestRandDataRequest message. Does not implicitly {@link dcnet.pb.RequestRandDataRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.RequestRandDataRequest
             * @static
             * @param {dcnet.pb.IRequestRandDataRequest} message RequestRandDataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestRandDataRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.extradata != null && Object.hasOwnProperty.call(message, "extradata"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.extradata);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified RequestRandDataRequest message, length delimited. Does not implicitly {@link dcnet.pb.RequestRandDataRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.RequestRandDataRequest
             * @static
             * @param {dcnet.pb.IRequestRandDataRequest} message RequestRandDataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestRandDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestRandDataRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.RequestRandDataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.RequestRandDataRequest} RequestRandDataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestRandDataRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.RequestRandDataRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.extradata = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestRandDataRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.RequestRandDataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.RequestRandDataRequest} RequestRandDataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestRandDataRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestRandDataRequest message.
             * @function verify
             * @memberof dcnet.pb.RequestRandDataRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestRandDataRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.extradata != null && message.hasOwnProperty("extradata"))
                    if (!(message.extradata && typeof message.extradata.length === "number" || $util.isString(message.extradata)))
                        return "extradata: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a RequestRandDataRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.RequestRandDataRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.RequestRandDataRequest} RequestRandDataRequest
             */
            RequestRandDataRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.RequestRandDataRequest)
                    return object;
                let message = new $root.dcnet.pb.RequestRandDataRequest();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.extradata != null)
                    if (typeof object.extradata === "string")
                        $util.base64.decode(object.extradata, message.extradata = $util.newBuffer($util.base64.length(object.extradata)), 0);
                    else if (object.extradata.length >= 0)
                        message.extradata = object.extradata;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a RequestRandDataRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.RequestRandDataRequest
             * @static
             * @param {dcnet.pb.RequestRandDataRequest} message RequestRandDataRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestRandDataRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.extradata = "";
                    else {
                        object.extradata = [];
                        if (options.bytes !== Array)
                            object.extradata = $util.newBuffer(object.extradata);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.extradata != null && message.hasOwnProperty("extradata"))
                    object.extradata = options.bytes === String ? $util.base64.encode(message.extradata, 0, message.extradata.length) : options.bytes === Array ? Array.prototype.slice.call(message.extradata) : message.extradata;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this RequestRandDataRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.RequestRandDataRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestRandDataRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RequestRandDataRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.RequestRandDataRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RequestRandDataRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.RequestRandDataRequest";
            };

            return RequestRandDataRequest;
        })();

        pb.RequestRandDataReply = (function() {

            /**
             * Properties of a RequestRandDataReply.
             * @memberof dcnet.pb
             * @interface IRequestRandDataReply
             * @property {Uint8Array|null} [userPubkey] RequestRandDataReply userPubkey
             * @property {Uint8Array|null} [randdata] RequestRandDataReply randdata
             * @property {number|null} [blockheight] RequestRandDataReply blockheight
             * @property {Uint8Array|null} [extradata] RequestRandDataReply extradata
             * @property {Uint8Array|null} [signature] RequestRandDataReply signature
             */

            /**
             * Constructs a new RequestRandDataReply.
             * @memberof dcnet.pb
             * @classdesc Represents a RequestRandDataReply.
             * @implements IRequestRandDataReply
             * @constructor
             * @param {dcnet.pb.IRequestRandDataReply=} [properties] Properties to set
             */
            function RequestRandDataReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestRandDataReply userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.RequestRandDataReply
             * @instance
             */
            RequestRandDataReply.prototype.userPubkey = $util.newBuffer([]);

            /**
             * RequestRandDataReply randdata.
             * @member {Uint8Array} randdata
             * @memberof dcnet.pb.RequestRandDataReply
             * @instance
             */
            RequestRandDataReply.prototype.randdata = $util.newBuffer([]);

            /**
             * RequestRandDataReply blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.RequestRandDataReply
             * @instance
             */
            RequestRandDataReply.prototype.blockheight = 0;

            /**
             * RequestRandDataReply extradata.
             * @member {Uint8Array} extradata
             * @memberof dcnet.pb.RequestRandDataReply
             * @instance
             */
            RequestRandDataReply.prototype.extradata = $util.newBuffer([]);

            /**
             * RequestRandDataReply signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.RequestRandDataReply
             * @instance
             */
            RequestRandDataReply.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new RequestRandDataReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.RequestRandDataReply
             * @static
             * @param {dcnet.pb.IRequestRandDataReply=} [properties] Properties to set
             * @returns {dcnet.pb.RequestRandDataReply} RequestRandDataReply instance
             */
            RequestRandDataReply.create = function create(properties) {
                return new RequestRandDataReply(properties);
            };

            /**
             * Encodes the specified RequestRandDataReply message. Does not implicitly {@link dcnet.pb.RequestRandDataReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.RequestRandDataReply
             * @static
             * @param {dcnet.pb.IRequestRandDataReply} message RequestRandDataReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestRandDataReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                if (message.randdata != null && Object.hasOwnProperty.call(message, "randdata"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.randdata);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.blockheight);
                if (message.extradata != null && Object.hasOwnProperty.call(message, "extradata"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.extradata);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified RequestRandDataReply message, length delimited. Does not implicitly {@link dcnet.pb.RequestRandDataReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.RequestRandDataReply
             * @static
             * @param {dcnet.pb.IRequestRandDataReply} message RequestRandDataReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestRandDataReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestRandDataReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.RequestRandDataReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.RequestRandDataReply} RequestRandDataReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestRandDataReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.RequestRandDataReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.randdata = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.extradata = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestRandDataReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.RequestRandDataReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.RequestRandDataReply} RequestRandDataReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestRandDataReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestRandDataReply message.
             * @function verify
             * @memberof dcnet.pb.RequestRandDataReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestRandDataReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.randdata != null && message.hasOwnProperty("randdata"))
                    if (!(message.randdata && typeof message.randdata.length === "number" || $util.isString(message.randdata)))
                        return "randdata: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.extradata != null && message.hasOwnProperty("extradata"))
                    if (!(message.extradata && typeof message.extradata.length === "number" || $util.isString(message.extradata)))
                        return "extradata: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a RequestRandDataReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.RequestRandDataReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.RequestRandDataReply} RequestRandDataReply
             */
            RequestRandDataReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.RequestRandDataReply)
                    return object;
                let message = new $root.dcnet.pb.RequestRandDataReply();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.randdata != null)
                    if (typeof object.randdata === "string")
                        $util.base64.decode(object.randdata, message.randdata = $util.newBuffer($util.base64.length(object.randdata)), 0);
                    else if (object.randdata.length >= 0)
                        message.randdata = object.randdata;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.extradata != null)
                    if (typeof object.extradata === "string")
                        $util.base64.decode(object.extradata, message.extradata = $util.newBuffer($util.base64.length(object.extradata)), 0);
                    else if (object.extradata.length >= 0)
                        message.extradata = object.extradata;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a RequestRandDataReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.RequestRandDataReply
             * @static
             * @param {dcnet.pb.RequestRandDataReply} message RequestRandDataReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestRandDataReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.randdata = "";
                    else {
                        object.randdata = [];
                        if (options.bytes !== Array)
                            object.randdata = $util.newBuffer(object.randdata);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.extradata = "";
                    else {
                        object.extradata = [];
                        if (options.bytes !== Array)
                            object.extradata = $util.newBuffer(object.extradata);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.randdata != null && message.hasOwnProperty("randdata"))
                    object.randdata = options.bytes === String ? $util.base64.encode(message.randdata, 0, message.randdata.length) : options.bytes === Array ? Array.prototype.slice.call(message.randdata) : message.randdata;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.extradata != null && message.hasOwnProperty("extradata"))
                    object.extradata = options.bytes === String ? $util.base64.encode(message.extradata, 0, message.extradata.length) : options.bytes === Array ? Array.prototype.slice.call(message.extradata) : message.extradata;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this RequestRandDataReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.RequestRandDataReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestRandDataReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RequestRandDataReply
             * @function getTypeUrl
             * @memberof dcnet.pb.RequestRandDataReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RequestRandDataReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.RequestRandDataReply";
            };

            return RequestRandDataReply;
        })();

        pb.DeductUserOffChainOpTimesRequest = (function() {

            /**
             * Properties of a DeductUserOffChainOpTimesRequest.
             * @memberof dcnet.pb
             * @interface IDeductUserOffChainOpTimesRequest
             * @property {Uint8Array|null} [userPubkey] DeductUserOffChainOpTimesRequest userPubkey
             * @property {number|null} [blockheight] DeductUserOffChainOpTimesRequest blockheight
             * @property {number|null} [deductType] DeductUserOffChainOpTimesRequest deductType
             * @property {Uint8Array|null} [rawReq] DeductUserOffChainOpTimesRequest rawReq
             */

            /**
             * Constructs a new DeductUserOffChainOpTimesRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a DeductUserOffChainOpTimesRequest.
             * @implements IDeductUserOffChainOpTimesRequest
             * @constructor
             * @param {dcnet.pb.IDeductUserOffChainOpTimesRequest=} [properties] Properties to set
             */
            function DeductUserOffChainOpTimesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeductUserOffChainOpTimesRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @instance
             */
            DeductUserOffChainOpTimesRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * DeductUserOffChainOpTimesRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @instance
             */
            DeductUserOffChainOpTimesRequest.prototype.blockheight = 0;

            /**
             * DeductUserOffChainOpTimesRequest deductType.
             * @member {number} deductType
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @instance
             */
            DeductUserOffChainOpTimesRequest.prototype.deductType = 0;

            /**
             * DeductUserOffChainOpTimesRequest rawReq.
             * @member {Uint8Array} rawReq
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @instance
             */
            DeductUserOffChainOpTimesRequest.prototype.rawReq = $util.newBuffer([]);

            /**
             * Creates a new DeductUserOffChainOpTimesRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.IDeductUserOffChainOpTimesRequest=} [properties] Properties to set
             * @returns {dcnet.pb.DeductUserOffChainOpTimesRequest} DeductUserOffChainOpTimesRequest instance
             */
            DeductUserOffChainOpTimesRequest.create = function create(properties) {
                return new DeductUserOffChainOpTimesRequest(properties);
            };

            /**
             * Encodes the specified DeductUserOffChainOpTimesRequest message. Does not implicitly {@link dcnet.pb.DeductUserOffChainOpTimesRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.IDeductUserOffChainOpTimesRequest} message DeductUserOffChainOpTimesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeductUserOffChainOpTimesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.deductType != null && Object.hasOwnProperty.call(message, "deductType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.deductType);
                if (message.rawReq != null && Object.hasOwnProperty.call(message, "rawReq"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.rawReq);
                return writer;
            };

            /**
             * Encodes the specified DeductUserOffChainOpTimesRequest message, length delimited. Does not implicitly {@link dcnet.pb.DeductUserOffChainOpTimesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.IDeductUserOffChainOpTimesRequest} message DeductUserOffChainOpTimesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeductUserOffChainOpTimesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeductUserOffChainOpTimesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeductUserOffChainOpTimesRequest} DeductUserOffChainOpTimesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeductUserOffChainOpTimesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeductUserOffChainOpTimesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.deductType = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.rawReq = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeductUserOffChainOpTimesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeductUserOffChainOpTimesRequest} DeductUserOffChainOpTimesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeductUserOffChainOpTimesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeductUserOffChainOpTimesRequest message.
             * @function verify
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeductUserOffChainOpTimesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.deductType != null && message.hasOwnProperty("deductType"))
                    if (!$util.isInteger(message.deductType))
                        return "deductType: integer expected";
                if (message.rawReq != null && message.hasOwnProperty("rawReq"))
                    if (!(message.rawReq && typeof message.rawReq.length === "number" || $util.isString(message.rawReq)))
                        return "rawReq: buffer expected";
                return null;
            };

            /**
             * Creates a DeductUserOffChainOpTimesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeductUserOffChainOpTimesRequest} DeductUserOffChainOpTimesRequest
             */
            DeductUserOffChainOpTimesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeductUserOffChainOpTimesRequest)
                    return object;
                let message = new $root.dcnet.pb.DeductUserOffChainOpTimesRequest();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.deductType != null)
                    message.deductType = object.deductType >>> 0;
                if (object.rawReq != null)
                    if (typeof object.rawReq === "string")
                        $util.base64.decode(object.rawReq, message.rawReq = $util.newBuffer($util.base64.length(object.rawReq)), 0);
                    else if (object.rawReq.length >= 0)
                        message.rawReq = object.rawReq;
                return message;
            };

            /**
             * Creates a plain object from a DeductUserOffChainOpTimesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.DeductUserOffChainOpTimesRequest} message DeductUserOffChainOpTimesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeductUserOffChainOpTimesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    object.blockheight = 0;
                    object.deductType = 0;
                    if (options.bytes === String)
                        object.rawReq = "";
                    else {
                        object.rawReq = [];
                        if (options.bytes !== Array)
                            object.rawReq = $util.newBuffer(object.rawReq);
                    }
                }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.deductType != null && message.hasOwnProperty("deductType"))
                    object.deductType = message.deductType;
                if (message.rawReq != null && message.hasOwnProperty("rawReq"))
                    object.rawReq = options.bytes === String ? $util.base64.encode(message.rawReq, 0, message.rawReq.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawReq) : message.rawReq;
                return object;
            };

            /**
             * Converts this DeductUserOffChainOpTimesRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeductUserOffChainOpTimesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeductUserOffChainOpTimesRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.DeductUserOffChainOpTimesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeductUserOffChainOpTimesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeductUserOffChainOpTimesRequest";
            };

            return DeductUserOffChainOpTimesRequest;
        })();

        pb.DeductUserOffChainOpTimesReply = (function() {

            /**
             * Properties of a DeductUserOffChainOpTimesReply.
             * @memberof dcnet.pb
             * @interface IDeductUserOffChainOpTimesReply
             * @property {number|null} [flag] DeductUserOffChainOpTimesReply flag
             */

            /**
             * Constructs a new DeductUserOffChainOpTimesReply.
             * @memberof dcnet.pb
             * @classdesc Represents a DeductUserOffChainOpTimesReply.
             * @implements IDeductUserOffChainOpTimesReply
             * @constructor
             * @param {dcnet.pb.IDeductUserOffChainOpTimesReply=} [properties] Properties to set
             */
            function DeductUserOffChainOpTimesReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeductUserOffChainOpTimesReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.DeductUserOffChainOpTimesReply
             * @instance
             */
            DeductUserOffChainOpTimesReply.prototype.flag = 0;

            /**
             * Creates a new DeductUserOffChainOpTimesReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeductUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.IDeductUserOffChainOpTimesReply=} [properties] Properties to set
             * @returns {dcnet.pb.DeductUserOffChainOpTimesReply} DeductUserOffChainOpTimesReply instance
             */
            DeductUserOffChainOpTimesReply.create = function create(properties) {
                return new DeductUserOffChainOpTimesReply(properties);
            };

            /**
             * Encodes the specified DeductUserOffChainOpTimesReply message. Does not implicitly {@link dcnet.pb.DeductUserOffChainOpTimesReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeductUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.IDeductUserOffChainOpTimesReply} message DeductUserOffChainOpTimesReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeductUserOffChainOpTimesReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified DeductUserOffChainOpTimesReply message, length delimited. Does not implicitly {@link dcnet.pb.DeductUserOffChainOpTimesReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeductUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.IDeductUserOffChainOpTimesReply} message DeductUserOffChainOpTimesReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeductUserOffChainOpTimesReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeductUserOffChainOpTimesReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeductUserOffChainOpTimesReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeductUserOffChainOpTimesReply} DeductUserOffChainOpTimesReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeductUserOffChainOpTimesReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeductUserOffChainOpTimesReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeductUserOffChainOpTimesReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeductUserOffChainOpTimesReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeductUserOffChainOpTimesReply} DeductUserOffChainOpTimesReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeductUserOffChainOpTimesReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeductUserOffChainOpTimesReply message.
             * @function verify
             * @memberof dcnet.pb.DeductUserOffChainOpTimesReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeductUserOffChainOpTimesReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a DeductUserOffChainOpTimesReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeductUserOffChainOpTimesReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeductUserOffChainOpTimesReply} DeductUserOffChainOpTimesReply
             */
            DeductUserOffChainOpTimesReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeductUserOffChainOpTimesReply)
                    return object;
                let message = new $root.dcnet.pb.DeductUserOffChainOpTimesReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DeductUserOffChainOpTimesReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeductUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.DeductUserOffChainOpTimesReply} message DeductUserOffChainOpTimesReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeductUserOffChainOpTimesReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this DeductUserOffChainOpTimesReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeductUserOffChainOpTimesReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeductUserOffChainOpTimesReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeductUserOffChainOpTimesReply
             * @function getTypeUrl
             * @memberof dcnet.pb.DeductUserOffChainOpTimesReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeductUserOffChainOpTimesReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeductUserOffChainOpTimesReply";
            };

            return DeductUserOffChainOpTimesReply;
        })();

        pb.DeductUserAIProxyOpTimesRequest = (function() {

            /**
             * Properties of a DeductUserAIProxyOpTimesRequest.
             * @memberof dcnet.pb
             * @interface IDeductUserAIProxyOpTimesRequest
             * @property {Uint8Array|null} [userPubkey] DeductUserAIProxyOpTimesRequest userPubkey
             * @property {Uint8Array|null} [appId] DeductUserAIProxyOpTimesRequest appId
             * @property {Uint8Array|null} [themeAuthor] DeductUserAIProxyOpTimesRequest themeAuthor
             * @property {Uint8Array|null} [theme] DeductUserAIProxyOpTimesRequest theme
             */

            /**
             * Constructs a new DeductUserAIProxyOpTimesRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a DeductUserAIProxyOpTimesRequest.
             * @implements IDeductUserAIProxyOpTimesRequest
             * @constructor
             * @param {dcnet.pb.IDeductUserAIProxyOpTimesRequest=} [properties] Properties to set
             */
            function DeductUserAIProxyOpTimesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeductUserAIProxyOpTimesRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @instance
             */
            DeductUserAIProxyOpTimesRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * DeductUserAIProxyOpTimesRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @instance
             */
            DeductUserAIProxyOpTimesRequest.prototype.appId = $util.newBuffer([]);

            /**
             * DeductUserAIProxyOpTimesRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @instance
             */
            DeductUserAIProxyOpTimesRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * DeductUserAIProxyOpTimesRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @instance
             */
            DeductUserAIProxyOpTimesRequest.prototype.theme = $util.newBuffer([]);

            /**
             * Creates a new DeductUserAIProxyOpTimesRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @static
             * @param {dcnet.pb.IDeductUserAIProxyOpTimesRequest=} [properties] Properties to set
             * @returns {dcnet.pb.DeductUserAIProxyOpTimesRequest} DeductUserAIProxyOpTimesRequest instance
             */
            DeductUserAIProxyOpTimesRequest.create = function create(properties) {
                return new DeductUserAIProxyOpTimesRequest(properties);
            };

            /**
             * Encodes the specified DeductUserAIProxyOpTimesRequest message. Does not implicitly {@link dcnet.pb.DeductUserAIProxyOpTimesRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @static
             * @param {dcnet.pb.IDeductUserAIProxyOpTimesRequest} message DeductUserAIProxyOpTimesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeductUserAIProxyOpTimesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.theme);
                return writer;
            };

            /**
             * Encodes the specified DeductUserAIProxyOpTimesRequest message, length delimited. Does not implicitly {@link dcnet.pb.DeductUserAIProxyOpTimesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @static
             * @param {dcnet.pb.IDeductUserAIProxyOpTimesRequest} message DeductUserAIProxyOpTimesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeductUserAIProxyOpTimesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeductUserAIProxyOpTimesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeductUserAIProxyOpTimesRequest} DeductUserAIProxyOpTimesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeductUserAIProxyOpTimesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeductUserAIProxyOpTimesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.theme = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeductUserAIProxyOpTimesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeductUserAIProxyOpTimesRequest} DeductUserAIProxyOpTimesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeductUserAIProxyOpTimesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeductUserAIProxyOpTimesRequest message.
             * @function verify
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeductUserAIProxyOpTimesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                return null;
            };

            /**
             * Creates a DeductUserAIProxyOpTimesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeductUserAIProxyOpTimesRequest} DeductUserAIProxyOpTimesRequest
             */
            DeductUserAIProxyOpTimesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeductUserAIProxyOpTimesRequest)
                    return object;
                let message = new $root.dcnet.pb.DeductUserAIProxyOpTimesRequest();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                return message;
            };

            /**
             * Creates a plain object from a DeductUserAIProxyOpTimesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @static
             * @param {dcnet.pb.DeductUserAIProxyOpTimesRequest} message DeductUserAIProxyOpTimesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeductUserAIProxyOpTimesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                return object;
            };

            /**
             * Converts this DeductUserAIProxyOpTimesRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeductUserAIProxyOpTimesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeductUserAIProxyOpTimesRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeductUserAIProxyOpTimesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeductUserAIProxyOpTimesRequest";
            };

            return DeductUserAIProxyOpTimesRequest;
        })();

        pb.DeductUserAIProxyOpTimesReply = (function() {

            /**
             * Properties of a DeductUserAIProxyOpTimesReply.
             * @memberof dcnet.pb
             * @interface IDeductUserAIProxyOpTimesReply
             * @property {number|null} [flag] DeductUserAIProxyOpTimesReply flag
             */

            /**
             * Constructs a new DeductUserAIProxyOpTimesReply.
             * @memberof dcnet.pb
             * @classdesc Represents a DeductUserAIProxyOpTimesReply.
             * @implements IDeductUserAIProxyOpTimesReply
             * @constructor
             * @param {dcnet.pb.IDeductUserAIProxyOpTimesReply=} [properties] Properties to set
             */
            function DeductUserAIProxyOpTimesReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeductUserAIProxyOpTimesReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesReply
             * @instance
             */
            DeductUserAIProxyOpTimesReply.prototype.flag = 0;

            /**
             * Creates a new DeductUserAIProxyOpTimesReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesReply
             * @static
             * @param {dcnet.pb.IDeductUserAIProxyOpTimesReply=} [properties] Properties to set
             * @returns {dcnet.pb.DeductUserAIProxyOpTimesReply} DeductUserAIProxyOpTimesReply instance
             */
            DeductUserAIProxyOpTimesReply.create = function create(properties) {
                return new DeductUserAIProxyOpTimesReply(properties);
            };

            /**
             * Encodes the specified DeductUserAIProxyOpTimesReply message. Does not implicitly {@link dcnet.pb.DeductUserAIProxyOpTimesReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesReply
             * @static
             * @param {dcnet.pb.IDeductUserAIProxyOpTimesReply} message DeductUserAIProxyOpTimesReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeductUserAIProxyOpTimesReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified DeductUserAIProxyOpTimesReply message, length delimited. Does not implicitly {@link dcnet.pb.DeductUserAIProxyOpTimesReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesReply
             * @static
             * @param {dcnet.pb.IDeductUserAIProxyOpTimesReply} message DeductUserAIProxyOpTimesReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeductUserAIProxyOpTimesReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeductUserAIProxyOpTimesReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DeductUserAIProxyOpTimesReply} DeductUserAIProxyOpTimesReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeductUserAIProxyOpTimesReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DeductUserAIProxyOpTimesReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeductUserAIProxyOpTimesReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DeductUserAIProxyOpTimesReply} DeductUserAIProxyOpTimesReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeductUserAIProxyOpTimesReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeductUserAIProxyOpTimesReply message.
             * @function verify
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeductUserAIProxyOpTimesReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates a DeductUserAIProxyOpTimesReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DeductUserAIProxyOpTimesReply} DeductUserAIProxyOpTimesReply
             */
            DeductUserAIProxyOpTimesReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DeductUserAIProxyOpTimesReply)
                    return object;
                let message = new $root.dcnet.pb.DeductUserAIProxyOpTimesReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DeductUserAIProxyOpTimesReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesReply
             * @static
             * @param {dcnet.pb.DeductUserAIProxyOpTimesReply} message DeductUserAIProxyOpTimesReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeductUserAIProxyOpTimesReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this DeductUserAIProxyOpTimesReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeductUserAIProxyOpTimesReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeductUserAIProxyOpTimesReply
             * @function getTypeUrl
             * @memberof dcnet.pb.DeductUserAIProxyOpTimesReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeductUserAIProxyOpTimesReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DeductUserAIProxyOpTimesReply";
            };

            return DeductUserAIProxyOpTimesReply;
        })();

        pb.GetAIProxyConfigFromPeerRequest = (function() {

            /**
             * Properties of a GetAIProxyConfigFromPeerRequest.
             * @memberof dcnet.pb
             * @interface IGetAIProxyConfigFromPeerRequest
             * @property {Uint8Array|null} [theme] GetAIProxyConfigFromPeerRequest theme
             * @property {Uint8Array|null} [appId] GetAIProxyConfigFromPeerRequest appId
             * @property {Uint8Array|null} [themeAuthor] GetAIProxyConfigFromPeerRequest themeAuthor
             * @property {Uint8Array|null} [UserPubkey] GetAIProxyConfigFromPeerRequest UserPubkey
             * @property {Uint8Array|null} [edges] GetAIProxyConfigFromPeerRequest edges
             */

            /**
             * Constructs a new GetAIProxyConfigFromPeerRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetAIProxyConfigFromPeerRequest.
             * @implements IGetAIProxyConfigFromPeerRequest
             * @constructor
             * @param {dcnet.pb.IGetAIProxyConfigFromPeerRequest=} [properties] Properties to set
             */
            function GetAIProxyConfigFromPeerRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAIProxyConfigFromPeerRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @instance
             */
            GetAIProxyConfigFromPeerRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetAIProxyConfigFromPeerRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @instance
             */
            GetAIProxyConfigFromPeerRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetAIProxyConfigFromPeerRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @instance
             */
            GetAIProxyConfigFromPeerRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * GetAIProxyConfigFromPeerRequest UserPubkey.
             * @member {Uint8Array} UserPubkey
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @instance
             */
            GetAIProxyConfigFromPeerRequest.prototype.UserPubkey = $util.newBuffer([]);

            /**
             * GetAIProxyConfigFromPeerRequest edges.
             * @member {Uint8Array} edges
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @instance
             */
            GetAIProxyConfigFromPeerRequest.prototype.edges = $util.newBuffer([]);

            /**
             * Creates a new GetAIProxyConfigFromPeerRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigFromPeerRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetAIProxyConfigFromPeerRequest} GetAIProxyConfigFromPeerRequest instance
             */
            GetAIProxyConfigFromPeerRequest.create = function create(properties) {
                return new GetAIProxyConfigFromPeerRequest(properties);
            };

            /**
             * Encodes the specified GetAIProxyConfigFromPeerRequest message. Does not implicitly {@link dcnet.pb.GetAIProxyConfigFromPeerRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigFromPeerRequest} message GetAIProxyConfigFromPeerRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAIProxyConfigFromPeerRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.UserPubkey != null && Object.hasOwnProperty.call(message, "UserPubkey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.UserPubkey);
                if (message.edges != null && Object.hasOwnProperty.call(message, "edges"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.edges);
                return writer;
            };

            /**
             * Encodes the specified GetAIProxyConfigFromPeerRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetAIProxyConfigFromPeerRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigFromPeerRequest} message GetAIProxyConfigFromPeerRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAIProxyConfigFromPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAIProxyConfigFromPeerRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetAIProxyConfigFromPeerRequest} GetAIProxyConfigFromPeerRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAIProxyConfigFromPeerRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetAIProxyConfigFromPeerRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.UserPubkey = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.edges = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAIProxyConfigFromPeerRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetAIProxyConfigFromPeerRequest} GetAIProxyConfigFromPeerRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAIProxyConfigFromPeerRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAIProxyConfigFromPeerRequest message.
             * @function verify
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAIProxyConfigFromPeerRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.UserPubkey != null && message.hasOwnProperty("UserPubkey"))
                    if (!(message.UserPubkey && typeof message.UserPubkey.length === "number" || $util.isString(message.UserPubkey)))
                        return "UserPubkey: buffer expected";
                if (message.edges != null && message.hasOwnProperty("edges"))
                    if (!(message.edges && typeof message.edges.length === "number" || $util.isString(message.edges)))
                        return "edges: buffer expected";
                return null;
            };

            /**
             * Creates a GetAIProxyConfigFromPeerRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetAIProxyConfigFromPeerRequest} GetAIProxyConfigFromPeerRequest
             */
            GetAIProxyConfigFromPeerRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetAIProxyConfigFromPeerRequest)
                    return object;
                let message = new $root.dcnet.pb.GetAIProxyConfigFromPeerRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.UserPubkey != null)
                    if (typeof object.UserPubkey === "string")
                        $util.base64.decode(object.UserPubkey, message.UserPubkey = $util.newBuffer($util.base64.length(object.UserPubkey)), 0);
                    else if (object.UserPubkey.length >= 0)
                        message.UserPubkey = object.UserPubkey;
                if (object.edges != null)
                    if (typeof object.edges === "string")
                        $util.base64.decode(object.edges, message.edges = $util.newBuffer($util.base64.length(object.edges)), 0);
                    else if (object.edges.length >= 0)
                        message.edges = object.edges;
                return message;
            };

            /**
             * Creates a plain object from a GetAIProxyConfigFromPeerRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @static
             * @param {dcnet.pb.GetAIProxyConfigFromPeerRequest} message GetAIProxyConfigFromPeerRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAIProxyConfigFromPeerRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    if (options.bytes === String)
                        object.UserPubkey = "";
                    else {
                        object.UserPubkey = [];
                        if (options.bytes !== Array)
                            object.UserPubkey = $util.newBuffer(object.UserPubkey);
                    }
                    if (options.bytes === String)
                        object.edges = "";
                    else {
                        object.edges = [];
                        if (options.bytes !== Array)
                            object.edges = $util.newBuffer(object.edges);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.UserPubkey != null && message.hasOwnProperty("UserPubkey"))
                    object.UserPubkey = options.bytes === String ? $util.base64.encode(message.UserPubkey, 0, message.UserPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.UserPubkey) : message.UserPubkey;
                if (message.edges != null && message.hasOwnProperty("edges"))
                    object.edges = options.bytes === String ? $util.base64.encode(message.edges, 0, message.edges.length) : options.bytes === Array ? Array.prototype.slice.call(message.edges) : message.edges;
                return object;
            };

            /**
             * Converts this GetAIProxyConfigFromPeerRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAIProxyConfigFromPeerRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAIProxyConfigFromPeerRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAIProxyConfigFromPeerRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetAIProxyConfigFromPeerRequest";
            };

            return GetAIProxyConfigFromPeerRequest;
        })();

        pb.GetAIProxyConfigFromPeerReply = (function() {

            /**
             * Properties of a GetAIProxyConfigFromPeerReply.
             * @memberof dcnet.pb
             * @interface IGetAIProxyConfigFromPeerReply
             * @property {number|null} [flag] GetAIProxyConfigFromPeerReply flag
             * @property {Uint8Array|null} [configInfo] GetAIProxyConfigFromPeerReply configInfo
             * @property {Uint8Array|null} [edges] GetAIProxyConfigFromPeerReply edges
             */

            /**
             * Constructs a new GetAIProxyConfigFromPeerReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetAIProxyConfigFromPeerReply.
             * @implements IGetAIProxyConfigFromPeerReply
             * @constructor
             * @param {dcnet.pb.IGetAIProxyConfigFromPeerReply=} [properties] Properties to set
             */
            function GetAIProxyConfigFromPeerReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAIProxyConfigFromPeerReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @instance
             */
            GetAIProxyConfigFromPeerReply.prototype.flag = 0;

            /**
             * GetAIProxyConfigFromPeerReply configInfo.
             * @member {Uint8Array} configInfo
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @instance
             */
            GetAIProxyConfigFromPeerReply.prototype.configInfo = $util.newBuffer([]);

            /**
             * GetAIProxyConfigFromPeerReply edges.
             * @member {Uint8Array} edges
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @instance
             */
            GetAIProxyConfigFromPeerReply.prototype.edges = $util.newBuffer([]);

            /**
             * Creates a new GetAIProxyConfigFromPeerReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigFromPeerReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetAIProxyConfigFromPeerReply} GetAIProxyConfigFromPeerReply instance
             */
            GetAIProxyConfigFromPeerReply.create = function create(properties) {
                return new GetAIProxyConfigFromPeerReply(properties);
            };

            /**
             * Encodes the specified GetAIProxyConfigFromPeerReply message. Does not implicitly {@link dcnet.pb.GetAIProxyConfigFromPeerReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigFromPeerReply} message GetAIProxyConfigFromPeerReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAIProxyConfigFromPeerReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.configInfo != null && Object.hasOwnProperty.call(message, "configInfo"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.configInfo);
                if (message.edges != null && Object.hasOwnProperty.call(message, "edges"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.edges);
                return writer;
            };

            /**
             * Encodes the specified GetAIProxyConfigFromPeerReply message, length delimited. Does not implicitly {@link dcnet.pb.GetAIProxyConfigFromPeerReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigFromPeerReply} message GetAIProxyConfigFromPeerReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAIProxyConfigFromPeerReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAIProxyConfigFromPeerReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetAIProxyConfigFromPeerReply} GetAIProxyConfigFromPeerReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAIProxyConfigFromPeerReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetAIProxyConfigFromPeerReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.configInfo = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.edges = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAIProxyConfigFromPeerReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetAIProxyConfigFromPeerReply} GetAIProxyConfigFromPeerReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAIProxyConfigFromPeerReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAIProxyConfigFromPeerReply message.
             * @function verify
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAIProxyConfigFromPeerReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.configInfo != null && message.hasOwnProperty("configInfo"))
                    if (!(message.configInfo && typeof message.configInfo.length === "number" || $util.isString(message.configInfo)))
                        return "configInfo: buffer expected";
                if (message.edges != null && message.hasOwnProperty("edges"))
                    if (!(message.edges && typeof message.edges.length === "number" || $util.isString(message.edges)))
                        return "edges: buffer expected";
                return null;
            };

            /**
             * Creates a GetAIProxyConfigFromPeerReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetAIProxyConfigFromPeerReply} GetAIProxyConfigFromPeerReply
             */
            GetAIProxyConfigFromPeerReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetAIProxyConfigFromPeerReply)
                    return object;
                let message = new $root.dcnet.pb.GetAIProxyConfigFromPeerReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.configInfo != null)
                    if (typeof object.configInfo === "string")
                        $util.base64.decode(object.configInfo, message.configInfo = $util.newBuffer($util.base64.length(object.configInfo)), 0);
                    else if (object.configInfo.length >= 0)
                        message.configInfo = object.configInfo;
                if (object.edges != null)
                    if (typeof object.edges === "string")
                        $util.base64.decode(object.edges, message.edges = $util.newBuffer($util.base64.length(object.edges)), 0);
                    else if (object.edges.length >= 0)
                        message.edges = object.edges;
                return message;
            };

            /**
             * Creates a plain object from a GetAIProxyConfigFromPeerReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @static
             * @param {dcnet.pb.GetAIProxyConfigFromPeerReply} message GetAIProxyConfigFromPeerReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAIProxyConfigFromPeerReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.configInfo = "";
                    else {
                        object.configInfo = [];
                        if (options.bytes !== Array)
                            object.configInfo = $util.newBuffer(object.configInfo);
                    }
                    if (options.bytes === String)
                        object.edges = "";
                    else {
                        object.edges = [];
                        if (options.bytes !== Array)
                            object.edges = $util.newBuffer(object.edges);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.configInfo != null && message.hasOwnProperty("configInfo"))
                    object.configInfo = options.bytes === String ? $util.base64.encode(message.configInfo, 0, message.configInfo.length) : options.bytes === Array ? Array.prototype.slice.call(message.configInfo) : message.configInfo;
                if (message.edges != null && message.hasOwnProperty("edges"))
                    object.edges = options.bytes === String ? $util.base64.encode(message.edges, 0, message.edges.length) : options.bytes === Array ? Array.prototype.slice.call(message.edges) : message.edges;
                return object;
            };

            /**
             * Converts this GetAIProxyConfigFromPeerReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAIProxyConfigFromPeerReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAIProxyConfigFromPeerReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetAIProxyConfigFromPeerReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAIProxyConfigFromPeerReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetAIProxyConfigFromPeerReply";
            };

            return GetAIProxyConfigFromPeerReply;
        })();

        pb.GetAIProxyConfigRequest = (function() {

            /**
             * Properties of a GetAIProxyConfigRequest.
             * @memberof dcnet.pb
             * @interface IGetAIProxyConfigRequest
             * @property {Uint8Array|null} [theme] GetAIProxyConfigRequest theme
             * @property {Uint8Array|null} [appId] GetAIProxyConfigRequest appId
             * @property {Uint8Array|null} [themeAuthor] GetAIProxyConfigRequest themeAuthor
             * @property {number|null} [blockheight] GetAIProxyConfigRequest blockheight
             * @property {Uint8Array|null} [signature] GetAIProxyConfigRequest signature
             */

            /**
             * Constructs a new GetAIProxyConfigRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetAIProxyConfigRequest.
             * @implements IGetAIProxyConfigRequest
             * @constructor
             * @param {dcnet.pb.IGetAIProxyConfigRequest=} [properties] Properties to set
             */
            function GetAIProxyConfigRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAIProxyConfigRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @instance
             */
            GetAIProxyConfigRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetAIProxyConfigRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @instance
             */
            GetAIProxyConfigRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetAIProxyConfigRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @instance
             */
            GetAIProxyConfigRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * GetAIProxyConfigRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @instance
             */
            GetAIProxyConfigRequest.prototype.blockheight = 0;

            /**
             * GetAIProxyConfigRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @instance
             */
            GetAIProxyConfigRequest.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new GetAIProxyConfigRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetAIProxyConfigRequest} GetAIProxyConfigRequest instance
             */
            GetAIProxyConfigRequest.create = function create(properties) {
                return new GetAIProxyConfigRequest(properties);
            };

            /**
             * Encodes the specified GetAIProxyConfigRequest message. Does not implicitly {@link dcnet.pb.GetAIProxyConfigRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigRequest} message GetAIProxyConfigRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAIProxyConfigRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockheight);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified GetAIProxyConfigRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetAIProxyConfigRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigRequest} message GetAIProxyConfigRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAIProxyConfigRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAIProxyConfigRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetAIProxyConfigRequest} GetAIProxyConfigRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAIProxyConfigRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetAIProxyConfigRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAIProxyConfigRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetAIProxyConfigRequest} GetAIProxyConfigRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAIProxyConfigRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAIProxyConfigRequest message.
             * @function verify
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAIProxyConfigRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a GetAIProxyConfigRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetAIProxyConfigRequest} GetAIProxyConfigRequest
             */
            GetAIProxyConfigRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetAIProxyConfigRequest)
                    return object;
                let message = new $root.dcnet.pb.GetAIProxyConfigRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a GetAIProxyConfigRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @static
             * @param {dcnet.pb.GetAIProxyConfigRequest} message GetAIProxyConfigRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAIProxyConfigRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this GetAIProxyConfigRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAIProxyConfigRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAIProxyConfigRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetAIProxyConfigRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAIProxyConfigRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetAIProxyConfigRequest";
            };

            return GetAIProxyConfigRequest;
        })();

        pb.GetAIProxyConfigReply = (function() {

            /**
             * Properties of a GetAIProxyConfigReply.
             * @memberof dcnet.pb
             * @interface IGetAIProxyConfigReply
             * @property {number|null} [flag] GetAIProxyConfigReply flag
             * @property {Uint8Array|null} [proxyConfigCid] GetAIProxyConfigReply proxyConfigCid
             * @property {Uint8Array|null} [aeskey] GetAIProxyConfigReply aeskey
             */

            /**
             * Constructs a new GetAIProxyConfigReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetAIProxyConfigReply.
             * @implements IGetAIProxyConfigReply
             * @constructor
             * @param {dcnet.pb.IGetAIProxyConfigReply=} [properties] Properties to set
             */
            function GetAIProxyConfigReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAIProxyConfigReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @instance
             */
            GetAIProxyConfigReply.prototype.flag = 0;

            /**
             * GetAIProxyConfigReply proxyConfigCid.
             * @member {Uint8Array} proxyConfigCid
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @instance
             */
            GetAIProxyConfigReply.prototype.proxyConfigCid = $util.newBuffer([]);

            /**
             * GetAIProxyConfigReply aeskey.
             * @member {Uint8Array} aeskey
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @instance
             */
            GetAIProxyConfigReply.prototype.aeskey = $util.newBuffer([]);

            /**
             * Creates a new GetAIProxyConfigReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetAIProxyConfigReply} GetAIProxyConfigReply instance
             */
            GetAIProxyConfigReply.create = function create(properties) {
                return new GetAIProxyConfigReply(properties);
            };

            /**
             * Encodes the specified GetAIProxyConfigReply message. Does not implicitly {@link dcnet.pb.GetAIProxyConfigReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigReply} message GetAIProxyConfigReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAIProxyConfigReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.proxyConfigCid != null && Object.hasOwnProperty.call(message, "proxyConfigCid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.proxyConfigCid);
                if (message.aeskey != null && Object.hasOwnProperty.call(message, "aeskey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.aeskey);
                return writer;
            };

            /**
             * Encodes the specified GetAIProxyConfigReply message, length delimited. Does not implicitly {@link dcnet.pb.GetAIProxyConfigReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @static
             * @param {dcnet.pb.IGetAIProxyConfigReply} message GetAIProxyConfigReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAIProxyConfigReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAIProxyConfigReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetAIProxyConfigReply} GetAIProxyConfigReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAIProxyConfigReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetAIProxyConfigReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.proxyConfigCid = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.aeskey = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAIProxyConfigReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetAIProxyConfigReply} GetAIProxyConfigReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAIProxyConfigReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAIProxyConfigReply message.
             * @function verify
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAIProxyConfigReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.proxyConfigCid != null && message.hasOwnProperty("proxyConfigCid"))
                    if (!(message.proxyConfigCid && typeof message.proxyConfigCid.length === "number" || $util.isString(message.proxyConfigCid)))
                        return "proxyConfigCid: buffer expected";
                if (message.aeskey != null && message.hasOwnProperty("aeskey"))
                    if (!(message.aeskey && typeof message.aeskey.length === "number" || $util.isString(message.aeskey)))
                        return "aeskey: buffer expected";
                return null;
            };

            /**
             * Creates a GetAIProxyConfigReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetAIProxyConfigReply} GetAIProxyConfigReply
             */
            GetAIProxyConfigReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetAIProxyConfigReply)
                    return object;
                let message = new $root.dcnet.pb.GetAIProxyConfigReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.proxyConfigCid != null)
                    if (typeof object.proxyConfigCid === "string")
                        $util.base64.decode(object.proxyConfigCid, message.proxyConfigCid = $util.newBuffer($util.base64.length(object.proxyConfigCid)), 0);
                    else if (object.proxyConfigCid.length >= 0)
                        message.proxyConfigCid = object.proxyConfigCid;
                if (object.aeskey != null)
                    if (typeof object.aeskey === "string")
                        $util.base64.decode(object.aeskey, message.aeskey = $util.newBuffer($util.base64.length(object.aeskey)), 0);
                    else if (object.aeskey.length >= 0)
                        message.aeskey = object.aeskey;
                return message;
            };

            /**
             * Creates a plain object from a GetAIProxyConfigReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @static
             * @param {dcnet.pb.GetAIProxyConfigReply} message GetAIProxyConfigReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAIProxyConfigReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.proxyConfigCid = "";
                    else {
                        object.proxyConfigCid = [];
                        if (options.bytes !== Array)
                            object.proxyConfigCid = $util.newBuffer(object.proxyConfigCid);
                    }
                    if (options.bytes === String)
                        object.aeskey = "";
                    else {
                        object.aeskey = [];
                        if (options.bytes !== Array)
                            object.aeskey = $util.newBuffer(object.aeskey);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.proxyConfigCid != null && message.hasOwnProperty("proxyConfigCid"))
                    object.proxyConfigCid = options.bytes === String ? $util.base64.encode(message.proxyConfigCid, 0, message.proxyConfigCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.proxyConfigCid) : message.proxyConfigCid;
                if (message.aeskey != null && message.hasOwnProperty("aeskey"))
                    object.aeskey = options.bytes === String ? $util.base64.encode(message.aeskey, 0, message.aeskey.length) : options.bytes === Array ? Array.prototype.slice.call(message.aeskey) : message.aeskey;
                return object;
            };

            /**
             * Converts this GetAIProxyConfigReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAIProxyConfigReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAIProxyConfigReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetAIProxyConfigReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAIProxyConfigReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetAIProxyConfigReply";
            };

            return GetAIProxyConfigReply;
        })();

        pb.GetUserOwnAIProxyAuthRequest = (function() {

            /**
             * Properties of a GetUserOwnAIProxyAuthRequest.
             * @memberof dcnet.pb
             * @interface IGetUserOwnAIProxyAuthRequest
             * @property {Uint8Array|null} [theme] GetUserOwnAIProxyAuthRequest theme
             * @property {Uint8Array|null} [appId] GetUserOwnAIProxyAuthRequest appId
             * @property {Uint8Array|null} [themeAuthor] GetUserOwnAIProxyAuthRequest themeAuthor
             * @property {number|null} [blockheight] GetUserOwnAIProxyAuthRequest blockheight
             * @property {Uint8Array|null} [signature] GetUserOwnAIProxyAuthRequest signature
             */

            /**
             * Constructs a new GetUserOwnAIProxyAuthRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetUserOwnAIProxyAuthRequest.
             * @implements IGetUserOwnAIProxyAuthRequest
             * @constructor
             * @param {dcnet.pb.IGetUserOwnAIProxyAuthRequest=} [properties] Properties to set
             */
            function GetUserOwnAIProxyAuthRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUserOwnAIProxyAuthRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @instance
             */
            GetUserOwnAIProxyAuthRequest.prototype.theme = $util.newBuffer([]);

            /**
             * GetUserOwnAIProxyAuthRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @instance
             */
            GetUserOwnAIProxyAuthRequest.prototype.appId = $util.newBuffer([]);

            /**
             * GetUserOwnAIProxyAuthRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @instance
             */
            GetUserOwnAIProxyAuthRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * GetUserOwnAIProxyAuthRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @instance
             */
            GetUserOwnAIProxyAuthRequest.prototype.blockheight = 0;

            /**
             * GetUserOwnAIProxyAuthRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @instance
             */
            GetUserOwnAIProxyAuthRequest.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new GetUserOwnAIProxyAuthRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @static
             * @param {dcnet.pb.IGetUserOwnAIProxyAuthRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetUserOwnAIProxyAuthRequest} GetUserOwnAIProxyAuthRequest instance
             */
            GetUserOwnAIProxyAuthRequest.create = function create(properties) {
                return new GetUserOwnAIProxyAuthRequest(properties);
            };

            /**
             * Encodes the specified GetUserOwnAIProxyAuthRequest message. Does not implicitly {@link dcnet.pb.GetUserOwnAIProxyAuthRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @static
             * @param {dcnet.pb.IGetUserOwnAIProxyAuthRequest} message GetUserOwnAIProxyAuthRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOwnAIProxyAuthRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockheight);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified GetUserOwnAIProxyAuthRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetUserOwnAIProxyAuthRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @static
             * @param {dcnet.pb.IGetUserOwnAIProxyAuthRequest} message GetUserOwnAIProxyAuthRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOwnAIProxyAuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUserOwnAIProxyAuthRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetUserOwnAIProxyAuthRequest} GetUserOwnAIProxyAuthRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOwnAIProxyAuthRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetUserOwnAIProxyAuthRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUserOwnAIProxyAuthRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetUserOwnAIProxyAuthRequest} GetUserOwnAIProxyAuthRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOwnAIProxyAuthRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUserOwnAIProxyAuthRequest message.
             * @function verify
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUserOwnAIProxyAuthRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a GetUserOwnAIProxyAuthRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetUserOwnAIProxyAuthRequest} GetUserOwnAIProxyAuthRequest
             */
            GetUserOwnAIProxyAuthRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetUserOwnAIProxyAuthRequest)
                    return object;
                let message = new $root.dcnet.pb.GetUserOwnAIProxyAuthRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a GetUserOwnAIProxyAuthRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @static
             * @param {dcnet.pb.GetUserOwnAIProxyAuthRequest} message GetUserOwnAIProxyAuthRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUserOwnAIProxyAuthRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this GetUserOwnAIProxyAuthRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUserOwnAIProxyAuthRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUserOwnAIProxyAuthRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUserOwnAIProxyAuthRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetUserOwnAIProxyAuthRequest";
            };

            return GetUserOwnAIProxyAuthRequest;
        })();

        pb.GetUserOwnAIProxyAuthReply = (function() {

            /**
             * Properties of a GetUserOwnAIProxyAuthReply.
             * @memberof dcnet.pb
             * @interface IGetUserOwnAIProxyAuthReply
             * @property {number|null} [flag] GetUserOwnAIProxyAuthReply flag
             * @property {Uint8Array|null} [authInfo] GetUserOwnAIProxyAuthReply authInfo
             * @property {Uint8Array|null} [configs] GetUserOwnAIProxyAuthReply configs
             */

            /**
             * Constructs a new GetUserOwnAIProxyAuthReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetUserOwnAIProxyAuthReply.
             * @implements IGetUserOwnAIProxyAuthReply
             * @constructor
             * @param {dcnet.pb.IGetUserOwnAIProxyAuthReply=} [properties] Properties to set
             */
            function GetUserOwnAIProxyAuthReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUserOwnAIProxyAuthReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @instance
             */
            GetUserOwnAIProxyAuthReply.prototype.flag = 0;

            /**
             * GetUserOwnAIProxyAuthReply authInfo.
             * @member {Uint8Array} authInfo
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @instance
             */
            GetUserOwnAIProxyAuthReply.prototype.authInfo = $util.newBuffer([]);

            /**
             * GetUserOwnAIProxyAuthReply configs.
             * @member {Uint8Array} configs
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @instance
             */
            GetUserOwnAIProxyAuthReply.prototype.configs = $util.newBuffer([]);

            /**
             * Creates a new GetUserOwnAIProxyAuthReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @static
             * @param {dcnet.pb.IGetUserOwnAIProxyAuthReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetUserOwnAIProxyAuthReply} GetUserOwnAIProxyAuthReply instance
             */
            GetUserOwnAIProxyAuthReply.create = function create(properties) {
                return new GetUserOwnAIProxyAuthReply(properties);
            };

            /**
             * Encodes the specified GetUserOwnAIProxyAuthReply message. Does not implicitly {@link dcnet.pb.GetUserOwnAIProxyAuthReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @static
             * @param {dcnet.pb.IGetUserOwnAIProxyAuthReply} message GetUserOwnAIProxyAuthReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOwnAIProxyAuthReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.authInfo != null && Object.hasOwnProperty.call(message, "authInfo"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.authInfo);
                if (message.configs != null && Object.hasOwnProperty.call(message, "configs"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.configs);
                return writer;
            };

            /**
             * Encodes the specified GetUserOwnAIProxyAuthReply message, length delimited. Does not implicitly {@link dcnet.pb.GetUserOwnAIProxyAuthReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @static
             * @param {dcnet.pb.IGetUserOwnAIProxyAuthReply} message GetUserOwnAIProxyAuthReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOwnAIProxyAuthReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUserOwnAIProxyAuthReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetUserOwnAIProxyAuthReply} GetUserOwnAIProxyAuthReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOwnAIProxyAuthReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetUserOwnAIProxyAuthReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.authInfo = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.configs = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUserOwnAIProxyAuthReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetUserOwnAIProxyAuthReply} GetUserOwnAIProxyAuthReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOwnAIProxyAuthReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUserOwnAIProxyAuthReply message.
             * @function verify
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUserOwnAIProxyAuthReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.authInfo != null && message.hasOwnProperty("authInfo"))
                    if (!(message.authInfo && typeof message.authInfo.length === "number" || $util.isString(message.authInfo)))
                        return "authInfo: buffer expected";
                if (message.configs != null && message.hasOwnProperty("configs"))
                    if (!(message.configs && typeof message.configs.length === "number" || $util.isString(message.configs)))
                        return "configs: buffer expected";
                return null;
            };

            /**
             * Creates a GetUserOwnAIProxyAuthReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetUserOwnAIProxyAuthReply} GetUserOwnAIProxyAuthReply
             */
            GetUserOwnAIProxyAuthReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetUserOwnAIProxyAuthReply)
                    return object;
                let message = new $root.dcnet.pb.GetUserOwnAIProxyAuthReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.authInfo != null)
                    if (typeof object.authInfo === "string")
                        $util.base64.decode(object.authInfo, message.authInfo = $util.newBuffer($util.base64.length(object.authInfo)), 0);
                    else if (object.authInfo.length >= 0)
                        message.authInfo = object.authInfo;
                if (object.configs != null)
                    if (typeof object.configs === "string")
                        $util.base64.decode(object.configs, message.configs = $util.newBuffer($util.base64.length(object.configs)), 0);
                    else if (object.configs.length >= 0)
                        message.configs = object.configs;
                return message;
            };

            /**
             * Creates a plain object from a GetUserOwnAIProxyAuthReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @static
             * @param {dcnet.pb.GetUserOwnAIProxyAuthReply} message GetUserOwnAIProxyAuthReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUserOwnAIProxyAuthReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.authInfo = "";
                    else {
                        object.authInfo = [];
                        if (options.bytes !== Array)
                            object.authInfo = $util.newBuffer(object.authInfo);
                    }
                    if (options.bytes === String)
                        object.configs = "";
                    else {
                        object.configs = [];
                        if (options.bytes !== Array)
                            object.configs = $util.newBuffer(object.configs);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.authInfo != null && message.hasOwnProperty("authInfo"))
                    object.authInfo = options.bytes === String ? $util.base64.encode(message.authInfo, 0, message.authInfo.length) : options.bytes === Array ? Array.prototype.slice.call(message.authInfo) : message.authInfo;
                if (message.configs != null && message.hasOwnProperty("configs"))
                    object.configs = options.bytes === String ? $util.base64.encode(message.configs, 0, message.configs.length) : options.bytes === Array ? Array.prototype.slice.call(message.configs) : message.configs;
                return object;
            };

            /**
             * Converts this GetUserOwnAIProxyAuthReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUserOwnAIProxyAuthReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUserOwnAIProxyAuthReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetUserOwnAIProxyAuthReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUserOwnAIProxyAuthReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetUserOwnAIProxyAuthReply";
            };

            return GetUserOwnAIProxyAuthReply;
        })();

        pb.DoAIProxyCallRequest = (function() {

            /**
             * Properties of a DoAIProxyCallRequest.
             * @memberof dcnet.pb
             * @interface IDoAIProxyCallRequest
             * @property {Uint8Array|null} [theme] DoAIProxyCallRequest theme
             * @property {Uint8Array|null} [appId] DoAIProxyCallRequest appId
             * @property {Uint8Array|null} [themeAuthor] DoAIProxyCallRequest themeAuthor
             * @property {number|null} [blockheight] DoAIProxyCallRequest blockheight
             * @property {Uint8Array|null} [configKey] DoAIProxyCallRequest configKey
             * @property {Uint8Array|null} [path] DoAIProxyCallRequest path
             * @property {Uint8Array|null} [reqBody] DoAIProxyCallRequest reqBody
             * @property {Uint8Array|null} [modelConfig] DoAIProxyCallRequest modelConfig
             * @property {number|null} [forceRefresh] DoAIProxyCallRequest forceRefresh
             * @property {Uint8Array|null} [headers] DoAIProxyCallRequest headers
             * @property {Uint8Array|null} [signature] DoAIProxyCallRequest signature
             */

            /**
             * Constructs a new DoAIProxyCallRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a DoAIProxyCallRequest.
             * @implements IDoAIProxyCallRequest
             * @constructor
             * @param {dcnet.pb.IDoAIProxyCallRequest=} [properties] Properties to set
             */
            function DoAIProxyCallRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DoAIProxyCallRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             */
            DoAIProxyCallRequest.prototype.theme = $util.newBuffer([]);

            /**
             * DoAIProxyCallRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             */
            DoAIProxyCallRequest.prototype.appId = $util.newBuffer([]);

            /**
             * DoAIProxyCallRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             */
            DoAIProxyCallRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * DoAIProxyCallRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             */
            DoAIProxyCallRequest.prototype.blockheight = 0;

            /**
             * DoAIProxyCallRequest configKey.
             * @member {Uint8Array} configKey
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             */
            DoAIProxyCallRequest.prototype.configKey = $util.newBuffer([]);

            /**
             * DoAIProxyCallRequest path.
             * @member {Uint8Array} path
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             */
            DoAIProxyCallRequest.prototype.path = $util.newBuffer([]);

            /**
             * DoAIProxyCallRequest reqBody.
             * @member {Uint8Array} reqBody
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             */
            DoAIProxyCallRequest.prototype.reqBody = $util.newBuffer([]);

            /**
             * DoAIProxyCallRequest modelConfig.
             * @member {Uint8Array} modelConfig
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             */
            DoAIProxyCallRequest.prototype.modelConfig = $util.newBuffer([]);

            /**
             * DoAIProxyCallRequest forceRefresh.
             * @member {number} forceRefresh
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             */
            DoAIProxyCallRequest.prototype.forceRefresh = 0;

            /**
             * DoAIProxyCallRequest headers.
             * @member {Uint8Array} headers
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             */
            DoAIProxyCallRequest.prototype.headers = $util.newBuffer([]);

            /**
             * DoAIProxyCallRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             */
            DoAIProxyCallRequest.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new DoAIProxyCallRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @static
             * @param {dcnet.pb.IDoAIProxyCallRequest=} [properties] Properties to set
             * @returns {dcnet.pb.DoAIProxyCallRequest} DoAIProxyCallRequest instance
             */
            DoAIProxyCallRequest.create = function create(properties) {
                return new DoAIProxyCallRequest(properties);
            };

            /**
             * Encodes the specified DoAIProxyCallRequest message. Does not implicitly {@link dcnet.pb.DoAIProxyCallRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @static
             * @param {dcnet.pb.IDoAIProxyCallRequest} message DoAIProxyCallRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoAIProxyCallRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.appId);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.themeAuthor);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.blockheight);
                if (message.configKey != null && Object.hasOwnProperty.call(message, "configKey"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.configKey);
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.path);
                if (message.reqBody != null && Object.hasOwnProperty.call(message, "reqBody"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.reqBody);
                if (message.modelConfig != null && Object.hasOwnProperty.call(message, "modelConfig"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.modelConfig);
                if (message.forceRefresh != null && Object.hasOwnProperty.call(message, "forceRefresh"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.forceRefresh);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.headers);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified DoAIProxyCallRequest message, length delimited. Does not implicitly {@link dcnet.pb.DoAIProxyCallRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @static
             * @param {dcnet.pb.IDoAIProxyCallRequest} message DoAIProxyCallRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoAIProxyCallRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DoAIProxyCallRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DoAIProxyCallRequest} DoAIProxyCallRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoAIProxyCallRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DoAIProxyCallRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.configKey = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.path = reader.bytes();
                            break;
                        }
                    case 7: {
                            message.reqBody = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.modelConfig = reader.bytes();
                            break;
                        }
                    case 9: {
                            message.forceRefresh = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.headers = reader.bytes();
                            break;
                        }
                    case 11: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DoAIProxyCallRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DoAIProxyCallRequest} DoAIProxyCallRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoAIProxyCallRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DoAIProxyCallRequest message.
             * @function verify
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DoAIProxyCallRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.configKey != null && message.hasOwnProperty("configKey"))
                    if (!(message.configKey && typeof message.configKey.length === "number" || $util.isString(message.configKey)))
                        return "configKey: buffer expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!(message.path && typeof message.path.length === "number" || $util.isString(message.path)))
                        return "path: buffer expected";
                if (message.reqBody != null && message.hasOwnProperty("reqBody"))
                    if (!(message.reqBody && typeof message.reqBody.length === "number" || $util.isString(message.reqBody)))
                        return "reqBody: buffer expected";
                if (message.modelConfig != null && message.hasOwnProperty("modelConfig"))
                    if (!(message.modelConfig && typeof message.modelConfig.length === "number" || $util.isString(message.modelConfig)))
                        return "modelConfig: buffer expected";
                if (message.forceRefresh != null && message.hasOwnProperty("forceRefresh"))
                    if (!$util.isInteger(message.forceRefresh))
                        return "forceRefresh: integer expected";
                if (message.headers != null && message.hasOwnProperty("headers"))
                    if (!(message.headers && typeof message.headers.length === "number" || $util.isString(message.headers)))
                        return "headers: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates a DoAIProxyCallRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DoAIProxyCallRequest} DoAIProxyCallRequest
             */
            DoAIProxyCallRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DoAIProxyCallRequest)
                    return object;
                let message = new $root.dcnet.pb.DoAIProxyCallRequest();
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.configKey != null)
                    if (typeof object.configKey === "string")
                        $util.base64.decode(object.configKey, message.configKey = $util.newBuffer($util.base64.length(object.configKey)), 0);
                    else if (object.configKey.length >= 0)
                        message.configKey = object.configKey;
                if (object.path != null)
                    if (typeof object.path === "string")
                        $util.base64.decode(object.path, message.path = $util.newBuffer($util.base64.length(object.path)), 0);
                    else if (object.path.length >= 0)
                        message.path = object.path;
                if (object.reqBody != null)
                    if (typeof object.reqBody === "string")
                        $util.base64.decode(object.reqBody, message.reqBody = $util.newBuffer($util.base64.length(object.reqBody)), 0);
                    else if (object.reqBody.length >= 0)
                        message.reqBody = object.reqBody;
                if (object.modelConfig != null)
                    if (typeof object.modelConfig === "string")
                        $util.base64.decode(object.modelConfig, message.modelConfig = $util.newBuffer($util.base64.length(object.modelConfig)), 0);
                    else if (object.modelConfig.length >= 0)
                        message.modelConfig = object.modelConfig;
                if (object.forceRefresh != null)
                    message.forceRefresh = object.forceRefresh >>> 0;
                if (object.headers != null)
                    if (typeof object.headers === "string")
                        $util.base64.decode(object.headers, message.headers = $util.newBuffer($util.base64.length(object.headers)), 0);
                    else if (object.headers.length >= 0)
                        message.headers = object.headers;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from a DoAIProxyCallRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @static
             * @param {dcnet.pb.DoAIProxyCallRequest} message DoAIProxyCallRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DoAIProxyCallRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.configKey = "";
                    else {
                        object.configKey = [];
                        if (options.bytes !== Array)
                            object.configKey = $util.newBuffer(object.configKey);
                    }
                    if (options.bytes === String)
                        object.path = "";
                    else {
                        object.path = [];
                        if (options.bytes !== Array)
                            object.path = $util.newBuffer(object.path);
                    }
                    if (options.bytes === String)
                        object.reqBody = "";
                    else {
                        object.reqBody = [];
                        if (options.bytes !== Array)
                            object.reqBody = $util.newBuffer(object.reqBody);
                    }
                    if (options.bytes === String)
                        object.modelConfig = "";
                    else {
                        object.modelConfig = [];
                        if (options.bytes !== Array)
                            object.modelConfig = $util.newBuffer(object.modelConfig);
                    }
                    object.forceRefresh = 0;
                    if (options.bytes === String)
                        object.headers = "";
                    else {
                        object.headers = [];
                        if (options.bytes !== Array)
                            object.headers = $util.newBuffer(object.headers);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.configKey != null && message.hasOwnProperty("configKey"))
                    object.configKey = options.bytes === String ? $util.base64.encode(message.configKey, 0, message.configKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.configKey) : message.configKey;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = options.bytes === String ? $util.base64.encode(message.path, 0, message.path.length) : options.bytes === Array ? Array.prototype.slice.call(message.path) : message.path;
                if (message.reqBody != null && message.hasOwnProperty("reqBody"))
                    object.reqBody = options.bytes === String ? $util.base64.encode(message.reqBody, 0, message.reqBody.length) : options.bytes === Array ? Array.prototype.slice.call(message.reqBody) : message.reqBody;
                if (message.modelConfig != null && message.hasOwnProperty("modelConfig"))
                    object.modelConfig = options.bytes === String ? $util.base64.encode(message.modelConfig, 0, message.modelConfig.length) : options.bytes === Array ? Array.prototype.slice.call(message.modelConfig) : message.modelConfig;
                if (message.forceRefresh != null && message.hasOwnProperty("forceRefresh"))
                    object.forceRefresh = message.forceRefresh;
                if (message.headers != null && message.hasOwnProperty("headers"))
                    object.headers = options.bytes === String ? $util.base64.encode(message.headers, 0, message.headers.length) : options.bytes === Array ? Array.prototype.slice.call(message.headers) : message.headers;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this DoAIProxyCallRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DoAIProxyCallRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DoAIProxyCallRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.DoAIProxyCallRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DoAIProxyCallRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DoAIProxyCallRequest";
            };

            return DoAIProxyCallRequest;
        })();

        pb.DoAIProxyCallReply = (function() {

            /**
             * Properties of a DoAIProxyCallReply.
             * @memberof dcnet.pb
             * @interface IDoAIProxyCallReply
             * @property {number|null} [flag] DoAIProxyCallReply flag
             * @property {Uint8Array|null} [content] DoAIProxyCallReply content
             * @property {Uint8Array|null} [err] DoAIProxyCallReply err
             */

            /**
             * Constructs a new DoAIProxyCallReply.
             * @memberof dcnet.pb
             * @classdesc Represents a DoAIProxyCallReply.
             * @implements IDoAIProxyCallReply
             * @constructor
             * @param {dcnet.pb.IDoAIProxyCallReply=} [properties] Properties to set
             */
            function DoAIProxyCallReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DoAIProxyCallReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @instance
             */
            DoAIProxyCallReply.prototype.flag = 0;

            /**
             * DoAIProxyCallReply content.
             * @member {Uint8Array} content
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @instance
             */
            DoAIProxyCallReply.prototype.content = $util.newBuffer([]);

            /**
             * DoAIProxyCallReply err.
             * @member {Uint8Array} err
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @instance
             */
            DoAIProxyCallReply.prototype.err = $util.newBuffer([]);

            /**
             * Creates a new DoAIProxyCallReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @static
             * @param {dcnet.pb.IDoAIProxyCallReply=} [properties] Properties to set
             * @returns {dcnet.pb.DoAIProxyCallReply} DoAIProxyCallReply instance
             */
            DoAIProxyCallReply.create = function create(properties) {
                return new DoAIProxyCallReply(properties);
            };

            /**
             * Encodes the specified DoAIProxyCallReply message. Does not implicitly {@link dcnet.pb.DoAIProxyCallReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @static
             * @param {dcnet.pb.IDoAIProxyCallReply} message DoAIProxyCallReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoAIProxyCallReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.content);
                if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.err);
                return writer;
            };

            /**
             * Encodes the specified DoAIProxyCallReply message, length delimited. Does not implicitly {@link dcnet.pb.DoAIProxyCallReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @static
             * @param {dcnet.pb.IDoAIProxyCallReply} message DoAIProxyCallReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoAIProxyCallReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DoAIProxyCallReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.DoAIProxyCallReply} DoAIProxyCallReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoAIProxyCallReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.DoAIProxyCallReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.content = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.err = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DoAIProxyCallReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.DoAIProxyCallReply} DoAIProxyCallReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoAIProxyCallReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DoAIProxyCallReply message.
             * @function verify
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DoAIProxyCallReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                        return "content: buffer expected";
                if (message.err != null && message.hasOwnProperty("err"))
                    if (!(message.err && typeof message.err.length === "number" || $util.isString(message.err)))
                        return "err: buffer expected";
                return null;
            };

            /**
             * Creates a DoAIProxyCallReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.DoAIProxyCallReply} DoAIProxyCallReply
             */
            DoAIProxyCallReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.DoAIProxyCallReply)
                    return object;
                let message = new $root.dcnet.pb.DoAIProxyCallReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.content != null)
                    if (typeof object.content === "string")
                        $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                    else if (object.content.length >= 0)
                        message.content = object.content;
                if (object.err != null)
                    if (typeof object.err === "string")
                        $util.base64.decode(object.err, message.err = $util.newBuffer($util.base64.length(object.err)), 0);
                    else if (object.err.length >= 0)
                        message.err = object.err;
                return message;
            };

            /**
             * Creates a plain object from a DoAIProxyCallReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @static
             * @param {dcnet.pb.DoAIProxyCallReply} message DoAIProxyCallReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DoAIProxyCallReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.content = "";
                    else {
                        object.content = [];
                        if (options.bytes !== Array)
                            object.content = $util.newBuffer(object.content);
                    }
                    if (options.bytes === String)
                        object.err = "";
                    else {
                        object.err = [];
                        if (options.bytes !== Array)
                            object.err = $util.newBuffer(object.err);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                if (message.err != null && message.hasOwnProperty("err"))
                    object.err = options.bytes === String ? $util.base64.encode(message.err, 0, message.err.length) : options.bytes === Array ? Array.prototype.slice.call(message.err) : message.err;
                return object;
            };

            /**
             * Converts this DoAIProxyCallReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DoAIProxyCallReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DoAIProxyCallReply
             * @function getTypeUrl
             * @memberof dcnet.pb.DoAIProxyCallReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DoAIProxyCallReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.DoAIProxyCallReply";
            };

            return DoAIProxyCallReply;
        })();

        pb.ArchiveDeviceStatusRequest = (function() {

            /**
             * Properties of an ArchiveDeviceStatusRequest.
             * @memberof dcnet.pb
             * @interface IArchiveDeviceStatusRequest
             * @property {Uint8Array|null} [deviceID] ArchiveDeviceStatusRequest deviceID
             * @property {Uint8Array|null} [themeAuthor] ArchiveDeviceStatusRequest themeAuthor
             * @property {Uint8Array|null} [theme] ArchiveDeviceStatusRequest theme
             * @property {Uint8Array|null} [appId] ArchiveDeviceStatusRequest appId
             * @property {number|null} [startSeqno] ArchiveDeviceStatusRequest startSeqno
             * @property {number|null} [endSeqno] ArchiveDeviceStatusRequest endSeqno
             * @property {number|null} [blockheight] ArchiveDeviceStatusRequest blockheight
             * @property {Uint8Array|null} [encSecretkey] ArchiveDeviceStatusRequest encSecretkey
             * @property {Uint8Array|null} [signature] ArchiveDeviceStatusRequest signature
             */

            /**
             * Constructs a new ArchiveDeviceStatusRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an ArchiveDeviceStatusRequest.
             * @implements IArchiveDeviceStatusRequest
             * @constructor
             * @param {dcnet.pb.IArchiveDeviceStatusRequest=} [properties] Properties to set
             */
            function ArchiveDeviceStatusRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ArchiveDeviceStatusRequest deviceID.
             * @member {Uint8Array} deviceID
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @instance
             */
            ArchiveDeviceStatusRequest.prototype.deviceID = $util.newBuffer([]);

            /**
             * ArchiveDeviceStatusRequest themeAuthor.
             * @member {Uint8Array} themeAuthor
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @instance
             */
            ArchiveDeviceStatusRequest.prototype.themeAuthor = $util.newBuffer([]);

            /**
             * ArchiveDeviceStatusRequest theme.
             * @member {Uint8Array} theme
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @instance
             */
            ArchiveDeviceStatusRequest.prototype.theme = $util.newBuffer([]);

            /**
             * ArchiveDeviceStatusRequest appId.
             * @member {Uint8Array} appId
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @instance
             */
            ArchiveDeviceStatusRequest.prototype.appId = $util.newBuffer([]);

            /**
             * ArchiveDeviceStatusRequest startSeqno.
             * @member {number} startSeqno
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @instance
             */
            ArchiveDeviceStatusRequest.prototype.startSeqno = 0;

            /**
             * ArchiveDeviceStatusRequest endSeqno.
             * @member {number} endSeqno
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @instance
             */
            ArchiveDeviceStatusRequest.prototype.endSeqno = 0;

            /**
             * ArchiveDeviceStatusRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @instance
             */
            ArchiveDeviceStatusRequest.prototype.blockheight = 0;

            /**
             * ArchiveDeviceStatusRequest encSecretkey.
             * @member {Uint8Array} encSecretkey
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @instance
             */
            ArchiveDeviceStatusRequest.prototype.encSecretkey = $util.newBuffer([]);

            /**
             * ArchiveDeviceStatusRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @instance
             */
            ArchiveDeviceStatusRequest.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new ArchiveDeviceStatusRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @static
             * @param {dcnet.pb.IArchiveDeviceStatusRequest=} [properties] Properties to set
             * @returns {dcnet.pb.ArchiveDeviceStatusRequest} ArchiveDeviceStatusRequest instance
             */
            ArchiveDeviceStatusRequest.create = function create(properties) {
                return new ArchiveDeviceStatusRequest(properties);
            };

            /**
             * Encodes the specified ArchiveDeviceStatusRequest message. Does not implicitly {@link dcnet.pb.ArchiveDeviceStatusRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @static
             * @param {dcnet.pb.IArchiveDeviceStatusRequest} message ArchiveDeviceStatusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArchiveDeviceStatusRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deviceID != null && Object.hasOwnProperty.call(message, "deviceID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.deviceID);
                if (message.themeAuthor != null && Object.hasOwnProperty.call(message, "themeAuthor"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.themeAuthor);
                if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.theme);
                if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.appId);
                if (message.startSeqno != null && Object.hasOwnProperty.call(message, "startSeqno"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.startSeqno);
                if (message.endSeqno != null && Object.hasOwnProperty.call(message, "endSeqno"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.endSeqno);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.blockheight);
                if (message.encSecretkey != null && Object.hasOwnProperty.call(message, "encSecretkey"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.encSecretkey);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified ArchiveDeviceStatusRequest message, length delimited. Does not implicitly {@link dcnet.pb.ArchiveDeviceStatusRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @static
             * @param {dcnet.pb.IArchiveDeviceStatusRequest} message ArchiveDeviceStatusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArchiveDeviceStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ArchiveDeviceStatusRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ArchiveDeviceStatusRequest} ArchiveDeviceStatusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArchiveDeviceStatusRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ArchiveDeviceStatusRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.deviceID = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.themeAuthor = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.theme = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.appId = reader.bytes();
                            break;
                        }
                    case 5: {
                            message.startSeqno = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.endSeqno = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.encSecretkey = reader.bytes();
                            break;
                        }
                    case 9: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ArchiveDeviceStatusRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ArchiveDeviceStatusRequest} ArchiveDeviceStatusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArchiveDeviceStatusRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ArchiveDeviceStatusRequest message.
             * @function verify
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ArchiveDeviceStatusRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deviceID != null && message.hasOwnProperty("deviceID"))
                    if (!(message.deviceID && typeof message.deviceID.length === "number" || $util.isString(message.deviceID)))
                        return "deviceID: buffer expected";
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    if (!(message.themeAuthor && typeof message.themeAuthor.length === "number" || $util.isString(message.themeAuthor)))
                        return "themeAuthor: buffer expected";
                if (message.theme != null && message.hasOwnProperty("theme"))
                    if (!(message.theme && typeof message.theme.length === "number" || $util.isString(message.theme)))
                        return "theme: buffer expected";
                if (message.appId != null && message.hasOwnProperty("appId"))
                    if (!(message.appId && typeof message.appId.length === "number" || $util.isString(message.appId)))
                        return "appId: buffer expected";
                if (message.startSeqno != null && message.hasOwnProperty("startSeqno"))
                    if (!$util.isInteger(message.startSeqno))
                        return "startSeqno: integer expected";
                if (message.endSeqno != null && message.hasOwnProperty("endSeqno"))
                    if (!$util.isInteger(message.endSeqno))
                        return "endSeqno: integer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.encSecretkey != null && message.hasOwnProperty("encSecretkey"))
                    if (!(message.encSecretkey && typeof message.encSecretkey.length === "number" || $util.isString(message.encSecretkey)))
                        return "encSecretkey: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates an ArchiveDeviceStatusRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ArchiveDeviceStatusRequest} ArchiveDeviceStatusRequest
             */
            ArchiveDeviceStatusRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ArchiveDeviceStatusRequest)
                    return object;
                let message = new $root.dcnet.pb.ArchiveDeviceStatusRequest();
                if (object.deviceID != null)
                    if (typeof object.deviceID === "string")
                        $util.base64.decode(object.deviceID, message.deviceID = $util.newBuffer($util.base64.length(object.deviceID)), 0);
                    else if (object.deviceID.length >= 0)
                        message.deviceID = object.deviceID;
                if (object.themeAuthor != null)
                    if (typeof object.themeAuthor === "string")
                        $util.base64.decode(object.themeAuthor, message.themeAuthor = $util.newBuffer($util.base64.length(object.themeAuthor)), 0);
                    else if (object.themeAuthor.length >= 0)
                        message.themeAuthor = object.themeAuthor;
                if (object.theme != null)
                    if (typeof object.theme === "string")
                        $util.base64.decode(object.theme, message.theme = $util.newBuffer($util.base64.length(object.theme)), 0);
                    else if (object.theme.length >= 0)
                        message.theme = object.theme;
                if (object.appId != null)
                    if (typeof object.appId === "string")
                        $util.base64.decode(object.appId, message.appId = $util.newBuffer($util.base64.length(object.appId)), 0);
                    else if (object.appId.length >= 0)
                        message.appId = object.appId;
                if (object.startSeqno != null)
                    message.startSeqno = object.startSeqno >>> 0;
                if (object.endSeqno != null)
                    message.endSeqno = object.endSeqno >>> 0;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.encSecretkey != null)
                    if (typeof object.encSecretkey === "string")
                        $util.base64.decode(object.encSecretkey, message.encSecretkey = $util.newBuffer($util.base64.length(object.encSecretkey)), 0);
                    else if (object.encSecretkey.length >= 0)
                        message.encSecretkey = object.encSecretkey;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from an ArchiveDeviceStatusRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @static
             * @param {dcnet.pb.ArchiveDeviceStatusRequest} message ArchiveDeviceStatusRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ArchiveDeviceStatusRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.deviceID = "";
                    else {
                        object.deviceID = [];
                        if (options.bytes !== Array)
                            object.deviceID = $util.newBuffer(object.deviceID);
                    }
                    if (options.bytes === String)
                        object.themeAuthor = "";
                    else {
                        object.themeAuthor = [];
                        if (options.bytes !== Array)
                            object.themeAuthor = $util.newBuffer(object.themeAuthor);
                    }
                    if (options.bytes === String)
                        object.theme = "";
                    else {
                        object.theme = [];
                        if (options.bytes !== Array)
                            object.theme = $util.newBuffer(object.theme);
                    }
                    if (options.bytes === String)
                        object.appId = "";
                    else {
                        object.appId = [];
                        if (options.bytes !== Array)
                            object.appId = $util.newBuffer(object.appId);
                    }
                    object.startSeqno = 0;
                    object.endSeqno = 0;
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.encSecretkey = "";
                    else {
                        object.encSecretkey = [];
                        if (options.bytes !== Array)
                            object.encSecretkey = $util.newBuffer(object.encSecretkey);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.deviceID != null && message.hasOwnProperty("deviceID"))
                    object.deviceID = options.bytes === String ? $util.base64.encode(message.deviceID, 0, message.deviceID.length) : options.bytes === Array ? Array.prototype.slice.call(message.deviceID) : message.deviceID;
                if (message.themeAuthor != null && message.hasOwnProperty("themeAuthor"))
                    object.themeAuthor = options.bytes === String ? $util.base64.encode(message.themeAuthor, 0, message.themeAuthor.length) : options.bytes === Array ? Array.prototype.slice.call(message.themeAuthor) : message.themeAuthor;
                if (message.theme != null && message.hasOwnProperty("theme"))
                    object.theme = options.bytes === String ? $util.base64.encode(message.theme, 0, message.theme.length) : options.bytes === Array ? Array.prototype.slice.call(message.theme) : message.theme;
                if (message.appId != null && message.hasOwnProperty("appId"))
                    object.appId = options.bytes === String ? $util.base64.encode(message.appId, 0, message.appId.length) : options.bytes === Array ? Array.prototype.slice.call(message.appId) : message.appId;
                if (message.startSeqno != null && message.hasOwnProperty("startSeqno"))
                    object.startSeqno = message.startSeqno;
                if (message.endSeqno != null && message.hasOwnProperty("endSeqno"))
                    object.endSeqno = message.endSeqno;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.encSecretkey != null && message.hasOwnProperty("encSecretkey"))
                    object.encSecretkey = options.bytes === String ? $util.base64.encode(message.encSecretkey, 0, message.encSecretkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encSecretkey) : message.encSecretkey;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this ArchiveDeviceStatusRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ArchiveDeviceStatusRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ArchiveDeviceStatusRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.ArchiveDeviceStatusRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ArchiveDeviceStatusRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ArchiveDeviceStatusRequest";
            };

            return ArchiveDeviceStatusRequest;
        })();

        pb.ArchiveDeviceStatusReply = (function() {

            /**
             * Properties of an ArchiveDeviceStatusReply.
             * @memberof dcnet.pb
             * @interface IArchiveDeviceStatusReply
             * @property {number|null} [flag] ArchiveDeviceStatusReply flag
             * @property {Uint8Array|null} [statusCid] ArchiveDeviceStatusReply statusCid
             * @property {number|null} [statusCount] ArchiveDeviceStatusReply statusCount
             * @property {number|Long|null} [statusSize] ArchiveDeviceStatusReply statusSize
             * @property {number|null} [blockheight] ArchiveDeviceStatusReply blockheight
             * @property {Uint8Array|null} [signature] ArchiveDeviceStatusReply signature
             */

            /**
             * Constructs a new ArchiveDeviceStatusReply.
             * @memberof dcnet.pb
             * @classdesc Represents an ArchiveDeviceStatusReply.
             * @implements IArchiveDeviceStatusReply
             * @constructor
             * @param {dcnet.pb.IArchiveDeviceStatusReply=} [properties] Properties to set
             */
            function ArchiveDeviceStatusReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ArchiveDeviceStatusReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @instance
             */
            ArchiveDeviceStatusReply.prototype.flag = 0;

            /**
             * ArchiveDeviceStatusReply statusCid.
             * @member {Uint8Array} statusCid
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @instance
             */
            ArchiveDeviceStatusReply.prototype.statusCid = $util.newBuffer([]);

            /**
             * ArchiveDeviceStatusReply statusCount.
             * @member {number} statusCount
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @instance
             */
            ArchiveDeviceStatusReply.prototype.statusCount = 0;

            /**
             * ArchiveDeviceStatusReply statusSize.
             * @member {number|Long} statusSize
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @instance
             */
            ArchiveDeviceStatusReply.prototype.statusSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ArchiveDeviceStatusReply blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @instance
             */
            ArchiveDeviceStatusReply.prototype.blockheight = 0;

            /**
             * ArchiveDeviceStatusReply signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @instance
             */
            ArchiveDeviceStatusReply.prototype.signature = $util.newBuffer([]);

            /**
             * Creates a new ArchiveDeviceStatusReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @static
             * @param {dcnet.pb.IArchiveDeviceStatusReply=} [properties] Properties to set
             * @returns {dcnet.pb.ArchiveDeviceStatusReply} ArchiveDeviceStatusReply instance
             */
            ArchiveDeviceStatusReply.create = function create(properties) {
                return new ArchiveDeviceStatusReply(properties);
            };

            /**
             * Encodes the specified ArchiveDeviceStatusReply message. Does not implicitly {@link dcnet.pb.ArchiveDeviceStatusReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @static
             * @param {dcnet.pb.IArchiveDeviceStatusReply} message ArchiveDeviceStatusReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArchiveDeviceStatusReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                if (message.statusCid != null && Object.hasOwnProperty.call(message, "statusCid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.statusCid);
                if (message.statusCount != null && Object.hasOwnProperty.call(message, "statusCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.statusCount);
                if (message.statusSize != null && Object.hasOwnProperty.call(message, "statusSize"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.statusSize);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.blockheight);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.signature);
                return writer;
            };

            /**
             * Encodes the specified ArchiveDeviceStatusReply message, length delimited. Does not implicitly {@link dcnet.pb.ArchiveDeviceStatusReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @static
             * @param {dcnet.pb.IArchiveDeviceStatusReply} message ArchiveDeviceStatusReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArchiveDeviceStatusReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ArchiveDeviceStatusReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.ArchiveDeviceStatusReply} ArchiveDeviceStatusReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArchiveDeviceStatusReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.ArchiveDeviceStatusReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.statusCid = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.statusCount = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.statusSize = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.signature = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ArchiveDeviceStatusReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.ArchiveDeviceStatusReply} ArchiveDeviceStatusReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArchiveDeviceStatusReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ArchiveDeviceStatusReply message.
             * @function verify
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ArchiveDeviceStatusReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                if (message.statusCid != null && message.hasOwnProperty("statusCid"))
                    if (!(message.statusCid && typeof message.statusCid.length === "number" || $util.isString(message.statusCid)))
                        return "statusCid: buffer expected";
                if (message.statusCount != null && message.hasOwnProperty("statusCount"))
                    if (!$util.isInteger(message.statusCount))
                        return "statusCount: integer expected";
                if (message.statusSize != null && message.hasOwnProperty("statusSize"))
                    if (!$util.isInteger(message.statusSize) && !(message.statusSize && $util.isInteger(message.statusSize.low) && $util.isInteger(message.statusSize.high)))
                        return "statusSize: integer|Long expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };

            /**
             * Creates an ArchiveDeviceStatusReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.ArchiveDeviceStatusReply} ArchiveDeviceStatusReply
             */
            ArchiveDeviceStatusReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.ArchiveDeviceStatusReply)
                    return object;
                let message = new $root.dcnet.pb.ArchiveDeviceStatusReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                if (object.statusCid != null)
                    if (typeof object.statusCid === "string")
                        $util.base64.decode(object.statusCid, message.statusCid = $util.newBuffer($util.base64.length(object.statusCid)), 0);
                    else if (object.statusCid.length >= 0)
                        message.statusCid = object.statusCid;
                if (object.statusCount != null)
                    message.statusCount = object.statusCount >>> 0;
                if (object.statusSize != null)
                    if ($util.Long)
                        (message.statusSize = $util.Long.fromValue(object.statusSize)).unsigned = true;
                    else if (typeof object.statusSize === "string")
                        message.statusSize = parseInt(object.statusSize, 10);
                    else if (typeof object.statusSize === "number")
                        message.statusSize = object.statusSize;
                    else if (typeof object.statusSize === "object")
                        message.statusSize = new $util.LongBits(object.statusSize.low >>> 0, object.statusSize.high >>> 0).toNumber(true);
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                return message;
            };

            /**
             * Creates a plain object from an ArchiveDeviceStatusReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @static
             * @param {dcnet.pb.ArchiveDeviceStatusReply} message ArchiveDeviceStatusReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ArchiveDeviceStatusReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.flag = 0;
                    if (options.bytes === String)
                        object.statusCid = "";
                    else {
                        object.statusCid = [];
                        if (options.bytes !== Array)
                            object.statusCid = $util.newBuffer(object.statusCid);
                    }
                    object.statusCount = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.statusSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.statusSize = options.longs === String ? "0" : 0;
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.statusCid != null && message.hasOwnProperty("statusCid"))
                    object.statusCid = options.bytes === String ? $util.base64.encode(message.statusCid, 0, message.statusCid.length) : options.bytes === Array ? Array.prototype.slice.call(message.statusCid) : message.statusCid;
                if (message.statusCount != null && message.hasOwnProperty("statusCount"))
                    object.statusCount = message.statusCount;
                if (message.statusSize != null && message.hasOwnProperty("statusSize"))
                    if (typeof message.statusSize === "number")
                        object.statusSize = options.longs === String ? String(message.statusSize) : message.statusSize;
                    else
                        object.statusSize = options.longs === String ? $util.Long.prototype.toString.call(message.statusSize) : options.longs === Number ? new $util.LongBits(message.statusSize.low >>> 0, message.statusSize.high >>> 0).toNumber(true) : message.statusSize;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };

            /**
             * Converts this ArchiveDeviceStatusReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ArchiveDeviceStatusReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ArchiveDeviceStatusReply
             * @function getTypeUrl
             * @memberof dcnet.pb.ArchiveDeviceStatusReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ArchiveDeviceStatusReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.ArchiveDeviceStatusReply";
            };

            return ArchiveDeviceStatusReply;
        })();

        pb.AddUserOffChainOpTimesRequest = (function() {

            /**
             * Properties of an AddUserOffChainOpTimesRequest.
             * @memberof dcnet.pb
             * @interface IAddUserOffChainOpTimesRequest
             * @property {Uint8Array|null} [userPubkey] AddUserOffChainOpTimesRequest userPubkey
             * @property {number|null} [blockheight] AddUserOffChainOpTimesRequest blockheight
             * @property {Uint8Array|null} [peerid] AddUserOffChainOpTimesRequest peerid
             * @property {number|null} [times] AddUserOffChainOpTimesRequest times
             * @property {Uint8Array|null} [signature] AddUserOffChainOpTimesRequest signature
             * @property {Uint8Array|null} [vaccount] AddUserOffChainOpTimesRequest vaccount
             */

            /**
             * Constructs a new AddUserOffChainOpTimesRequest.
             * @memberof dcnet.pb
             * @classdesc Represents an AddUserOffChainOpTimesRequest.
             * @implements IAddUserOffChainOpTimesRequest
             * @constructor
             * @param {dcnet.pb.IAddUserOffChainOpTimesRequest=} [properties] Properties to set
             */
            function AddUserOffChainOpTimesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddUserOffChainOpTimesRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @instance
             */
            AddUserOffChainOpTimesRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * AddUserOffChainOpTimesRequest blockheight.
             * @member {number} blockheight
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @instance
             */
            AddUserOffChainOpTimesRequest.prototype.blockheight = 0;

            /**
             * AddUserOffChainOpTimesRequest peerid.
             * @member {Uint8Array} peerid
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @instance
             */
            AddUserOffChainOpTimesRequest.prototype.peerid = $util.newBuffer([]);

            /**
             * AddUserOffChainOpTimesRequest times.
             * @member {number} times
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @instance
             */
            AddUserOffChainOpTimesRequest.prototype.times = 0;

            /**
             * AddUserOffChainOpTimesRequest signature.
             * @member {Uint8Array} signature
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @instance
             */
            AddUserOffChainOpTimesRequest.prototype.signature = $util.newBuffer([]);

            /**
             * AddUserOffChainOpTimesRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @instance
             */
            AddUserOffChainOpTimesRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new AddUserOffChainOpTimesRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.IAddUserOffChainOpTimesRequest=} [properties] Properties to set
             * @returns {dcnet.pb.AddUserOffChainOpTimesRequest} AddUserOffChainOpTimesRequest instance
             */
            AddUserOffChainOpTimesRequest.create = function create(properties) {
                return new AddUserOffChainOpTimesRequest(properties);
            };

            /**
             * Encodes the specified AddUserOffChainOpTimesRequest message. Does not implicitly {@link dcnet.pb.AddUserOffChainOpTimesRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.IAddUserOffChainOpTimesRequest} message AddUserOffChainOpTimesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddUserOffChainOpTimesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                if (message.blockheight != null && Object.hasOwnProperty.call(message, "blockheight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockheight);
                if (message.peerid != null && Object.hasOwnProperty.call(message, "peerid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.peerid);
                if (message.times != null && Object.hasOwnProperty.call(message, "times"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.times);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.signature);
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified AddUserOffChainOpTimesRequest message, length delimited. Does not implicitly {@link dcnet.pb.AddUserOffChainOpTimesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.IAddUserOffChainOpTimesRequest} message AddUserOffChainOpTimesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddUserOffChainOpTimesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddUserOffChainOpTimesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddUserOffChainOpTimesRequest} AddUserOffChainOpTimesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddUserOffChainOpTimesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddUserOffChainOpTimesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.blockheight = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.peerid = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.times = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.signature = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddUserOffChainOpTimesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddUserOffChainOpTimesRequest} AddUserOffChainOpTimesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddUserOffChainOpTimesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddUserOffChainOpTimesRequest message.
             * @function verify
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddUserOffChainOpTimesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    if (!$util.isInteger(message.blockheight))
                        return "blockheight: integer expected";
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    if (!(message.peerid && typeof message.peerid.length === "number" || $util.isString(message.peerid)))
                        return "peerid: buffer expected";
                if (message.times != null && message.hasOwnProperty("times"))
                    if (!$util.isInteger(message.times))
                        return "times: integer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates an AddUserOffChainOpTimesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddUserOffChainOpTimesRequest} AddUserOffChainOpTimesRequest
             */
            AddUserOffChainOpTimesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddUserOffChainOpTimesRequest)
                    return object;
                let message = new $root.dcnet.pb.AddUserOffChainOpTimesRequest();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                if (object.blockheight != null)
                    message.blockheight = object.blockheight >>> 0;
                if (object.peerid != null)
                    if (typeof object.peerid === "string")
                        $util.base64.decode(object.peerid, message.peerid = $util.newBuffer($util.base64.length(object.peerid)), 0);
                    else if (object.peerid.length >= 0)
                        message.peerid = object.peerid;
                if (object.times != null)
                    message.times = object.times >>> 0;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length >= 0)
                        message.signature = object.signature;
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from an AddUserOffChainOpTimesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.AddUserOffChainOpTimesRequest} message AddUserOffChainOpTimesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddUserOffChainOpTimesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                    object.blockheight = 0;
                    if (options.bytes === String)
                        object.peerid = "";
                    else {
                        object.peerid = [];
                        if (options.bytes !== Array)
                            object.peerid = $util.newBuffer(object.peerid);
                    }
                    object.times = 0;
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                if (message.blockheight != null && message.hasOwnProperty("blockheight"))
                    object.blockheight = message.blockheight;
                if (message.peerid != null && message.hasOwnProperty("peerid"))
                    object.peerid = options.bytes === String ? $util.base64.encode(message.peerid, 0, message.peerid.length) : options.bytes === Array ? Array.prototype.slice.call(message.peerid) : message.peerid;
                if (message.times != null && message.hasOwnProperty("times"))
                    object.times = message.times;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this AddUserOffChainOpTimesRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddUserOffChainOpTimesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddUserOffChainOpTimesRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.AddUserOffChainOpTimesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddUserOffChainOpTimesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddUserOffChainOpTimesRequest";
            };

            return AddUserOffChainOpTimesRequest;
        })();

        pb.AddUserOffChainOpTimesReply = (function() {

            /**
             * Properties of an AddUserOffChainOpTimesReply.
             * @memberof dcnet.pb
             * @interface IAddUserOffChainOpTimesReply
             * @property {number|null} [flag] AddUserOffChainOpTimesReply flag
             */

            /**
             * Constructs a new AddUserOffChainOpTimesReply.
             * @memberof dcnet.pb
             * @classdesc Represents an AddUserOffChainOpTimesReply.
             * @implements IAddUserOffChainOpTimesReply
             * @constructor
             * @param {dcnet.pb.IAddUserOffChainOpTimesReply=} [properties] Properties to set
             */
            function AddUserOffChainOpTimesReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddUserOffChainOpTimesReply flag.
             * @member {number} flag
             * @memberof dcnet.pb.AddUserOffChainOpTimesReply
             * @instance
             */
            AddUserOffChainOpTimesReply.prototype.flag = 0;

            /**
             * Creates a new AddUserOffChainOpTimesReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.AddUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.IAddUserOffChainOpTimesReply=} [properties] Properties to set
             * @returns {dcnet.pb.AddUserOffChainOpTimesReply} AddUserOffChainOpTimesReply instance
             */
            AddUserOffChainOpTimesReply.create = function create(properties) {
                return new AddUserOffChainOpTimesReply(properties);
            };

            /**
             * Encodes the specified AddUserOffChainOpTimesReply message. Does not implicitly {@link dcnet.pb.AddUserOffChainOpTimesReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.AddUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.IAddUserOffChainOpTimesReply} message AddUserOffChainOpTimesReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddUserOffChainOpTimesReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flag);
                return writer;
            };

            /**
             * Encodes the specified AddUserOffChainOpTimesReply message, length delimited. Does not implicitly {@link dcnet.pb.AddUserOffChainOpTimesReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.AddUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.IAddUserOffChainOpTimesReply} message AddUserOffChainOpTimesReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddUserOffChainOpTimesReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddUserOffChainOpTimesReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.AddUserOffChainOpTimesReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.AddUserOffChainOpTimesReply} AddUserOffChainOpTimesReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddUserOffChainOpTimesReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.AddUserOffChainOpTimesReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddUserOffChainOpTimesReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.AddUserOffChainOpTimesReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.AddUserOffChainOpTimesReply} AddUserOffChainOpTimesReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddUserOffChainOpTimesReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddUserOffChainOpTimesReply message.
             * @function verify
             * @memberof dcnet.pb.AddUserOffChainOpTimesReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddUserOffChainOpTimesReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isInteger(message.flag))
                        return "flag: integer expected";
                return null;
            };

            /**
             * Creates an AddUserOffChainOpTimesReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.AddUserOffChainOpTimesReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.AddUserOffChainOpTimesReply} AddUserOffChainOpTimesReply
             */
            AddUserOffChainOpTimesReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.AddUserOffChainOpTimesReply)
                    return object;
                let message = new $root.dcnet.pb.AddUserOffChainOpTimesReply();
                if (object.flag != null)
                    message.flag = object.flag >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AddUserOffChainOpTimesReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.AddUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.AddUserOffChainOpTimesReply} message AddUserOffChainOpTimesReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddUserOffChainOpTimesReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = 0;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this AddUserOffChainOpTimesReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.AddUserOffChainOpTimesReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddUserOffChainOpTimesReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddUserOffChainOpTimesReply
             * @function getTypeUrl
             * @memberof dcnet.pb.AddUserOffChainOpTimesReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddUserOffChainOpTimesReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.AddUserOffChainOpTimesReply";
            };

            return AddUserOffChainOpTimesReply;
        })();

        pb.GetUserOffChainOpTimesRequest = (function() {

            /**
             * Properties of a GetUserOffChainOpTimesRequest.
             * @memberof dcnet.pb
             * @interface IGetUserOffChainOpTimesRequest
             * @property {Uint8Array|null} [userPubkey] GetUserOffChainOpTimesRequest userPubkey
             */

            /**
             * Constructs a new GetUserOffChainOpTimesRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetUserOffChainOpTimesRequest.
             * @implements IGetUserOffChainOpTimesRequest
             * @constructor
             * @param {dcnet.pb.IGetUserOffChainOpTimesRequest=} [properties] Properties to set
             */
            function GetUserOffChainOpTimesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUserOffChainOpTimesRequest userPubkey.
             * @member {Uint8Array} userPubkey
             * @memberof dcnet.pb.GetUserOffChainOpTimesRequest
             * @instance
             */
            GetUserOffChainOpTimesRequest.prototype.userPubkey = $util.newBuffer([]);

            /**
             * Creates a new GetUserOffChainOpTimesRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.IGetUserOffChainOpTimesRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetUserOffChainOpTimesRequest} GetUserOffChainOpTimesRequest instance
             */
            GetUserOffChainOpTimesRequest.create = function create(properties) {
                return new GetUserOffChainOpTimesRequest(properties);
            };

            /**
             * Encodes the specified GetUserOffChainOpTimesRequest message. Does not implicitly {@link dcnet.pb.GetUserOffChainOpTimesRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.IGetUserOffChainOpTimesRequest} message GetUserOffChainOpTimesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOffChainOpTimesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userPubkey != null && Object.hasOwnProperty.call(message, "userPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userPubkey);
                return writer;
            };

            /**
             * Encodes the specified GetUserOffChainOpTimesRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetUserOffChainOpTimesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.IGetUserOffChainOpTimesRequest} message GetUserOffChainOpTimesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOffChainOpTimesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUserOffChainOpTimesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetUserOffChainOpTimesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetUserOffChainOpTimesRequest} GetUserOffChainOpTimesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOffChainOpTimesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetUserOffChainOpTimesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userPubkey = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUserOffChainOpTimesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetUserOffChainOpTimesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetUserOffChainOpTimesRequest} GetUserOffChainOpTimesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOffChainOpTimesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUserOffChainOpTimesRequest message.
             * @function verify
             * @memberof dcnet.pb.GetUserOffChainOpTimesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUserOffChainOpTimesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    if (!(message.userPubkey && typeof message.userPubkey.length === "number" || $util.isString(message.userPubkey)))
                        return "userPubkey: buffer expected";
                return null;
            };

            /**
             * Creates a GetUserOffChainOpTimesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetUserOffChainOpTimesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetUserOffChainOpTimesRequest} GetUserOffChainOpTimesRequest
             */
            GetUserOffChainOpTimesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetUserOffChainOpTimesRequest)
                    return object;
                let message = new $root.dcnet.pb.GetUserOffChainOpTimesRequest();
                if (object.userPubkey != null)
                    if (typeof object.userPubkey === "string")
                        $util.base64.decode(object.userPubkey, message.userPubkey = $util.newBuffer($util.base64.length(object.userPubkey)), 0);
                    else if (object.userPubkey.length >= 0)
                        message.userPubkey = object.userPubkey;
                return message;
            };

            /**
             * Creates a plain object from a GetUserOffChainOpTimesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetUserOffChainOpTimesRequest
             * @static
             * @param {dcnet.pb.GetUserOffChainOpTimesRequest} message GetUserOffChainOpTimesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUserOffChainOpTimesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.userPubkey = "";
                    else {
                        object.userPubkey = [];
                        if (options.bytes !== Array)
                            object.userPubkey = $util.newBuffer(object.userPubkey);
                    }
                if (message.userPubkey != null && message.hasOwnProperty("userPubkey"))
                    object.userPubkey = options.bytes === String ? $util.base64.encode(message.userPubkey, 0, message.userPubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userPubkey) : message.userPubkey;
                return object;
            };

            /**
             * Converts this GetUserOffChainOpTimesRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetUserOffChainOpTimesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUserOffChainOpTimesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUserOffChainOpTimesRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetUserOffChainOpTimesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUserOffChainOpTimesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetUserOffChainOpTimesRequest";
            };

            return GetUserOffChainOpTimesRequest;
        })();

        pb.GetUserOffChainOpTimesReply = (function() {

            /**
             * Properties of a GetUserOffChainOpTimesReply.
             * @memberof dcnet.pb
             * @interface IGetUserOffChainOpTimesReply
             * @property {number|null} [usedtimes] GetUserOffChainOpTimesReply usedtimes
             */

            /**
             * Constructs a new GetUserOffChainOpTimesReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetUserOffChainOpTimesReply.
             * @implements IGetUserOffChainOpTimesReply
             * @constructor
             * @param {dcnet.pb.IGetUserOffChainOpTimesReply=} [properties] Properties to set
             */
            function GetUserOffChainOpTimesReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUserOffChainOpTimesReply usedtimes.
             * @member {number} usedtimes
             * @memberof dcnet.pb.GetUserOffChainOpTimesReply
             * @instance
             */
            GetUserOffChainOpTimesReply.prototype.usedtimes = 0;

            /**
             * Creates a new GetUserOffChainOpTimesReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.IGetUserOffChainOpTimesReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetUserOffChainOpTimesReply} GetUserOffChainOpTimesReply instance
             */
            GetUserOffChainOpTimesReply.create = function create(properties) {
                return new GetUserOffChainOpTimesReply(properties);
            };

            /**
             * Encodes the specified GetUserOffChainOpTimesReply message. Does not implicitly {@link dcnet.pb.GetUserOffChainOpTimesReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.IGetUserOffChainOpTimesReply} message GetUserOffChainOpTimesReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOffChainOpTimesReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.usedtimes != null && Object.hasOwnProperty.call(message, "usedtimes"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.usedtimes);
                return writer;
            };

            /**
             * Encodes the specified GetUserOffChainOpTimesReply message, length delimited. Does not implicitly {@link dcnet.pb.GetUserOffChainOpTimesReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.IGetUserOffChainOpTimesReply} message GetUserOffChainOpTimesReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOffChainOpTimesReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUserOffChainOpTimesReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetUserOffChainOpTimesReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetUserOffChainOpTimesReply} GetUserOffChainOpTimesReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOffChainOpTimesReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetUserOffChainOpTimesReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.usedtimes = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUserOffChainOpTimesReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetUserOffChainOpTimesReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetUserOffChainOpTimesReply} GetUserOffChainOpTimesReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOffChainOpTimesReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUserOffChainOpTimesReply message.
             * @function verify
             * @memberof dcnet.pb.GetUserOffChainOpTimesReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUserOffChainOpTimesReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.usedtimes != null && message.hasOwnProperty("usedtimes"))
                    if (!$util.isInteger(message.usedtimes))
                        return "usedtimes: integer expected";
                return null;
            };

            /**
             * Creates a GetUserOffChainOpTimesReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetUserOffChainOpTimesReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetUserOffChainOpTimesReply} GetUserOffChainOpTimesReply
             */
            GetUserOffChainOpTimesReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetUserOffChainOpTimesReply)
                    return object;
                let message = new $root.dcnet.pb.GetUserOffChainOpTimesReply();
                if (object.usedtimes != null)
                    message.usedtimes = object.usedtimes >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetUserOffChainOpTimesReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetUserOffChainOpTimesReply
             * @static
             * @param {dcnet.pb.GetUserOffChainOpTimesReply} message GetUserOffChainOpTimesReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUserOffChainOpTimesReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.usedtimes = 0;
                if (message.usedtimes != null && message.hasOwnProperty("usedtimes"))
                    object.usedtimes = message.usedtimes;
                return object;
            };

            /**
             * Converts this GetUserOffChainOpTimesReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetUserOffChainOpTimesReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUserOffChainOpTimesReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUserOffChainOpTimesReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetUserOffChainOpTimesReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUserOffChainOpTimesReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetUserOffChainOpTimesReply";
            };

            return GetUserOffChainOpTimesReply;
        })();

        pb.GetUserOffChainUsedInfoRequest = (function() {

            /**
             * Properties of a GetUserOffChainUsedInfoRequest.
             * @memberof dcnet.pb
             * @interface IGetUserOffChainUsedInfoRequest
             * @property {Uint8Array|null} [vaccount] GetUserOffChainUsedInfoRequest vaccount
             */

            /**
             * Constructs a new GetUserOffChainUsedInfoRequest.
             * @memberof dcnet.pb
             * @classdesc Represents a GetUserOffChainUsedInfoRequest.
             * @implements IGetUserOffChainUsedInfoRequest
             * @constructor
             * @param {dcnet.pb.IGetUserOffChainUsedInfoRequest=} [properties] Properties to set
             */
            function GetUserOffChainUsedInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUserOffChainUsedInfoRequest vaccount.
             * @member {Uint8Array} vaccount
             * @memberof dcnet.pb.GetUserOffChainUsedInfoRequest
             * @instance
             */
            GetUserOffChainUsedInfoRequest.prototype.vaccount = $util.newBuffer([]);

            /**
             * Creates a new GetUserOffChainUsedInfoRequest instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetUserOffChainUsedInfoRequest
             * @static
             * @param {dcnet.pb.IGetUserOffChainUsedInfoRequest=} [properties] Properties to set
             * @returns {dcnet.pb.GetUserOffChainUsedInfoRequest} GetUserOffChainUsedInfoRequest instance
             */
            GetUserOffChainUsedInfoRequest.create = function create(properties) {
                return new GetUserOffChainUsedInfoRequest(properties);
            };

            /**
             * Encodes the specified GetUserOffChainUsedInfoRequest message. Does not implicitly {@link dcnet.pb.GetUserOffChainUsedInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetUserOffChainUsedInfoRequest
             * @static
             * @param {dcnet.pb.IGetUserOffChainUsedInfoRequest} message GetUserOffChainUsedInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOffChainUsedInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.vaccount != null && Object.hasOwnProperty.call(message, "vaccount"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.vaccount);
                return writer;
            };

            /**
             * Encodes the specified GetUserOffChainUsedInfoRequest message, length delimited. Does not implicitly {@link dcnet.pb.GetUserOffChainUsedInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetUserOffChainUsedInfoRequest
             * @static
             * @param {dcnet.pb.IGetUserOffChainUsedInfoRequest} message GetUserOffChainUsedInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOffChainUsedInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUserOffChainUsedInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetUserOffChainUsedInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetUserOffChainUsedInfoRequest} GetUserOffChainUsedInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOffChainUsedInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetUserOffChainUsedInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.vaccount = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUserOffChainUsedInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetUserOffChainUsedInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetUserOffChainUsedInfoRequest} GetUserOffChainUsedInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOffChainUsedInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUserOffChainUsedInfoRequest message.
             * @function verify
             * @memberof dcnet.pb.GetUserOffChainUsedInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUserOffChainUsedInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    if (!(message.vaccount && typeof message.vaccount.length === "number" || $util.isString(message.vaccount)))
                        return "vaccount: buffer expected";
                return null;
            };

            /**
             * Creates a GetUserOffChainUsedInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetUserOffChainUsedInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetUserOffChainUsedInfoRequest} GetUserOffChainUsedInfoRequest
             */
            GetUserOffChainUsedInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetUserOffChainUsedInfoRequest)
                    return object;
                let message = new $root.dcnet.pb.GetUserOffChainUsedInfoRequest();
                if (object.vaccount != null)
                    if (typeof object.vaccount === "string")
                        $util.base64.decode(object.vaccount, message.vaccount = $util.newBuffer($util.base64.length(object.vaccount)), 0);
                    else if (object.vaccount.length >= 0)
                        message.vaccount = object.vaccount;
                return message;
            };

            /**
             * Creates a plain object from a GetUserOffChainUsedInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetUserOffChainUsedInfoRequest
             * @static
             * @param {dcnet.pb.GetUserOffChainUsedInfoRequest} message GetUserOffChainUsedInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUserOffChainUsedInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.vaccount = "";
                    else {
                        object.vaccount = [];
                        if (options.bytes !== Array)
                            object.vaccount = $util.newBuffer(object.vaccount);
                    }
                if (message.vaccount != null && message.hasOwnProperty("vaccount"))
                    object.vaccount = options.bytes === String ? $util.base64.encode(message.vaccount, 0, message.vaccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.vaccount) : message.vaccount;
                return object;
            };

            /**
             * Converts this GetUserOffChainUsedInfoRequest to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetUserOffChainUsedInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUserOffChainUsedInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUserOffChainUsedInfoRequest
             * @function getTypeUrl
             * @memberof dcnet.pb.GetUserOffChainUsedInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUserOffChainUsedInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetUserOffChainUsedInfoRequest";
            };

            return GetUserOffChainUsedInfoRequest;
        })();

        pb.GetUserOffChainUsedInfoReply = (function() {

            /**
             * Properties of a GetUserOffChainUsedInfoReply.
             * @memberof dcnet.pb
             * @interface IGetUserOffChainUsedInfoReply
             * @property {number|null} [usedtimes] GetUserOffChainUsedInfoReply usedtimes
             * @property {number|Long|null} [usedspace] GetUserOffChainUsedInfoReply usedspace
             */

            /**
             * Constructs a new GetUserOffChainUsedInfoReply.
             * @memberof dcnet.pb
             * @classdesc Represents a GetUserOffChainUsedInfoReply.
             * @implements IGetUserOffChainUsedInfoReply
             * @constructor
             * @param {dcnet.pb.IGetUserOffChainUsedInfoReply=} [properties] Properties to set
             */
            function GetUserOffChainUsedInfoReply(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUserOffChainUsedInfoReply usedtimes.
             * @member {number} usedtimes
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @instance
             */
            GetUserOffChainUsedInfoReply.prototype.usedtimes = 0;

            /**
             * GetUserOffChainUsedInfoReply usedspace.
             * @member {number|Long} usedspace
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @instance
             */
            GetUserOffChainUsedInfoReply.prototype.usedspace = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetUserOffChainUsedInfoReply instance using the specified properties.
             * @function create
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @static
             * @param {dcnet.pb.IGetUserOffChainUsedInfoReply=} [properties] Properties to set
             * @returns {dcnet.pb.GetUserOffChainUsedInfoReply} GetUserOffChainUsedInfoReply instance
             */
            GetUserOffChainUsedInfoReply.create = function create(properties) {
                return new GetUserOffChainUsedInfoReply(properties);
            };

            /**
             * Encodes the specified GetUserOffChainUsedInfoReply message. Does not implicitly {@link dcnet.pb.GetUserOffChainUsedInfoReply.verify|verify} messages.
             * @function encode
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @static
             * @param {dcnet.pb.IGetUserOffChainUsedInfoReply} message GetUserOffChainUsedInfoReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOffChainUsedInfoReply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.usedtimes != null && Object.hasOwnProperty.call(message, "usedtimes"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.usedtimes);
                if (message.usedspace != null && Object.hasOwnProperty.call(message, "usedspace"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.usedspace);
                return writer;
            };

            /**
             * Encodes the specified GetUserOffChainUsedInfoReply message, length delimited. Does not implicitly {@link dcnet.pb.GetUserOffChainUsedInfoReply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @static
             * @param {dcnet.pb.IGetUserOffChainUsedInfoReply} message GetUserOffChainUsedInfoReply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUserOffChainUsedInfoReply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUserOffChainUsedInfoReply message from the specified reader or buffer.
             * @function decode
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dcnet.pb.GetUserOffChainUsedInfoReply} GetUserOffChainUsedInfoReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOffChainUsedInfoReply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dcnet.pb.GetUserOffChainUsedInfoReply();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.usedtimes = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.usedspace = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUserOffChainUsedInfoReply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dcnet.pb.GetUserOffChainUsedInfoReply} GetUserOffChainUsedInfoReply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUserOffChainUsedInfoReply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUserOffChainUsedInfoReply message.
             * @function verify
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUserOffChainUsedInfoReply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.usedtimes != null && message.hasOwnProperty("usedtimes"))
                    if (!$util.isInteger(message.usedtimes))
                        return "usedtimes: integer expected";
                if (message.usedspace != null && message.hasOwnProperty("usedspace"))
                    if (!$util.isInteger(message.usedspace) && !(message.usedspace && $util.isInteger(message.usedspace.low) && $util.isInteger(message.usedspace.high)))
                        return "usedspace: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetUserOffChainUsedInfoReply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dcnet.pb.GetUserOffChainUsedInfoReply} GetUserOffChainUsedInfoReply
             */
            GetUserOffChainUsedInfoReply.fromObject = function fromObject(object) {
                if (object instanceof $root.dcnet.pb.GetUserOffChainUsedInfoReply)
                    return object;
                let message = new $root.dcnet.pb.GetUserOffChainUsedInfoReply();
                if (object.usedtimes != null)
                    message.usedtimes = object.usedtimes >>> 0;
                if (object.usedspace != null)
                    if ($util.Long)
                        (message.usedspace = $util.Long.fromValue(object.usedspace)).unsigned = true;
                    else if (typeof object.usedspace === "string")
                        message.usedspace = parseInt(object.usedspace, 10);
                    else if (typeof object.usedspace === "number")
                        message.usedspace = object.usedspace;
                    else if (typeof object.usedspace === "object")
                        message.usedspace = new $util.LongBits(object.usedspace.low >>> 0, object.usedspace.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetUserOffChainUsedInfoReply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @static
             * @param {dcnet.pb.GetUserOffChainUsedInfoReply} message GetUserOffChainUsedInfoReply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUserOffChainUsedInfoReply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.usedtimes = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.usedspace = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.usedspace = options.longs === String ? "0" : 0;
                }
                if (message.usedtimes != null && message.hasOwnProperty("usedtimes"))
                    object.usedtimes = message.usedtimes;
                if (message.usedspace != null && message.hasOwnProperty("usedspace"))
                    if (typeof message.usedspace === "number")
                        object.usedspace = options.longs === String ? String(message.usedspace) : message.usedspace;
                    else
                        object.usedspace = options.longs === String ? $util.Long.prototype.toString.call(message.usedspace) : options.longs === Number ? new $util.LongBits(message.usedspace.low >>> 0, message.usedspace.high >>> 0).toNumber(true) : message.usedspace;
                return object;
            };

            /**
             * Converts this GetUserOffChainUsedInfoReply to JSON.
             * @function toJSON
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUserOffChainUsedInfoReply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUserOffChainUsedInfoReply
             * @function getTypeUrl
             * @memberof dcnet.pb.GetUserOffChainUsedInfoReply
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUserOffChainUsedInfoReply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dcnet.pb.GetUserOffChainUsedInfoReply";
            };

            return GetUserOffChainUsedInfoReply;
        })();

        pb.Service = (function() {

            /**
             * Constructs a new Service service.
             * @memberof dcnet.pb
             * @classdesc Represents a Service
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Service(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (Service.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Service;

            /**
             * Creates new Service service using the specified rpc implementation.
             * @function create
             * @memberof dcnet.pb.Service
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Service} RPC service. Useful where requests and/or responses are streamed.
             */
            Service.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link dcnet.pb.Service#storeThreadToPeer}.
             * @memberof dcnet.pb.Service
             * @typedef StoreThreadToPeerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.StoreThreadReply} [response] StoreThreadReply
             */

            /**
             * Calls StoreThreadToPeer.
             * @function storeThreadToPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IStoreThreadRequest} request StoreThreadRequest message or plain object
             * @param {dcnet.pb.Service.StoreThreadToPeerCallback} callback Node-style callback called with the error, if any, and StoreThreadReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.storeThreadToPeer = function storeThreadToPeer(request, callback) {
                return this.rpcCall(storeThreadToPeer, $root.dcnet.pb.StoreThreadRequest, $root.dcnet.pb.StoreThreadReply, request, callback);
            }, "name", { value: "StoreThreadToPeer" });

            /**
             * Calls StoreThreadToPeer.
             * @function storeThreadToPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IStoreThreadRequest} request StoreThreadRequest message or plain object
             * @returns {Promise<dcnet.pb.StoreThreadReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#storeFileToPeer}.
             * @memberof dcnet.pb.Service
             * @typedef StoreFileToPeerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.StroeFileToPeerReply} [response] StroeFileToPeerReply
             */

            /**
             * Calls StoreFileToPeer.
             * @function storeFileToPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IStroeFileToPeerRequest} request StroeFileToPeerRequest message or plain object
             * @param {dcnet.pb.Service.StoreFileToPeerCallback} callback Node-style callback called with the error, if any, and StroeFileToPeerReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.storeFileToPeer = function storeFileToPeer(request, callback) {
                return this.rpcCall(storeFileToPeer, $root.dcnet.pb.StroeFileToPeerRequest, $root.dcnet.pb.StroeFileToPeerReply, request, callback);
            }, "name", { value: "StoreFileToPeer" });

            /**
             * Calls StoreFileToPeer.
             * @function storeFileToPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IStroeFileToPeerRequest} request StroeFileToPeerRequest message or plain object
             * @returns {Promise<dcnet.pb.StroeFileToPeerReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#accountBindBackup}.
             * @memberof dcnet.pb.Service
             * @typedef AccountBindBackupCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AccountDealBackupReply} [response] AccountDealBackupReply
             */

            /**
             * Calls AccountBindBackup.
             * @function accountBindBackup
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountDealBackupRequest} request AccountDealBackupRequest message or plain object
             * @param {dcnet.pb.Service.AccountBindBackupCallback} callback Node-style callback called with the error, if any, and AccountDealBackupReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.accountBindBackup = function accountBindBackup(request, callback) {
                return this.rpcCall(accountBindBackup, $root.dcnet.pb.AccountDealBackupRequest, $root.dcnet.pb.AccountDealBackupReply, request, callback);
            }, "name", { value: "AccountBindBackup" });

            /**
             * Calls AccountBindBackup.
             * @function accountBindBackup
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountDealBackupRequest} request AccountDealBackupRequest message or plain object
             * @returns {Promise<dcnet.pb.AccountDealBackupReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#accountInfoModifyBackup}.
             * @memberof dcnet.pb.Service
             * @typedef AccountInfoModifyBackupCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AccountDealBackupReply} [response] AccountDealBackupReply
             */

            /**
             * Calls AccountInfoModifyBackup.
             * @function accountInfoModifyBackup
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountDealBackupRequest} request AccountDealBackupRequest message or plain object
             * @param {dcnet.pb.Service.AccountInfoModifyBackupCallback} callback Node-style callback called with the error, if any, and AccountDealBackupReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.accountInfoModifyBackup = function accountInfoModifyBackup(request, callback) {
                return this.rpcCall(accountInfoModifyBackup, $root.dcnet.pb.AccountDealBackupRequest, $root.dcnet.pb.AccountDealBackupReply, request, callback);
            }, "name", { value: "AccountInfoModifyBackup" });

            /**
             * Calls AccountInfoModifyBackup.
             * @function accountInfoModifyBackup
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountDealBackupRequest} request AccountDealBackupRequest message or plain object
             * @returns {Promise<dcnet.pb.AccountDealBackupReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#onlineStatusCheck}.
             * @memberof dcnet.pb.Service
             * @typedef OnlineStatusCheckCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.OnlineStatusCheckReply} [response] OnlineStatusCheckReply
             */

            /**
             * Calls OnlineStatusCheck.
             * @function onlineStatusCheck
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IOnlineStatusCheckRequest} request OnlineStatusCheckRequest message or plain object
             * @param {dcnet.pb.Service.OnlineStatusCheckCallback} callback Node-style callback called with the error, if any, and OnlineStatusCheckReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.onlineStatusCheck = function onlineStatusCheck(request, callback) {
                return this.rpcCall(onlineStatusCheck, $root.dcnet.pb.OnlineStatusCheckRequest, $root.dcnet.pb.OnlineStatusCheckReply, request, callback);
            }, "name", { value: "OnlineStatusCheck" });

            /**
             * Calls OnlineStatusCheck.
             * @function onlineStatusCheck
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IOnlineStatusCheckRequest} request OnlineStatusCheckRequest message or plain object
             * @returns {Promise<dcnet.pb.OnlineStatusCheckReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#teeReportVerify}.
             * @memberof dcnet.pb.Service
             * @typedef TeeReportVerifyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.TeeReportVerifyReply} [response] TeeReportVerifyReply
             */

            /**
             * Calls TeeReportVerify.
             * @function teeReportVerify
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ITeeReportVerifyRequest} request TeeReportVerifyRequest message or plain object
             * @param {dcnet.pb.Service.TeeReportVerifyCallback} callback Node-style callback called with the error, if any, and TeeReportVerifyReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.teeReportVerify = function teeReportVerify(request, callback) {
                return this.rpcCall(teeReportVerify, $root.dcnet.pb.TeeReportVerifyRequest, $root.dcnet.pb.TeeReportVerifyReply, request, callback);
            }, "name", { value: "TeeReportVerify" });

            /**
             * Calls TeeReportVerify.
             * @function teeReportVerify
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ITeeReportVerifyRequest} request TeeReportVerifyRequest message or plain object
             * @returns {Promise<dcnet.pb.TeeReportVerifyReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#checkPeerStatus}.
             * @memberof dcnet.pb.Service
             * @typedef CheckPeerStatusCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.CheckPeerStatusReply} [response] CheckPeerStatusReply
             */

            /**
             * Calls CheckPeerStatus.
             * @function checkPeerStatus
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ICheckPeerStatusRequest} request CheckPeerStatusRequest message or plain object
             * @param {dcnet.pb.Service.CheckPeerStatusCallback} callback Node-style callback called with the error, if any, and CheckPeerStatusReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.checkPeerStatus = function checkPeerStatus(request, callback) {
                return this.rpcCall(checkPeerStatus, $root.dcnet.pb.CheckPeerStatusRequest, $root.dcnet.pb.CheckPeerStatusReply, request, callback);
            }, "name", { value: "CheckPeerStatus" });

            /**
             * Calls CheckPeerStatus.
             * @function checkPeerStatus
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ICheckPeerStatusRequest} request CheckPeerStatusRequest message or plain object
             * @returns {Promise<dcnet.pb.CheckPeerStatusReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#localFileCheck}.
             * @memberof dcnet.pb.Service
             * @typedef LocalFileCheckCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.LocalFileCheckReply} [response] LocalFileCheckReply
             */

            /**
             * Calls LocalFileCheck.
             * @function localFileCheck
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ILocalFileCheckRequest} request LocalFileCheckRequest message or plain object
             * @param {dcnet.pb.Service.LocalFileCheckCallback} callback Node-style callback called with the error, if any, and LocalFileCheckReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.localFileCheck = function localFileCheck(request, callback) {
                return this.rpcCall(localFileCheck, $root.dcnet.pb.LocalFileCheckRequest, $root.dcnet.pb.LocalFileCheckReply, request, callback);
            }, "name", { value: "LocalFileCheck" });

            /**
             * Calls LocalFileCheck.
             * @function localFileCheck
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ILocalFileCheckRequest} request LocalFileCheckRequest message or plain object
             * @returns {Promise<dcnet.pb.LocalFileCheckReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getPeersWithSid}.
             * @memberof dcnet.pb.Service
             * @typedef GetPeersWithSidCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetPeersWithSidReply} [response] GetPeersWithSidReply
             */

            /**
             * Calls GetPeersWithSid.
             * @function getPeersWithSid
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetPeersWithSidRequest} request GetPeersWithSidRequest message or plain object
             * @param {dcnet.pb.Service.GetPeersWithSidCallback} callback Node-style callback called with the error, if any, and GetPeersWithSidReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getPeersWithSid = function getPeersWithSid(request, callback) {
                return this.rpcCall(getPeersWithSid, $root.dcnet.pb.GetPeersWithSidRequest, $root.dcnet.pb.GetPeersWithSidReply, request, callback);
            }, "name", { value: "GetPeersWithSid" });

            /**
             * Calls GetPeersWithSid.
             * @function getPeersWithSid
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetPeersWithSidRequest} request GetPeersWithSidRequest message or plain object
             * @returns {Promise<dcnet.pb.GetPeersWithSidReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getPeersWithAccountHash}.
             * @memberof dcnet.pb.Service
             * @typedef GetPeersWithAccountHashCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetPeersWithAccountHashReply} [response] GetPeersWithAccountHashReply
             */

            /**
             * Calls GetPeersWithAccountHash.
             * @function getPeersWithAccountHash
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetPeersWithAccountHashRequest} request GetPeersWithAccountHashRequest message or plain object
             * @param {dcnet.pb.Service.GetPeersWithAccountHashCallback} callback Node-style callback called with the error, if any, and GetPeersWithAccountHashReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getPeersWithAccountHash = function getPeersWithAccountHash(request, callback) {
                return this.rpcCall(getPeersWithAccountHash, $root.dcnet.pb.GetPeersWithAccountHashRequest, $root.dcnet.pb.GetPeersWithAccountHashReply, request, callback);
            }, "name", { value: "GetPeersWithAccountHash" });

            /**
             * Calls GetPeersWithAccountHash.
             * @function getPeersWithAccountHash
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetPeersWithAccountHashRequest} request GetPeersWithAccountHashRequest message or plain object
             * @returns {Promise<dcnet.pb.GetPeersWithAccountHashReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#localAccountInfoCheck}.
             * @memberof dcnet.pb.Service
             * @typedef LocalAccountInfoCheckCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.LocalAccountInfoCheckReply} [response] LocalAccountInfoCheckReply
             */

            /**
             * Calls LocalAccountInfoCheck.
             * @function localAccountInfoCheck
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ILocalAccountInfoCheckRequest} request LocalAccountInfoCheckRequest message or plain object
             * @param {dcnet.pb.Service.LocalAccountInfoCheckCallback} callback Node-style callback called with the error, if any, and LocalAccountInfoCheckReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.localAccountInfoCheck = function localAccountInfoCheck(request, callback) {
                return this.rpcCall(localAccountInfoCheck, $root.dcnet.pb.LocalAccountInfoCheckRequest, $root.dcnet.pb.LocalAccountInfoCheckReply, request, callback);
            }, "name", { value: "LocalAccountInfoCheck" });

            /**
             * Calls LocalAccountInfoCheck.
             * @function localAccountInfoCheck
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ILocalAccountInfoCheckRequest} request LocalAccountInfoCheckRequest message or plain object
             * @returns {Promise<dcnet.pb.LocalAccountInfoCheckReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#accountInfoSync}.
             * @memberof dcnet.pb.Service
             * @typedef AccountInfoSyncCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AccountInfoSyncReply} [response] AccountInfoSyncReply
             */

            /**
             * Calls AccountInfoSync.
             * @function accountInfoSync
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountInfoSyncRequest} request AccountInfoSyncRequest message or plain object
             * @param {dcnet.pb.Service.AccountInfoSyncCallback} callback Node-style callback called with the error, if any, and AccountInfoSyncReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.accountInfoSync = function accountInfoSync(request, callback) {
                return this.rpcCall(accountInfoSync, $root.dcnet.pb.AccountInfoSyncRequest, $root.dcnet.pb.AccountInfoSyncReply, request, callback);
            }, "name", { value: "AccountInfoSync" });

            /**
             * Calls AccountInfoSync.
             * @function accountInfoSync
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountInfoSyncRequest} request AccountInfoSyncRequest message or plain object
             * @returns {Promise<dcnet.pb.AccountInfoSyncReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#setEncryptKeyWithScan}.
             * @memberof dcnet.pb.Service
             * @typedef SetEncryptKeyWithScanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.SetEncryptKeyWithScanReply} [response] SetEncryptKeyWithScanReply
             */

            /**
             * Calls SetEncryptKeyWithScan.
             * @function setEncryptKeyWithScan
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISetEncryptKeyWithScanRequest} request SetEncryptKeyWithScanRequest message or plain object
             * @param {dcnet.pb.Service.SetEncryptKeyWithScanCallback} callback Node-style callback called with the error, if any, and SetEncryptKeyWithScanReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.setEncryptKeyWithScan = function setEncryptKeyWithScan(request, callback) {
                return this.rpcCall(setEncryptKeyWithScan, $root.dcnet.pb.SetEncryptKeyWithScanRequest, $root.dcnet.pb.SetEncryptKeyWithScanReply, request, callback);
            }, "name", { value: "SetEncryptKeyWithScan" });

            /**
             * Calls SetEncryptKeyWithScan.
             * @function setEncryptKeyWithScan
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISetEncryptKeyWithScanRequest} request SetEncryptKeyWithScanRequest message or plain object
             * @returns {Promise<dcnet.pb.SetEncryptKeyWithScanReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getEncryptKeyWithScan}.
             * @memberof dcnet.pb.Service
             * @typedef GetEncryptKeyWithScanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetEncryptKeyWithScanReply} [response] GetEncryptKeyWithScanReply
             */

            /**
             * Calls GetEncryptKeyWithScan.
             * @function getEncryptKeyWithScan
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetEncryptKeyWithScanRequest} request GetEncryptKeyWithScanRequest message or plain object
             * @param {dcnet.pb.Service.GetEncryptKeyWithScanCallback} callback Node-style callback called with the error, if any, and GetEncryptKeyWithScanReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getEncryptKeyWithScan = function getEncryptKeyWithScan(request, callback) {
                return this.rpcCall(getEncryptKeyWithScan, $root.dcnet.pb.GetEncryptKeyWithScanRequest, $root.dcnet.pb.GetEncryptKeyWithScanReply, request, callback);
            }, "name", { value: "GetEncryptKeyWithScan" });

            /**
             * Calls GetEncryptKeyWithScan.
             * @function getEncryptKeyWithScan
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetEncryptKeyWithScanRequest} request GetEncryptKeyWithScanRequest message or plain object
             * @returns {Promise<dcnet.pb.GetEncryptKeyWithScanReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#requestRandEncryptKey}.
             * @memberof dcnet.pb.Service
             * @typedef RequestRandEncryptKeyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.RequestRandEncryptKeyReply} [response] RequestRandEncryptKeyReply
             */

            /**
             * Calls RequestRandEncryptKey.
             * @function requestRandEncryptKey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IRequestRandEncryptKeyRequest} request RequestRandEncryptKeyRequest message or plain object
             * @param {dcnet.pb.Service.RequestRandEncryptKeyCallback} callback Node-style callback called with the error, if any, and RequestRandEncryptKeyReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.requestRandEncryptKey = function requestRandEncryptKey(request, callback) {
                return this.rpcCall(requestRandEncryptKey, $root.dcnet.pb.RequestRandEncryptKeyRequest, $root.dcnet.pb.RequestRandEncryptKeyReply, request, callback);
            }, "name", { value: "RequestRandEncryptKey" });

            /**
             * Calls RequestRandEncryptKey.
             * @function requestRandEncryptKey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IRequestRandEncryptKeyRequest} request RequestRandEncryptKeyRequest message or plain object
             * @returns {Promise<dcnet.pb.RequestRandEncryptKeyReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getEncryptKey}.
             * @memberof dcnet.pb.Service
             * @typedef GetEncryptKeyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetEncryptKeyReply} [response] GetEncryptKeyReply
             */

            /**
             * Calls GetEncryptKey.
             * @function getEncryptKey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetEncryptKeyRequest} request GetEncryptKeyRequest message or plain object
             * @param {dcnet.pb.Service.GetEncryptKeyCallback} callback Node-style callback called with the error, if any, and GetEncryptKeyReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getEncryptKey = function getEncryptKey(request, callback) {
                return this.rpcCall(getEncryptKey, $root.dcnet.pb.GetEncryptKeyRequest, $root.dcnet.pb.GetEncryptKeyReply, request, callback);
            }, "name", { value: "GetEncryptKey" });

            /**
             * Calls GetEncryptKey.
             * @function getEncryptKey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetEncryptKeyRequest} request GetEncryptKeyRequest message or plain object
             * @returns {Promise<dcnet.pb.GetEncryptKeyReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#reportLocalMultilAddr}.
             * @memberof dcnet.pb.Service
             * @typedef ReportLocalMultilAddrCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.ReportLocalMultilAddrReply} [response] ReportLocalMultilAddrReply
             */

            /**
             * Calls ReportLocalMultilAddr.
             * @function reportLocalMultilAddr
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IReportLocalMultilAddrRequest} request ReportLocalMultilAddrRequest message or plain object
             * @param {dcnet.pb.Service.ReportLocalMultilAddrCallback} callback Node-style callback called with the error, if any, and ReportLocalMultilAddrReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.reportLocalMultilAddr = function reportLocalMultilAddr(request, callback) {
                return this.rpcCall(reportLocalMultilAddr, $root.dcnet.pb.ReportLocalMultilAddrRequest, $root.dcnet.pb.ReportLocalMultilAddrReply, request, callback);
            }, "name", { value: "ReportLocalMultilAddr" });

            /**
             * Calls ReportLocalMultilAddr.
             * @function reportLocalMultilAddr
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IReportLocalMultilAddrRequest} request ReportLocalMultilAddrRequest message or plain object
             * @returns {Promise<dcnet.pb.ReportLocalMultilAddrReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getHostID}.
             * @memberof dcnet.pb.Service
             * @typedef GetHostIDCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetHostIDReply} [response] GetHostIDReply
             */

            /**
             * Calls GetHostID.
             * @function getHostID
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetHostIDRequest} request GetHostIDRequest message or plain object
             * @param {dcnet.pb.Service.GetHostIDCallback} callback Node-style callback called with the error, if any, and GetHostIDReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getHostID = function getHostID(request, callback) {
                return this.rpcCall(getHostID, $root.dcnet.pb.GetHostIDRequest, $root.dcnet.pb.GetHostIDReply, request, callback);
            }, "name", { value: "GetHostID" });

            /**
             * Calls GetHostID.
             * @function getHostID
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetHostIDRequest} request GetHostIDRequest message or plain object
             * @returns {Promise<dcnet.pb.GetHostIDReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getToken}.
             * @memberof dcnet.pb.Service
             * @typedef GetTokenCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetTokenReply} [response] GetTokenReply
             */

            /**
             * Calls GetToken.
             * @function getToken
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetTokenRequest} request GetTokenRequest message or plain object
             * @param {dcnet.pb.Service.GetTokenCallback} callback Node-style callback called with the error, if any, and GetTokenReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getToken = function getToken(request, callback) {
                return this.rpcCall(getToken, $root.dcnet.pb.GetTokenRequest, $root.dcnet.pb.GetTokenReply, request, callback);
            }, "name", { value: "GetToken" });

            /**
             * Calls GetToken.
             * @function getToken
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetTokenRequest} request GetTokenRequest message or plain object
             * @returns {Promise<dcnet.pb.GetTokenReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#createThread}.
             * @memberof dcnet.pb.Service
             * @typedef CreateThreadCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.ThreadInfoReply} [response] ThreadInfoReply
             */

            /**
             * Calls CreateThread.
             * @function createThread
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ICreateThreadRequest} request CreateThreadRequest message or plain object
             * @param {dcnet.pb.Service.CreateThreadCallback} callback Node-style callback called with the error, if any, and ThreadInfoReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.createThread = function createThread(request, callback) {
                return this.rpcCall(createThread, $root.dcnet.pb.CreateThreadRequest, $root.dcnet.pb.ThreadInfoReply, request, callback);
            }, "name", { value: "CreateThread" });

            /**
             * Calls CreateThread.
             * @function createThread
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ICreateThreadRequest} request CreateThreadRequest message or plain object
             * @returns {Promise<dcnet.pb.ThreadInfoReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#requestThreadID}.
             * @memberof dcnet.pb.Service
             * @typedef RequestThreadIDCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.ThreadIDReply} [response] ThreadIDReply
             */

            /**
             * Calls RequestThreadID.
             * @function requestThreadID
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IThreadIDRequest} request ThreadIDRequest message or plain object
             * @param {dcnet.pb.Service.RequestThreadIDCallback} callback Node-style callback called with the error, if any, and ThreadIDReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.requestThreadID = function requestThreadID(request, callback) {
                return this.rpcCall(requestThreadID, $root.dcnet.pb.ThreadIDRequest, $root.dcnet.pb.ThreadIDReply, request, callback);
            }, "name", { value: "RequestThreadID" });

            /**
             * Calls RequestThreadID.
             * @function requestThreadID
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IThreadIDRequest} request ThreadIDRequest message or plain object
             * @returns {Promise<dcnet.pb.ThreadIDReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#addLogToThread}.
             * @memberof dcnet.pb.Service
             * @typedef AddLogToThreadCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AddLogToThreadReply} [response] AddLogToThreadReply
             */

            /**
             * Calls AddLogToThread.
             * @function addLogToThread
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddLogToThreadRequest} request AddLogToThreadRequest message or plain object
             * @param {dcnet.pb.Service.AddLogToThreadCallback} callback Node-style callback called with the error, if any, and AddLogToThreadReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.addLogToThread = function addLogToThread(request, callback) {
                return this.rpcCall(addLogToThread, $root.dcnet.pb.AddLogToThreadRequest, $root.dcnet.pb.AddLogToThreadReply, request, callback);
            }, "name", { value: "AddLogToThread" });

            /**
             * Calls AddLogToThread.
             * @function addLogToThread
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddLogToThreadRequest} request AddLogToThreadRequest message or plain object
             * @returns {Promise<dcnet.pb.AddLogToThreadReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getThreadUsedSpace}.
             * @memberof dcnet.pb.Service
             * @typedef GetThreadUsedSpaceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetThreadUsedSpaceReply} [response] GetThreadUsedSpaceReply
             */

            /**
             * Calls GetThreadUsedSpace.
             * @function getThreadUsedSpace
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThreadUsedSpaceRequest} request GetThreadUsedSpaceRequest message or plain object
             * @param {dcnet.pb.Service.GetThreadUsedSpaceCallback} callback Node-style callback called with the error, if any, and GetThreadUsedSpaceReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getThreadUsedSpace = function getThreadUsedSpace(request, callback) {
                return this.rpcCall(getThreadUsedSpace, $root.dcnet.pb.GetThreadUsedSpaceRequest, $root.dcnet.pb.GetThreadUsedSpaceReply, request, callback);
            }, "name", { value: "GetThreadUsedSpace" });

            /**
             * Calls GetThreadUsedSpace.
             * @function getThreadUsedSpace
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThreadUsedSpaceRequest} request GetThreadUsedSpaceRequest message or plain object
             * @returns {Promise<dcnet.pb.GetThreadUsedSpaceReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#addThreadToPeer}.
             * @memberof dcnet.pb.Service
             * @typedef AddThreadToPeerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AddThreadToPeerReply} [response] AddThreadToPeerReply
             */

            /**
             * Calls AddThreadToPeer.
             * @function addThreadToPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddThreadToPeerRequest} request AddThreadToPeerRequest message or plain object
             * @param {dcnet.pb.Service.AddThreadToPeerCallback} callback Node-style callback called with the error, if any, and AddThreadToPeerReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.addThreadToPeer = function addThreadToPeer(request, callback) {
                return this.rpcCall(addThreadToPeer, $root.dcnet.pb.AddThreadToPeerRequest, $root.dcnet.pb.AddThreadToPeerReply, request, callback);
            }, "name", { value: "AddThreadToPeer" });

            /**
             * Calls AddThreadToPeer.
             * @function addThreadToPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddThreadToPeerRequest} request AddThreadToPeerRequest message or plain object
             * @returns {Promise<dcnet.pb.AddThreadToPeerReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getThread}.
             * @memberof dcnet.pb.Service
             * @typedef GetThreadCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.ThreadInfoReply} [response] ThreadInfoReply
             */

            /**
             * Calls GetThread.
             * @function getThread
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThreadRequest} request GetThreadRequest message or plain object
             * @param {dcnet.pb.Service.GetThreadCallback} callback Node-style callback called with the error, if any, and ThreadInfoReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getThread = function getThread(request, callback) {
                return this.rpcCall(getThread, $root.dcnet.pb.GetThreadRequest, $root.dcnet.pb.ThreadInfoReply, request, callback);
            }, "name", { value: "GetThread" });

            /**
             * Calls GetThread.
             * @function getThread
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThreadRequest} request GetThreadRequest message or plain object
             * @returns {Promise<dcnet.pb.ThreadInfoReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#deleteThread}.
             * @memberof dcnet.pb.Service
             * @typedef DeleteThreadCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DeleteThreadReply} [response] DeleteThreadReply
             */

            /**
             * Calls DeleteThread.
             * @function deleteThread
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteThreadRequest} request DeleteThreadRequest message or plain object
             * @param {dcnet.pb.Service.DeleteThreadCallback} callback Node-style callback called with the error, if any, and DeleteThreadReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.deleteThread = function deleteThread(request, callback) {
                return this.rpcCall(deleteThread, $root.dcnet.pb.DeleteThreadRequest, $root.dcnet.pb.DeleteThreadReply, request, callback);
            }, "name", { value: "DeleteThread" });

            /**
             * Calls DeleteThread.
             * @function deleteThread
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteThreadRequest} request DeleteThreadRequest message or plain object
             * @returns {Promise<dcnet.pb.DeleteThreadReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#addThreadSpace}.
             * @memberof dcnet.pb.Service
             * @typedef AddThreadSpaceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AddThreadSpaceReply} [response] AddThreadSpaceReply
             */

            /**
             * Calls AddThreadSpace.
             * @function addThreadSpace
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddThreadSpaceRequest} request AddThreadSpaceRequest message or plain object
             * @param {dcnet.pb.Service.AddThreadSpaceCallback} callback Node-style callback called with the error, if any, and AddThreadSpaceReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.addThreadSpace = function addThreadSpace(request, callback) {
                return this.rpcCall(addThreadSpace, $root.dcnet.pb.AddThreadSpaceRequest, $root.dcnet.pb.AddThreadSpaceReply, request, callback);
            }, "name", { value: "AddThreadSpace" });

            /**
             * Calls AddThreadSpace.
             * @function addThreadSpace
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddThreadSpaceRequest} request AddThreadSpaceRequest message or plain object
             * @returns {Promise<dcnet.pb.AddThreadSpaceReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#storeFile}.
             * @memberof dcnet.pb.Service
             * @typedef StoreFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.StroeFileReply} [response] StroeFileReply
             */

            /**
             * Calls StoreFile.
             * @function storeFile
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IStroeFileRequest} request StroeFileRequest message or plain object
             * @param {dcnet.pb.Service.StoreFileCallback} callback Node-style callback called with the error, if any, and StroeFileReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.storeFile = function storeFile(request, callback) {
                return this.rpcCall(storeFile, $root.dcnet.pb.StroeFileRequest, $root.dcnet.pb.StroeFileReply, request, callback);
            }, "name", { value: "StoreFile" });

            /**
             * Calls StoreFile.
             * @function storeFile
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IStroeFileRequest} request StroeFileRequest message or plain object
             * @returns {Promise<dcnet.pb.StroeFileReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#storeFolder}.
             * @memberof dcnet.pb.Service
             * @typedef StoreFolderCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.StoreFolderReply} [response] StoreFolderReply
             */

            /**
             * Calls StoreFolder.
             * @function storeFolder
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IStoreFolderRequest} request StoreFolderRequest message or plain object
             * @param {dcnet.pb.Service.StoreFolderCallback} callback Node-style callback called with the error, if any, and StoreFolderReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.storeFolder = function storeFolder(request, callback) {
                return this.rpcCall(storeFolder, $root.dcnet.pb.StoreFolderRequest, $root.dcnet.pb.StoreFolderReply, request, callback);
            }, "name", { value: "StoreFolder" });

            /**
             * Calls StoreFolder.
             * @function storeFolder
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IStoreFolderRequest} request StoreFolderRequest message or plain object
             * @returns {Promise<dcnet.pb.StoreFolderReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#deleteFile}.
             * @memberof dcnet.pb.Service
             * @typedef DeleteFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DeleteFileReply} [response] DeleteFileReply
             */

            /**
             * Calls DeleteFile.
             * @function deleteFile
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteFileRequest} request DeleteFileRequest message or plain object
             * @param {dcnet.pb.Service.DeleteFileCallback} callback Node-style callback called with the error, if any, and DeleteFileReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.deleteFile = function deleteFile(request, callback) {
                return this.rpcCall(deleteFile, $root.dcnet.pb.DeleteFileRequest, $root.dcnet.pb.DeleteFileReply, request, callback);
            }, "name", { value: "DeleteFile" });

            /**
             * Calls DeleteFile.
             * @function deleteFile
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteFileRequest} request DeleteFileRequest message or plain object
             * @returns {Promise<dcnet.pb.DeleteFileReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#accountBind}.
             * @memberof dcnet.pb.Service
             * @typedef AccountBindCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AccountDealReply} [response] AccountDealReply
             */

            /**
             * Calls AccountBind.
             * @function accountBind
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountDealRequest} request AccountDealRequest message or plain object
             * @param {dcnet.pb.Service.AccountBindCallback} callback Node-style callback called with the error, if any, and AccountDealReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.accountBind = function accountBind(request, callback) {
                return this.rpcCall(accountBind, $root.dcnet.pb.AccountDealRequest, $root.dcnet.pb.AccountDealReply, request, callback);
            }, "name", { value: "AccountBind" });

            /**
             * Calls AccountBind.
             * @function accountBind
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountDealRequest} request AccountDealRequest message or plain object
             * @returns {Promise<dcnet.pb.AccountDealReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#accountInfoModify}.
             * @memberof dcnet.pb.Service
             * @typedef AccountInfoModifyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AccountDealReply} [response] AccountDealReply
             */

            /**
             * Calls AccountInfoModify.
             * @function accountInfoModify
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountDealRequest} request AccountDealRequest message or plain object
             * @param {dcnet.pb.Service.AccountInfoModifyCallback} callback Node-style callback called with the error, if any, and AccountDealReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.accountInfoModify = function accountInfoModify(request, callback) {
                return this.rpcCall(accountInfoModify, $root.dcnet.pb.AccountDealRequest, $root.dcnet.pb.AccountDealReply, request, callback);
            }, "name", { value: "AccountInfoModify" });

            /**
             * Calls AccountInfoModify.
             * @function accountInfoModify
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountDealRequest} request AccountDealRequest message or plain object
             * @returns {Promise<dcnet.pb.AccountDealReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#accountLogin}.
             * @memberof dcnet.pb.Service
             * @typedef AccountLoginCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AccountLoginReply} [response] AccountLoginReply
             */

            /**
             * Calls AccountLogin.
             * @function accountLogin
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountLoginRequest} request AccountLoginRequest message or plain object
             * @param {dcnet.pb.Service.AccountLoginCallback} callback Node-style callback called with the error, if any, and AccountLoginReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.accountLogin = function accountLogin(request, callback) {
                return this.rpcCall(accountLogin, $root.dcnet.pb.AccountLoginRequest, $root.dcnet.pb.AccountLoginReply, request, callback);
            }, "name", { value: "AccountLogin" });

            /**
             * Calls AccountLogin.
             * @function accountLogin
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAccountLoginRequest} request AccountLoginRequest message or plain object
             * @returns {Promise<dcnet.pb.AccountLoginReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#transferAccount}.
             * @memberof dcnet.pb.Service
             * @typedef TransferAccountCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.TransferAccountReply} [response] TransferAccountReply
             */

            /**
             * Calls TransferAccount.
             * @function transferAccount
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ITransferAccountRequest} request TransferAccountRequest message or plain object
             * @param {dcnet.pb.Service.TransferAccountCallback} callback Node-style callback called with the error, if any, and TransferAccountReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.transferAccount = function transferAccount(request, callback) {
                return this.rpcCall(transferAccount, $root.dcnet.pb.TransferAccountRequest, $root.dcnet.pb.TransferAccountReply, request, callback);
            }, "name", { value: "TransferAccount" });

            /**
             * Calls TransferAccount.
             * @function transferAccount
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ITransferAccountRequest} request TransferAccountRequest message or plain object
             * @returns {Promise<dcnet.pb.TransferAccountReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#addSubPubkey}.
             * @memberof dcnet.pb.Service
             * @typedef AddSubPubkeyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AddSubPubkeyReply} [response] AddSubPubkeyReply
             */

            /**
             * Calls AddSubPubkey.
             * @function addSubPubkey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddSubPubkeyRequest} request AddSubPubkeyRequest message or plain object
             * @param {dcnet.pb.Service.AddSubPubkeyCallback} callback Node-style callback called with the error, if any, and AddSubPubkeyReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.addSubPubkey = function addSubPubkey(request, callback) {
                return this.rpcCall(addSubPubkey, $root.dcnet.pb.AddSubPubkeyRequest, $root.dcnet.pb.AddSubPubkeyReply, request, callback);
            }, "name", { value: "AddSubPubkey" });

            /**
             * Calls AddSubPubkey.
             * @function addSubPubkey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddSubPubkeyRequest} request AddSubPubkeyRequest message or plain object
             * @returns {Promise<dcnet.pb.AddSubPubkeyReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#deleteSubPubkey}.
             * @memberof dcnet.pb.Service
             * @typedef DeleteSubPubkeyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DeleteSubPubkeyReply} [response] DeleteSubPubkeyReply
             */

            /**
             * Calls DeleteSubPubkey.
             * @function deleteSubPubkey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteSubPubkeyRequest} request DeleteSubPubkeyRequest message or plain object
             * @param {dcnet.pb.Service.DeleteSubPubkeyCallback} callback Node-style callback called with the error, if any, and DeleteSubPubkeyReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.deleteSubPubkey = function deleteSubPubkey(request, callback) {
                return this.rpcCall(deleteSubPubkey, $root.dcnet.pb.DeleteSubPubkeyRequest, $root.dcnet.pb.DeleteSubPubkeyReply, request, callback);
            }, "name", { value: "DeleteSubPubkey" });

            /**
             * Calls DeleteSubPubkey.
             * @function deleteSubPubkey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteSubPubkeyRequest} request DeleteSubPubkeyRequest message or plain object
             * @returns {Promise<dcnet.pb.DeleteSubPubkeyReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#bindAccessPeerToUser}.
             * @memberof dcnet.pb.Service
             * @typedef BindAccessPeerToUserCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.BindAccessPeerToUserReply} [response] BindAccessPeerToUserReply
             */

            /**
             * Calls BindAccessPeerToUser.
             * @function bindAccessPeerToUser
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IBindAccessPeerToUserRequest} request BindAccessPeerToUserRequest message or plain object
             * @param {dcnet.pb.Service.BindAccessPeerToUserCallback} callback Node-style callback called with the error, if any, and BindAccessPeerToUserReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.bindAccessPeerToUser = function bindAccessPeerToUser(request, callback) {
                return this.rpcCall(bindAccessPeerToUser, $root.dcnet.pb.BindAccessPeerToUserRequest, $root.dcnet.pb.BindAccessPeerToUserReply, request, callback);
            }, "name", { value: "BindAccessPeerToUser" });

            /**
             * Calls BindAccessPeerToUser.
             * @function bindAccessPeerToUser
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IBindAccessPeerToUserRequest} request BindAccessPeerToUserRequest message or plain object
             * @returns {Promise<dcnet.pb.BindAccessPeerToUserReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#setUserDefaultDB}.
             * @memberof dcnet.pb.Service
             * @typedef SetUserDefaultDBCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.SetUserDefaultDBReply} [response] SetUserDefaultDBReply
             */

            /**
             * Calls SetUserDefaultDB.
             * @function setUserDefaultDB
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISetUserDefaultDBRequest} request SetUserDefaultDBRequest message or plain object
             * @param {dcnet.pb.Service.SetUserDefaultDBCallback} callback Node-style callback called with the error, if any, and SetUserDefaultDBReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.setUserDefaultDB = function setUserDefaultDB(request, callback) {
                return this.rpcCall(setUserDefaultDB, $root.dcnet.pb.SetUserDefaultDBRequest, $root.dcnet.pb.SetUserDefaultDBReply, request, callback);
            }, "name", { value: "SetUserDefaultDB" });

            /**
             * Calls SetUserDefaultDB.
             * @function setUserDefaultDB
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISetUserDefaultDBRequest} request SetUserDefaultDBRequest message or plain object
             * @returns {Promise<dcnet.pb.SetUserDefaultDBReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#sendMsgToUserBox}.
             * @memberof dcnet.pb.Service
             * @typedef SendMsgToUserBoxCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.SendMsgToUserBoxReply} [response] SendMsgToUserBoxReply
             */

            /**
             * Calls SendMsgToUserBox.
             * @function sendMsgToUserBox
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISendMsgToUserBoxRequest} request SendMsgToUserBoxRequest message or plain object
             * @param {dcnet.pb.Service.SendMsgToUserBoxCallback} callback Node-style callback called with the error, if any, and SendMsgToUserBoxReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.sendMsgToUserBox = function sendMsgToUserBox(request, callback) {
                return this.rpcCall(sendMsgToUserBox, $root.dcnet.pb.SendMsgToUserBoxRequest, $root.dcnet.pb.SendMsgToUserBoxReply, request, callback);
            }, "name", { value: "SendMsgToUserBox" });

            /**
             * Calls SendMsgToUserBox.
             * @function sendMsgToUserBox
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISendMsgToUserBoxRequest} request SendMsgToUserBoxRequest message or plain object
             * @returns {Promise<dcnet.pb.SendMsgToUserBoxReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getToUserBoxAuth}.
             * @memberof dcnet.pb.Service
             * @typedef GetToUserBoxAuthCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetToUserBoxAuthReply} [response] GetToUserBoxAuthReply
             */

            /**
             * Calls GetToUserBoxAuth.
             * @function getToUserBoxAuth
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetToUserBoxAuthRequest} request GetToUserBoxAuthRequest message or plain object
             * @param {dcnet.pb.Service.GetToUserBoxAuthCallback} callback Node-style callback called with the error, if any, and GetToUserBoxAuthReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getToUserBoxAuth = function getToUserBoxAuth(request, callback) {
                return this.rpcCall(getToUserBoxAuth, $root.dcnet.pb.GetToUserBoxAuthRequest, $root.dcnet.pb.GetToUserBoxAuthReply, request, callback);
            }, "name", { value: "GetToUserBoxAuth" });

            /**
             * Calls GetToUserBoxAuth.
             * @function getToUserBoxAuth
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetToUserBoxAuthRequest} request GetToUserBoxAuthRequest message or plain object
             * @returns {Promise<dcnet.pb.GetToUserBoxAuthReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getMaxKeyFromUserBox}.
             * @memberof dcnet.pb.Service
             * @typedef GetMaxKeyFromUserBoxCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetMaxKeyFromUserBoxReply} [response] GetMaxKeyFromUserBoxReply
             */

            /**
             * Calls GetMaxKeyFromUserBox.
             * @function getMaxKeyFromUserBox
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetMaxKeyFromUserBoxRequest} request GetMaxKeyFromUserBoxRequest message or plain object
             * @param {dcnet.pb.Service.GetMaxKeyFromUserBoxCallback} callback Node-style callback called with the error, if any, and GetMaxKeyFromUserBoxReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getMaxKeyFromUserBox = function getMaxKeyFromUserBox(request, callback) {
                return this.rpcCall(getMaxKeyFromUserBox, $root.dcnet.pb.GetMaxKeyFromUserBoxRequest, $root.dcnet.pb.GetMaxKeyFromUserBoxReply, request, callback);
            }, "name", { value: "GetMaxKeyFromUserBox" });

            /**
             * Calls GetMaxKeyFromUserBox.
             * @function getMaxKeyFromUserBox
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetMaxKeyFromUserBoxRequest} request GetMaxKeyFromUserBoxRequest message or plain object
             * @returns {Promise<dcnet.pb.GetMaxKeyFromUserBoxReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getMsgFromUserBox}.
             * @memberof dcnet.pb.Service
             * @typedef GetMsgFromUserBoxCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetMsgFromUserBoxReply} [response] GetMsgFromUserBoxReply
             */

            /**
             * Calls GetMsgFromUserBox.
             * @function getMsgFromUserBox
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetMsgFromUserBoxRequest} request GetMsgFromUserBoxRequest message or plain object
             * @param {dcnet.pb.Service.GetMsgFromUserBoxCallback} callback Node-style callback called with the error, if any, and GetMsgFromUserBoxReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getMsgFromUserBox = function getMsgFromUserBox(request, callback) {
                return this.rpcCall(getMsgFromUserBox, $root.dcnet.pb.GetMsgFromUserBoxRequest, $root.dcnet.pb.GetMsgFromUserBoxReply, request, callback);
            }, "name", { value: "GetMsgFromUserBox" });

            /**
             * Calls GetMsgFromUserBox.
             * @function getMsgFromUserBox
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetMsgFromUserBoxRequest} request GetMsgFromUserBoxRequest message or plain object
             * @returns {Promise<dcnet.pb.GetMsgFromUserBoxReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#reportSpamMsg}.
             * @memberof dcnet.pb.Service
             * @typedef ReportSpamMsgCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.ReportSpamMsgReply} [response] ReportSpamMsgReply
             */

            /**
             * Calls ReportSpamMsg.
             * @function reportSpamMsg
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IReportSpamMsgRequest} request ReportSpamMsgRequest message or plain object
             * @param {dcnet.pb.Service.ReportSpamMsgCallback} callback Node-style callback called with the error, if any, and ReportSpamMsgReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.reportSpamMsg = function reportSpamMsg(request, callback) {
                return this.rpcCall(reportSpamMsg, $root.dcnet.pb.ReportSpamMsgRequest, $root.dcnet.pb.ReportSpamMsgReply, request, callback);
            }, "name", { value: "ReportSpamMsg" });

            /**
             * Calls ReportSpamMsg.
             * @function reportSpamMsg
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IReportSpamMsgRequest} request ReportSpamMsgRequest message or plain object
             * @returns {Promise<dcnet.pb.ReportSpamMsgReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#validToken}.
             * @memberof dcnet.pb.Service
             * @typedef ValidTokenCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.ValidTokenReply} [response] ValidTokenReply
             */

            /**
             * Calls ValidToken.
             * @function validToken
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IValidTokenRequest} request ValidTokenRequest message or plain object
             * @param {dcnet.pb.Service.ValidTokenCallback} callback Node-style callback called with the error, if any, and ValidTokenReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.validToken = function validToken(request, callback) {
                return this.rpcCall(validToken, $root.dcnet.pb.ValidTokenRequest, $root.dcnet.pb.ValidTokenReply, request, callback);
            }, "name", { value: "ValidToken" });

            /**
             * Calls ValidToken.
             * @function validToken
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IValidTokenRequest} request ValidTokenRequest message or plain object
             * @returns {Promise<dcnet.pb.ValidTokenReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getUserClientPeers}.
             * @memberof dcnet.pb.Service
             * @typedef GetUserClientPeersCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetUserClientPeersReply} [response] GetUserClientPeersReply
             */

            /**
             * Calls GetUserClientPeers.
             * @function getUserClientPeers
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetUserClientPeersRequest} request GetUserClientPeersRequest message or plain object
             * @param {dcnet.pb.Service.GetUserClientPeersCallback} callback Node-style callback called with the error, if any, and GetUserClientPeersReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getUserClientPeers = function getUserClientPeers(request, callback) {
                return this.rpcCall(getUserClientPeers, $root.dcnet.pb.GetUserClientPeersRequest, $root.dcnet.pb.GetUserClientPeersReply, request, callback);
            }, "name", { value: "GetUserClientPeers" });

            /**
             * Calls GetUserClientPeers.
             * @function getUserClientPeers
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetUserClientPeersRequest} request GetUserClientPeersRequest message or plain object
             * @returns {Promise<dcnet.pb.GetUserClientPeersReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#setCacheKey}.
             * @memberof dcnet.pb.Service
             * @typedef SetCacheKeyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.SetCacheKeyReply} [response] SetCacheKeyReply
             */

            /**
             * Calls SetCacheKey.
             * @function setCacheKey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISetCacheKeyRequest} request SetCacheKeyRequest message or plain object
             * @param {dcnet.pb.Service.SetCacheKeyCallback} callback Node-style callback called with the error, if any, and SetCacheKeyReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.setCacheKey = function setCacheKey(request, callback) {
                return this.rpcCall(setCacheKey, $root.dcnet.pb.SetCacheKeyRequest, $root.dcnet.pb.SetCacheKeyReply, request, callback);
            }, "name", { value: "SetCacheKey" });

            /**
             * Calls SetCacheKey.
             * @function setCacheKey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISetCacheKeyRequest} request SetCacheKeyRequest message or plain object
             * @returns {Promise<dcnet.pb.SetCacheKeyReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getCacheValue}.
             * @memberof dcnet.pb.Service
             * @typedef GetCacheValueCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetCacheValueReply} [response] GetCacheValueReply
             */

            /**
             * Calls GetCacheValue.
             * @function getCacheValue
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetCacheValueRequest} request GetCacheValueRequest message or plain object
             * @param {dcnet.pb.Service.GetCacheValueCallback} callback Node-style callback called with the error, if any, and GetCacheValueReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getCacheValue = function getCacheValue(request, callback) {
                return this.rpcCall(getCacheValue, $root.dcnet.pb.GetCacheValueRequest, $root.dcnet.pb.GetCacheValueReply, request, callback);
            }, "name", { value: "GetCacheValue" });

            /**
             * Calls GetCacheValue.
             * @function getCacheValue
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetCacheValueRequest} request GetCacheValueRequest message or plain object
             * @returns {Promise<dcnet.pb.GetCacheValueReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#addThemeObj}.
             * @memberof dcnet.pb.Service
             * @typedef AddThemeObjCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AddThemeObjReply} [response] AddThemeObjReply
             */

            /**
             * Calls AddThemeObj.
             * @function addThemeObj
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddThemeObjRequest} request AddThemeObjRequest message or plain object
             * @param {dcnet.pb.Service.AddThemeObjCallback} callback Node-style callback called with the error, if any, and AddThemeObjReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.addThemeObj = function addThemeObj(request, callback) {
                return this.rpcCall(addThemeObj, $root.dcnet.pb.AddThemeObjRequest, $root.dcnet.pb.AddThemeObjReply, request, callback);
            }, "name", { value: "AddThemeObj" });

            /**
             * Calls AddThemeObj.
             * @function addThemeObj
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddThemeObjRequest} request AddThemeObjRequest message or plain object
             * @returns {Promise<dcnet.pb.AddThemeObjReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#addThemeSpace}.
             * @memberof dcnet.pb.Service
             * @typedef AddThemeSpaceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AddThemeSpaceReply} [response] AddThemeSpaceReply
             */

            /**
             * Calls AddThemeSpace.
             * @function addThemeSpace
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddThemeSpaceRequest} request AddThemeSpaceRequest message or plain object
             * @param {dcnet.pb.Service.AddThemeSpaceCallback} callback Node-style callback called with the error, if any, and AddThemeSpaceReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.addThemeSpace = function addThemeSpace(request, callback) {
                return this.rpcCall(addThemeSpace, $root.dcnet.pb.AddThemeSpaceRequest, $root.dcnet.pb.AddThemeSpaceReply, request, callback);
            }, "name", { value: "AddThemeSpace" });

            /**
             * Calls AddThemeSpace.
             * @function addThemeSpace
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddThemeSpaceRequest} request AddThemeSpaceRequest message or plain object
             * @returns {Promise<dcnet.pb.AddThemeSpaceReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getThemeSpace}.
             * @memberof dcnet.pb.Service
             * @typedef GetThemeSpaceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetThemeSpaceReply} [response] GetThemeSpaceReply
             */

            /**
             * Calls GetThemeSpace.
             * @function getThemeSpace
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThemeSpaceRequest} request GetThemeSpaceRequest message or plain object
             * @param {dcnet.pb.Service.GetThemeSpaceCallback} callback Node-style callback called with the error, if any, and GetThemeSpaceReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getThemeSpace = function getThemeSpace(request, callback) {
                return this.rpcCall(getThemeSpace, $root.dcnet.pb.GetThemeSpaceRequest, $root.dcnet.pb.GetThemeSpaceReply, request, callback);
            }, "name", { value: "GetThemeSpace" });

            /**
             * Calls GetThemeSpace.
             * @function getThemeSpace
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThemeSpaceRequest} request GetThemeSpaceRequest message or plain object
             * @returns {Promise<dcnet.pb.GetThemeSpaceReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#deleteThemeObj}.
             * @memberof dcnet.pb.Service
             * @typedef DeleteThemeObjCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DeleteThemeObjReply} [response] DeleteThemeObjReply
             */

            /**
             * Calls DeleteThemeObj.
             * @function deleteThemeObj
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteThemeObjRequest} request DeleteThemeObjRequest message or plain object
             * @param {dcnet.pb.Service.DeleteThemeObjCallback} callback Node-style callback called with the error, if any, and DeleteThemeObjReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.deleteThemeObj = function deleteThemeObj(request, callback) {
                return this.rpcCall(deleteThemeObj, $root.dcnet.pb.DeleteThemeObjRequest, $root.dcnet.pb.DeleteThemeObjReply, request, callback);
            }, "name", { value: "DeleteThemeObj" });

            /**
             * Calls DeleteThemeObj.
             * @function deleteThemeObj
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteThemeObjRequest} request DeleteThemeObjRequest message or plain object
             * @returns {Promise<dcnet.pb.DeleteThemeObjReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#reportMaliciousComment}.
             * @memberof dcnet.pb.Service
             * @typedef ReportMaliciousCommentCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.ReportMaliciousCommentReply} [response] ReportMaliciousCommentReply
             */

            /**
             * Calls ReportMaliciousComment.
             * @function reportMaliciousComment
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IReportMaliciousCommentRequest} request ReportMaliciousCommentRequest message or plain object
             * @param {dcnet.pb.Service.ReportMaliciousCommentCallback} callback Node-style callback called with the error, if any, and ReportMaliciousCommentReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.reportMaliciousComment = function reportMaliciousComment(request, callback) {
                return this.rpcCall(reportMaliciousComment, $root.dcnet.pb.ReportMaliciousCommentRequest, $root.dcnet.pb.ReportMaliciousCommentReply, request, callback);
            }, "name", { value: "ReportMaliciousComment" });

            /**
             * Calls ReportMaliciousComment.
             * @function reportMaliciousComment
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IReportMaliciousCommentRequest} request ReportMaliciousCommentRequest message or plain object
             * @returns {Promise<dcnet.pb.ReportMaliciousCommentReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#setObjCommentPublic}.
             * @memberof dcnet.pb.Service
             * @typedef SetObjCommentPublicCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.SetObjCommentPublicReply} [response] SetObjCommentPublicReply
             */

            /**
             * Calls SetObjCommentPublic.
             * @function setObjCommentPublic
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISetObjCommentPublicRequest} request SetObjCommentPublicRequest message or plain object
             * @param {dcnet.pb.Service.SetObjCommentPublicCallback} callback Node-style callback called with the error, if any, and SetObjCommentPublicReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.setObjCommentPublic = function setObjCommentPublic(request, callback) {
                return this.rpcCall(setObjCommentPublic, $root.dcnet.pb.SetObjCommentPublicRequest, $root.dcnet.pb.SetObjCommentPublicReply, request, callback);
            }, "name", { value: "SetObjCommentPublic" });

            /**
             * Calls SetObjCommentPublic.
             * @function setObjCommentPublic
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISetObjCommentPublicRequest} request SetObjCommentPublicRequest message or plain object
             * @returns {Promise<dcnet.pb.SetObjCommentPublicReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#addUserOffChainSpace}.
             * @memberof dcnet.pb.Service
             * @typedef AddUserOffChainSpaceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AddUserOffChainSpaceReply} [response] AddUserOffChainSpaceReply
             */

            /**
             * Calls AddUserOffChainSpace.
             * @function addUserOffChainSpace
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddUserOffChainSpaceRequest} request AddUserOffChainSpaceRequest message or plain object
             * @param {dcnet.pb.Service.AddUserOffChainSpaceCallback} callback Node-style callback called with the error, if any, and AddUserOffChainSpaceReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.addUserOffChainSpace = function addUserOffChainSpace(request, callback) {
                return this.rpcCall(addUserOffChainSpace, $root.dcnet.pb.AddUserOffChainSpaceRequest, $root.dcnet.pb.AddUserOffChainSpaceReply, request, callback);
            }, "name", { value: "AddUserOffChainSpace" });

            /**
             * Calls AddUserOffChainSpace.
             * @function addUserOffChainSpace
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddUserOffChainSpaceRequest} request AddUserOffChainSpaceRequest message or plain object
             * @returns {Promise<dcnet.pb.AddUserOffChainSpaceReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#publishCommentToTheme}.
             * @memberof dcnet.pb.Service
             * @typedef PublishCommentToThemeCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.PublishCommentToThemeReply} [response] PublishCommentToThemeReply
             */

            /**
             * Calls PublishCommentToTheme.
             * @function publishCommentToTheme
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IPublishCommentToThemeRequest} request PublishCommentToThemeRequest message or plain object
             * @param {dcnet.pb.Service.PublishCommentToThemeCallback} callback Node-style callback called with the error, if any, and PublishCommentToThemeReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.publishCommentToTheme = function publishCommentToTheme(request, callback) {
                return this.rpcCall(publishCommentToTheme, $root.dcnet.pb.PublishCommentToThemeRequest, $root.dcnet.pb.PublishCommentToThemeReply, request, callback);
            }, "name", { value: "PublishCommentToTheme" });

            /**
             * Calls PublishCommentToTheme.
             * @function publishCommentToTheme
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IPublishCommentToThemeRequest} request PublishCommentToThemeRequest message or plain object
             * @returns {Promise<dcnet.pb.PublishCommentToThemeReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#configThemeObjAuth}.
             * @memberof dcnet.pb.Service
             * @typedef ConfigThemeObjAuthCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.ConfigThemeObjAuthReply} [response] ConfigThemeObjAuthReply
             */

            /**
             * Calls ConfigThemeObjAuth.
             * @function configThemeObjAuth
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IConfigThemeObjAuthRequest} request ConfigThemeObjAuthRequest message or plain object
             * @param {dcnet.pb.Service.ConfigThemeObjAuthCallback} callback Node-style callback called with the error, if any, and ConfigThemeObjAuthReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.configThemeObjAuth = function configThemeObjAuth(request, callback) {
                return this.rpcCall(configThemeObjAuth, $root.dcnet.pb.ConfigThemeObjAuthRequest, $root.dcnet.pb.ConfigThemeObjAuthReply, request, callback);
            }, "name", { value: "ConfigThemeObjAuth" });

            /**
             * Calls ConfigThemeObjAuth.
             * @function configThemeObjAuth
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IConfigThemeObjAuthRequest} request ConfigThemeObjAuthRequest message or plain object
             * @returns {Promise<dcnet.pb.ConfigThemeObjAuthReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#setKeyValue}.
             * @memberof dcnet.pb.Service
             * @typedef SetKeyValueCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.SetKeyValueReply} [response] SetKeyValueReply
             */

            /**
             * Calls SetKeyValue.
             * @function setKeyValue
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISetKeyValueRequest} request SetKeyValueRequest message or plain object
             * @param {dcnet.pb.Service.SetKeyValueCallback} callback Node-style callback called with the error, if any, and SetKeyValueReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.setKeyValue = function setKeyValue(request, callback) {
                return this.rpcCall(setKeyValue, $root.dcnet.pb.SetKeyValueRequest, $root.dcnet.pb.SetKeyValueReply, request, callback);
            }, "name", { value: "SetKeyValue" });

            /**
             * Calls SetKeyValue.
             * @function setKeyValue
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISetKeyValueRequest} request SetKeyValueRequest message or plain object
             * @returns {Promise<dcnet.pb.SetKeyValueReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#deleteSelfComment}.
             * @memberof dcnet.pb.Service
             * @typedef DeleteSelfCommentCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DeleteSelfCommentReply} [response] DeleteSelfCommentReply
             */

            /**
             * Calls DeleteSelfComment.
             * @function deleteSelfComment
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteSelfCommentRequest} request DeleteSelfCommentRequest message or plain object
             * @param {dcnet.pb.Service.DeleteSelfCommentCallback} callback Node-style callback called with the error, if any, and DeleteSelfCommentReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.deleteSelfComment = function deleteSelfComment(request, callback) {
                return this.rpcCall(deleteSelfComment, $root.dcnet.pb.DeleteSelfCommentRequest, $root.dcnet.pb.DeleteSelfCommentReply, request, callback);
            }, "name", { value: "DeleteSelfComment" });

            /**
             * Calls DeleteSelfComment.
             * @function deleteSelfComment
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteSelfCommentRequest} request DeleteSelfCommentRequest message or plain object
             * @returns {Promise<dcnet.pb.DeleteSelfCommentReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#deleteCommentToObj}.
             * @memberof dcnet.pb.Service
             * @typedef DeleteCommentToObjCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DeleteCommentToObjReply} [response] DeleteCommentToObjReply
             */

            /**
             * Calls DeleteCommentToObj.
             * @function deleteCommentToObj
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteCommentToObjRequest} request DeleteCommentToObjRequest message or plain object
             * @param {dcnet.pb.Service.DeleteCommentToObjCallback} callback Node-style callback called with the error, if any, and DeleteCommentToObjReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.deleteCommentToObj = function deleteCommentToObj(request, callback) {
                return this.rpcCall(deleteCommentToObj, $root.dcnet.pb.DeleteCommentToObjRequest, $root.dcnet.pb.DeleteCommentToObjReply, request, callback);
            }, "name", { value: "DeleteCommentToObj" });

            /**
             * Calls DeleteCommentToObj.
             * @function deleteCommentToObj
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeleteCommentToObjRequest} request DeleteCommentToObjRequest message or plain object
             * @returns {Promise<dcnet.pb.DeleteCommentToObjReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getThemeObj}.
             * @memberof dcnet.pb.Service
             * @typedef GetThemeObjCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetThemeObjReply} [response] GetThemeObjReply
             */

            /**
             * Calls GetThemeObj.
             * @function getThemeObj
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThemeObjRequest} request GetThemeObjRequest message or plain object
             * @param {dcnet.pb.Service.GetThemeObjCallback} callback Node-style callback called with the error, if any, and GetThemeObjReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getThemeObj = function getThemeObj(request, callback) {
                return this.rpcCall(getThemeObj, $root.dcnet.pb.GetThemeObjRequest, $root.dcnet.pb.GetThemeObjReply, request, callback);
            }, "name", { value: "GetThemeObj" });

            /**
             * Calls GetThemeObj.
             * @function getThemeObj
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThemeObjRequest} request GetThemeObjRequest message or plain object
             * @returns {Promise<dcnet.pb.GetThemeObjReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getThemeComments}.
             * @memberof dcnet.pb.Service
             * @typedef GetThemeCommentsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetThemeCommentsReply} [response] GetThemeCommentsReply
             */

            /**
             * Calls GetThemeComments.
             * @function getThemeComments
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThemeCommentsRequest} request GetThemeCommentsRequest message or plain object
             * @param {dcnet.pb.Service.GetThemeCommentsCallback} callback Node-style callback called with the error, if any, and GetThemeCommentsReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getThemeComments = function getThemeComments(request, callback) {
                return this.rpcCall(getThemeComments, $root.dcnet.pb.GetThemeCommentsRequest, $root.dcnet.pb.GetThemeCommentsReply, request, callback);
            }, "name", { value: "GetThemeComments" });

            /**
             * Calls GetThemeComments.
             * @function getThemeComments
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThemeCommentsRequest} request GetThemeCommentsRequest message or plain object
             * @returns {Promise<dcnet.pb.GetThemeCommentsReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getThemeAuthList}.
             * @memberof dcnet.pb.Service
             * @typedef GetThemeAuthListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetThemeAuthListReply} [response] GetThemeAuthListReply
             */

            /**
             * Calls GetThemeAuthList.
             * @function getThemeAuthList
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThemeAuthListRequest} request GetThemeAuthListRequest message or plain object
             * @param {dcnet.pb.Service.GetThemeAuthListCallback} callback Node-style callback called with the error, if any, and GetThemeAuthListReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getThemeAuthList = function getThemeAuthList(request, callback) {
                return this.rpcCall(getThemeAuthList, $root.dcnet.pb.GetThemeAuthListRequest, $root.dcnet.pb.GetThemeAuthListReply, request, callback);
            }, "name", { value: "GetThemeAuthList" });

            /**
             * Calls GetThemeAuthList.
             * @function getThemeAuthList
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThemeAuthListRequest} request GetThemeAuthListRequest message or plain object
             * @returns {Promise<dcnet.pb.GetThemeAuthListReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getUserComments}.
             * @memberof dcnet.pb.Service
             * @typedef GetUserCommentsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetUserCommentsReply} [response] GetUserCommentsReply
             */

            /**
             * Calls GetUserComments.
             * @function getUserComments
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetUserCommentsRequest} request GetUserCommentsRequest message or plain object
             * @param {dcnet.pb.Service.GetUserCommentsCallback} callback Node-style callback called with the error, if any, and GetUserCommentsReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getUserComments = function getUserComments(request, callback) {
                return this.rpcCall(getUserComments, $root.dcnet.pb.GetUserCommentsRequest, $root.dcnet.pb.GetUserCommentsReply, request, callback);
            }, "name", { value: "GetUserComments" });

            /**
             * Calls GetUserComments.
             * @function getUserComments
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetUserCommentsRequest} request GetUserCommentsRequest message or plain object
             * @returns {Promise<dcnet.pb.GetUserCommentsReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getValueWithKey}.
             * @memberof dcnet.pb.Service
             * @typedef GetValueWithKeyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetValueWithKeyReply} [response] GetValueWithKeyReply
             */

            /**
             * Calls GetValueWithKey.
             * @function getValueWithKey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetValueWithKeyRequest} request GetValueWithKeyRequest message or plain object
             * @param {dcnet.pb.Service.GetValueWithKeyCallback} callback Node-style callback called with the error, if any, and GetValueWithKeyReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getValueWithKey = function getValueWithKey(request, callback) {
                return this.rpcCall(getValueWithKey, $root.dcnet.pb.GetValueWithKeyRequest, $root.dcnet.pb.GetValueWithKeyReply, request, callback);
            }, "name", { value: "GetValueWithKey" });

            /**
             * Calls GetValueWithKey.
             * @function getValueWithKey
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetValueWithKeyRequest} request GetValueWithKeyRequest message or plain object
             * @returns {Promise<dcnet.pb.GetValueWithKeyReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getValuesWithKeys}.
             * @memberof dcnet.pb.Service
             * @typedef GetValuesWithKeysCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetValuesWithKeysReply} [response] GetValuesWithKeysReply
             */

            /**
             * Calls GetValuesWithKeys.
             * @function getValuesWithKeys
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetValuesWithKeysRequest} request GetValuesWithKeysRequest message or plain object
             * @param {dcnet.pb.Service.GetValuesWithKeysCallback} callback Node-style callback called with the error, if any, and GetValuesWithKeysReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getValuesWithKeys = function getValuesWithKeys(request, callback) {
                return this.rpcCall(getValuesWithKeys, $root.dcnet.pb.GetValuesWithKeysRequest, $root.dcnet.pb.GetValuesWithKeysReply, request, callback);
            }, "name", { value: "GetValuesWithKeys" });

            /**
             * Calls GetValuesWithKeys.
             * @function getValuesWithKeys
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetValuesWithKeysRequest} request GetValuesWithKeysRequest message or plain object
             * @returns {Promise<dcnet.pb.GetValuesWithKeysReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getValuesWithIndex}.
             * @memberof dcnet.pb.Service
             * @typedef GetValuesWithIndexCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetValuesWithIndexReply} [response] GetValuesWithIndexReply
             */

            /**
             * Calls GetValuesWithIndex.
             * @function getValuesWithIndex
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetValuesWithIndexRequest} request GetValuesWithIndexRequest message or plain object
             * @param {dcnet.pb.Service.GetValuesWithIndexCallback} callback Node-style callback called with the error, if any, and GetValuesWithIndexReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getValuesWithIndex = function getValuesWithIndex(request, callback) {
                return this.rpcCall(getValuesWithIndex, $root.dcnet.pb.GetValuesWithIndexRequest, $root.dcnet.pb.GetValuesWithIndexReply, request, callback);
            }, "name", { value: "GetValuesWithIndex" });

            /**
             * Calls GetValuesWithIndex.
             * @function getValuesWithIndex
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetValuesWithIndexRequest} request GetValuesWithIndexRequest message or plain object
             * @returns {Promise<dcnet.pb.GetValuesWithIndexReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#sendCommentToPeer}.
             * @memberof dcnet.pb.Service
             * @typedef SendCommentToPeerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.PublishCommentToThemeReply} [response] PublishCommentToThemeReply
             */

            /**
             * Calls SendCommentToPeer.
             * @function sendCommentToPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IPublishCommentToThemeRequest} request PublishCommentToThemeRequest message or plain object
             * @param {dcnet.pb.Service.SendCommentToPeerCallback} callback Node-style callback called with the error, if any, and PublishCommentToThemeReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.sendCommentToPeer = function sendCommentToPeer(request, callback) {
                return this.rpcCall(sendCommentToPeer, $root.dcnet.pb.PublishCommentToThemeRequest, $root.dcnet.pb.PublishCommentToThemeReply, request, callback);
            }, "name", { value: "SendCommentToPeer" });

            /**
             * Calls SendCommentToPeer.
             * @function sendCommentToPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IPublishCommentToThemeRequest} request PublishCommentToThemeRequest message or plain object
             * @returns {Promise<dcnet.pb.PublishCommentToThemeReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#pushThemeFunOpt}.
             * @memberof dcnet.pb.Service
             * @typedef PushThemeFunOptCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.PushThemeFunOptReply} [response] PushThemeFunOptReply
             */

            /**
             * Calls PushThemeFunOpt.
             * @function pushThemeFunOpt
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IPushThemeFunOptRequest} request PushThemeFunOptRequest message or plain object
             * @param {dcnet.pb.Service.PushThemeFunOptCallback} callback Node-style callback called with the error, if any, and PushThemeFunOptReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.pushThemeFunOpt = function pushThemeFunOpt(request, callback) {
                return this.rpcCall(pushThemeFunOpt, $root.dcnet.pb.PushThemeFunOptRequest, $root.dcnet.pb.PushThemeFunOptReply, request, callback);
            }, "name", { value: "PushThemeFunOpt" });

            /**
             * Calls PushThemeFunOpt.
             * @function pushThemeFunOpt
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IPushThemeFunOptRequest} request PushThemeFunOptRequest message or plain object
             * @returns {Promise<dcnet.pb.PushThemeFunOptReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#pullCommentFunOpts}.
             * @memberof dcnet.pb.Service
             * @typedef PullCommentFunOptsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.PullCommentFunOptsReply} [response] PullCommentFunOptsReply
             */

            /**
             * Calls PullCommentFunOpts.
             * @function pullCommentFunOpts
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IPullCommentFunOptsRequest} request PullCommentFunOptsRequest message or plain object
             * @param {dcnet.pb.Service.PullCommentFunOptsCallback} callback Node-style callback called with the error, if any, and PullCommentFunOptsReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.pullCommentFunOpts = function pullCommentFunOpts(request, callback) {
                return this.rpcCall(pullCommentFunOpts, $root.dcnet.pb.PullCommentFunOptsRequest, $root.dcnet.pb.PullCommentFunOptsReply, request, callback);
            }, "name", { value: "PullCommentFunOpts" });

            /**
             * Calls PullCommentFunOpts.
             * @function pullCommentFunOpts
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IPullCommentFunOptsRequest} request PullCommentFunOptsRequest message or plain object
             * @returns {Promise<dcnet.pb.PullCommentFunOptsReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#exchangeThemeEdges}.
             * @memberof dcnet.pb.Service
             * @typedef ExchangeThemeEdgesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.ExchangeThemeEdgesReply} [response] ExchangeThemeEdgesReply
             */

            /**
             * Calls ExchangeThemeEdges.
             * @function exchangeThemeEdges
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IExchangeThemeEdgesRequest} request ExchangeThemeEdgesRequest message or plain object
             * @param {dcnet.pb.Service.ExchangeThemeEdgesCallback} callback Node-style callback called with the error, if any, and ExchangeThemeEdgesReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.exchangeThemeEdges = function exchangeThemeEdges(request, callback) {
                return this.rpcCall(exchangeThemeEdges, $root.dcnet.pb.ExchangeThemeEdgesRequest, $root.dcnet.pb.ExchangeThemeEdgesReply, request, callback);
            }, "name", { value: "ExchangeThemeEdges" });

            /**
             * Calls ExchangeThemeEdges.
             * @function exchangeThemeEdges
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IExchangeThemeEdgesRequest} request ExchangeThemeEdgesRequest message or plain object
             * @returns {Promise<dcnet.pb.ExchangeThemeEdgesReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#downloadUserComments}.
             * @memberof dcnet.pb.Service
             * @typedef DownloadUserCommentsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DownloadUserCommentsReply} [response] DownloadUserCommentsReply
             */

            /**
             * Calls DownloadUserComments.
             * @function downloadUserComments
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDownloadUserCommentsRequest} request DownloadUserCommentsRequest message or plain object
             * @param {dcnet.pb.Service.DownloadUserCommentsCallback} callback Node-style callback called with the error, if any, and DownloadUserCommentsReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.downloadUserComments = function downloadUserComments(request, callback) {
                return this.rpcCall(downloadUserComments, $root.dcnet.pb.DownloadUserCommentsRequest, $root.dcnet.pb.DownloadUserCommentsReply, request, callback);
            }, "name", { value: "DownloadUserComments" });

            /**
             * Calls DownloadUserComments.
             * @function downloadUserComments
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDownloadUserCommentsRequest} request DownloadUserCommentsRequest message or plain object
             * @returns {Promise<dcnet.pb.DownloadUserCommentsReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#userCommentsDownloadReady}.
             * @memberof dcnet.pb.Service
             * @typedef UserCommentsDownloadReadyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.UserCommentsDownloadReadyReply} [response] UserCommentsDownloadReadyReply
             */

            /**
             * Calls UserCommentsDownloadReady.
             * @function userCommentsDownloadReady
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IUserCommentsDownloadReadyRequest} request UserCommentsDownloadReadyRequest message or plain object
             * @param {dcnet.pb.Service.UserCommentsDownloadReadyCallback} callback Node-style callback called with the error, if any, and UserCommentsDownloadReadyReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.userCommentsDownloadReady = function userCommentsDownloadReady(request, callback) {
                return this.rpcCall(userCommentsDownloadReady, $root.dcnet.pb.UserCommentsDownloadReadyRequest, $root.dcnet.pb.UserCommentsDownloadReadyReply, request, callback);
            }, "name", { value: "UserCommentsDownloadReady" });

            /**
             * Calls UserCommentsDownloadReady.
             * @function userCommentsDownloadReady
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IUserCommentsDownloadReadyRequest} request UserCommentsDownloadReadyRequest message or plain object
             * @returns {Promise<dcnet.pb.UserCommentsDownloadReadyReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#syncThemeObj}.
             * @memberof dcnet.pb.Service
             * @typedef SyncThemeObjCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.SyncThemeObjReply} [response] SyncThemeObjReply
             */

            /**
             * Calls SyncThemeObj.
             * @function syncThemeObj
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISyncThemeObjRequest} request SyncThemeObjRequest message or plain object
             * @param {dcnet.pb.Service.SyncThemeObjCallback} callback Node-style callback called with the error, if any, and SyncThemeObjReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.syncThemeObj = function syncThemeObj(request, callback) {
                return this.rpcCall(syncThemeObj, $root.dcnet.pb.SyncThemeObjRequest, $root.dcnet.pb.SyncThemeObjReply, request, callback);
            }, "name", { value: "SyncThemeObj" });

            /**
             * Calls SyncThemeObj.
             * @function syncThemeObj
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.ISyncThemeObjRequest} request SyncThemeObjRequest message or plain object
             * @returns {Promise<dcnet.pb.SyncThemeObjReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#deviceStatusReport}.
             * @memberof dcnet.pb.Service
             * @typedef DeviceStatusReportCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DeviceStatusReportReply} [response] DeviceStatusReportReply
             */

            /**
             * Calls DeviceStatusReport.
             * @function deviceStatusReport
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeviceStatusReportRequest} request DeviceStatusReportRequest message or plain object
             * @param {dcnet.pb.Service.DeviceStatusReportCallback} callback Node-style callback called with the error, if any, and DeviceStatusReportReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.deviceStatusReport = function deviceStatusReport(request, callback) {
                return this.rpcCall(deviceStatusReport, $root.dcnet.pb.DeviceStatusReportRequest, $root.dcnet.pb.DeviceStatusReportReply, request, callback);
            }, "name", { value: "DeviceStatusReport" });

            /**
             * Calls DeviceStatusReport.
             * @function deviceStatusReport
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeviceStatusReportRequest} request DeviceStatusReportRequest message or plain object
             * @returns {Promise<dcnet.pb.DeviceStatusReportReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#archiveDeviceStatus}.
             * @memberof dcnet.pb.Service
             * @typedef ArchiveDeviceStatusCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.ArchiveDeviceStatusReply} [response] ArchiveDeviceStatusReply
             */

            /**
             * Calls ArchiveDeviceStatus.
             * @function archiveDeviceStatus
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IArchiveDeviceStatusRequest} request ArchiveDeviceStatusRequest message or plain object
             * @param {dcnet.pb.Service.ArchiveDeviceStatusCallback} callback Node-style callback called with the error, if any, and ArchiveDeviceStatusReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.archiveDeviceStatus = function archiveDeviceStatus(request, callback) {
                return this.rpcCall(archiveDeviceStatus, $root.dcnet.pb.ArchiveDeviceStatusRequest, $root.dcnet.pb.ArchiveDeviceStatusReply, request, callback);
            }, "name", { value: "ArchiveDeviceStatus" });

            /**
             * Calls ArchiveDeviceStatus.
             * @function archiveDeviceStatus
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IArchiveDeviceStatusRequest} request ArchiveDeviceStatusRequest message or plain object
             * @returns {Promise<dcnet.pb.ArchiveDeviceStatusReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#sendDeviceStatusToPeer}.
             * @memberof dcnet.pb.Service
             * @typedef SendDeviceStatusToPeerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DeviceStatusReportReply} [response] DeviceStatusReportReply
             */

            /**
             * Calls SendDeviceStatusToPeer.
             * @function sendDeviceStatusToPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeviceStatusReportRequest} request DeviceStatusReportRequest message or plain object
             * @param {dcnet.pb.Service.SendDeviceStatusToPeerCallback} callback Node-style callback called with the error, if any, and DeviceStatusReportReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.sendDeviceStatusToPeer = function sendDeviceStatusToPeer(request, callback) {
                return this.rpcCall(sendDeviceStatusToPeer, $root.dcnet.pb.DeviceStatusReportRequest, $root.dcnet.pb.DeviceStatusReportReply, request, callback);
            }, "name", { value: "SendDeviceStatusToPeer" });

            /**
             * Calls SendDeviceStatusToPeer.
             * @function sendDeviceStatusToPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeviceStatusReportRequest} request DeviceStatusReportRequest message or plain object
             * @returns {Promise<dcnet.pb.DeviceStatusReportReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getThemeDevicesStatus}.
             * @memberof dcnet.pb.Service
             * @typedef GetThemeDevicesStatusCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetThemeDevicesStatusReply} [response] GetThemeDevicesStatusReply
             */

            /**
             * Calls GetThemeDevicesStatus.
             * @function getThemeDevicesStatus
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThemeDevicesStatusRequest} request GetThemeDevicesStatusRequest message or plain object
             * @param {dcnet.pb.Service.GetThemeDevicesStatusCallback} callback Node-style callback called with the error, if any, and GetThemeDevicesStatusReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getThemeDevicesStatus = function getThemeDevicesStatus(request, callback) {
                return this.rpcCall(getThemeDevicesStatus, $root.dcnet.pb.GetThemeDevicesStatusRequest, $root.dcnet.pb.GetThemeDevicesStatusReply, request, callback);
            }, "name", { value: "GetThemeDevicesStatus" });

            /**
             * Calls GetThemeDevicesStatus.
             * @function getThemeDevicesStatus
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetThemeDevicesStatusRequest} request GetThemeDevicesStatusRequest message or plain object
             * @returns {Promise<dcnet.pb.GetThemeDevicesStatusReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getDeviceAuth}.
             * @memberof dcnet.pb.Service
             * @typedef GetDeviceAuthCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetDeviceAuthReply} [response] GetDeviceAuthReply
             */

            /**
             * Calls GetDeviceAuth.
             * @function getDeviceAuth
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetDeviceAuthRequest} request GetDeviceAuthRequest message or plain object
             * @param {dcnet.pb.Service.GetDeviceAuthCallback} callback Node-style callback called with the error, if any, and GetDeviceAuthReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getDeviceAuth = function getDeviceAuth(request, callback) {
                return this.rpcCall(getDeviceAuth, $root.dcnet.pb.GetDeviceAuthRequest, $root.dcnet.pb.GetDeviceAuthReply, request, callback);
            }, "name", { value: "GetDeviceAuth" });

            /**
             * Calls GetDeviceAuth.
             * @function getDeviceAuth
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetDeviceAuthRequest} request GetDeviceAuthRequest message or plain object
             * @returns {Promise<dcnet.pb.GetDeviceAuthReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getDeviceStatusList}.
             * @memberof dcnet.pb.Service
             * @typedef GetDeviceStatusListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetDeviceStatusListReply} [response] GetDeviceStatusListReply
             */

            /**
             * Calls GetDeviceStatusList.
             * @function getDeviceStatusList
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetDeviceStatusListRequest} request GetDeviceStatusListRequest message or plain object
             * @param {dcnet.pb.Service.GetDeviceStatusListCallback} callback Node-style callback called with the error, if any, and GetDeviceStatusListReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getDeviceStatusList = function getDeviceStatusList(request, callback) {
                return this.rpcCall(getDeviceStatusList, $root.dcnet.pb.GetDeviceStatusListRequest, $root.dcnet.pb.GetDeviceStatusListReply, request, callback);
            }, "name", { value: "GetDeviceStatusList" });

            /**
             * Calls GetDeviceStatusList.
             * @function getDeviceStatusList
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetDeviceStatusListRequest} request GetDeviceStatusListRequest message or plain object
             * @returns {Promise<dcnet.pb.GetDeviceStatusListReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#addUserOffChainOpTimes}.
             * @memberof dcnet.pb.Service
             * @typedef AddUserOffChainOpTimesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.AddUserOffChainOpTimesReply} [response] AddUserOffChainOpTimesReply
             */

            /**
             * Calls AddUserOffChainOpTimes.
             * @function addUserOffChainOpTimes
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddUserOffChainOpTimesRequest} request AddUserOffChainOpTimesRequest message or plain object
             * @param {dcnet.pb.Service.AddUserOffChainOpTimesCallback} callback Node-style callback called with the error, if any, and AddUserOffChainOpTimesReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.addUserOffChainOpTimes = function addUserOffChainOpTimes(request, callback) {
                return this.rpcCall(addUserOffChainOpTimes, $root.dcnet.pb.AddUserOffChainOpTimesRequest, $root.dcnet.pb.AddUserOffChainOpTimesReply, request, callback);
            }, "name", { value: "AddUserOffChainOpTimes" });

            /**
             * Calls AddUserOffChainOpTimes.
             * @function addUserOffChainOpTimes
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IAddUserOffChainOpTimesRequest} request AddUserOffChainOpTimesRequest message or plain object
             * @returns {Promise<dcnet.pb.AddUserOffChainOpTimesReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getUserOffChainOpTimes}.
             * @memberof dcnet.pb.Service
             * @typedef GetUserOffChainOpTimesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetUserOffChainOpTimesReply} [response] GetUserOffChainOpTimesReply
             */

            /**
             * Calls GetUserOffChainOpTimes.
             * @function getUserOffChainOpTimes
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetUserOffChainOpTimesRequest} request GetUserOffChainOpTimesRequest message or plain object
             * @param {dcnet.pb.Service.GetUserOffChainOpTimesCallback} callback Node-style callback called with the error, if any, and GetUserOffChainOpTimesReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getUserOffChainOpTimes = function getUserOffChainOpTimes(request, callback) {
                return this.rpcCall(getUserOffChainOpTimes, $root.dcnet.pb.GetUserOffChainOpTimesRequest, $root.dcnet.pb.GetUserOffChainOpTimesReply, request, callback);
            }, "name", { value: "GetUserOffChainOpTimes" });

            /**
             * Calls GetUserOffChainOpTimes.
             * @function getUserOffChainOpTimes
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetUserOffChainOpTimesRequest} request GetUserOffChainOpTimesRequest message or plain object
             * @returns {Promise<dcnet.pb.GetUserOffChainOpTimesReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getUserOffChainUsedInfo}.
             * @memberof dcnet.pb.Service
             * @typedef GetUserOffChainUsedInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetUserOffChainUsedInfoReply} [response] GetUserOffChainUsedInfoReply
             */

            /**
             * Calls GetUserOffChainUsedInfo.
             * @function getUserOffChainUsedInfo
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetUserOffChainUsedInfoRequest} request GetUserOffChainUsedInfoRequest message or plain object
             * @param {dcnet.pb.Service.GetUserOffChainUsedInfoCallback} callback Node-style callback called with the error, if any, and GetUserOffChainUsedInfoReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getUserOffChainUsedInfo = function getUserOffChainUsedInfo(request, callback) {
                return this.rpcCall(getUserOffChainUsedInfo, $root.dcnet.pb.GetUserOffChainUsedInfoRequest, $root.dcnet.pb.GetUserOffChainUsedInfoReply, request, callback);
            }, "name", { value: "GetUserOffChainUsedInfo" });

            /**
             * Calls GetUserOffChainUsedInfo.
             * @function getUserOffChainUsedInfo
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetUserOffChainUsedInfoRequest} request GetUserOffChainUsedInfoRequest message or plain object
             * @returns {Promise<dcnet.pb.GetUserOffChainUsedInfoReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#reEncryptFile}.
             * @memberof dcnet.pb.Service
             * @typedef ReEncryptFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.ReEncryptFileReply} [response] ReEncryptFileReply
             */

            /**
             * Calls ReEncryptFile.
             * @function reEncryptFile
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IReEncryptFileRequest} request ReEncryptFileRequest message or plain object
             * @param {dcnet.pb.Service.ReEncryptFileCallback} callback Node-style callback called with the error, if any, and ReEncryptFileReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.reEncryptFile = function reEncryptFile(request, callback) {
                return this.rpcCall(reEncryptFile, $root.dcnet.pb.ReEncryptFileRequest, $root.dcnet.pb.ReEncryptFileReply, request, callback);
            }, "name", { value: "ReEncryptFile" });

            /**
             * Calls ReEncryptFile.
             * @function reEncryptFile
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IReEncryptFileRequest} request ReEncryptFileRequest message or plain object
             * @returns {Promise<dcnet.pb.ReEncryptFileReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#requestRandData}.
             * @memberof dcnet.pb.Service
             * @typedef RequestRandDataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.RequestRandDataReply} [response] RequestRandDataReply
             */

            /**
             * Calls RequestRandData.
             * @function requestRandData
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IRequestRandDataRequest} request RequestRandDataRequest message or plain object
             * @param {dcnet.pb.Service.RequestRandDataCallback} callback Node-style callback called with the error, if any, and RequestRandDataReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.requestRandData = function requestRandData(request, callback) {
                return this.rpcCall(requestRandData, $root.dcnet.pb.RequestRandDataRequest, $root.dcnet.pb.RequestRandDataReply, request, callback);
            }, "name", { value: "RequestRandData" });

            /**
             * Calls RequestRandData.
             * @function requestRandData
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IRequestRandDataRequest} request RequestRandDataRequest message or plain object
             * @returns {Promise<dcnet.pb.RequestRandDataReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getAIProxyConfigFromPeer}.
             * @memberof dcnet.pb.Service
             * @typedef GetAIProxyConfigFromPeerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetAIProxyConfigFromPeerReply} [response] GetAIProxyConfigFromPeerReply
             */

            /**
             * Calls GetAIProxyConfigFromPeer.
             * @function getAIProxyConfigFromPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetAIProxyConfigFromPeerRequest} request GetAIProxyConfigFromPeerRequest message or plain object
             * @param {dcnet.pb.Service.GetAIProxyConfigFromPeerCallback} callback Node-style callback called with the error, if any, and GetAIProxyConfigFromPeerReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getAIProxyConfigFromPeer = function getAIProxyConfigFromPeer(request, callback) {
                return this.rpcCall(getAIProxyConfigFromPeer, $root.dcnet.pb.GetAIProxyConfigFromPeerRequest, $root.dcnet.pb.GetAIProxyConfigFromPeerReply, request, callback);
            }, "name", { value: "GetAIProxyConfigFromPeer" });

            /**
             * Calls GetAIProxyConfigFromPeer.
             * @function getAIProxyConfigFromPeer
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetAIProxyConfigFromPeerRequest} request GetAIProxyConfigFromPeerRequest message or plain object
             * @returns {Promise<dcnet.pb.GetAIProxyConfigFromPeerReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getAIProxyConfig}.
             * @memberof dcnet.pb.Service
             * @typedef GetAIProxyConfigCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetAIProxyConfigReply} [response] GetAIProxyConfigReply
             */

            /**
             * Calls GetAIProxyConfig.
             * @function getAIProxyConfig
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetAIProxyConfigRequest} request GetAIProxyConfigRequest message or plain object
             * @param {dcnet.pb.Service.GetAIProxyConfigCallback} callback Node-style callback called with the error, if any, and GetAIProxyConfigReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getAIProxyConfig = function getAIProxyConfig(request, callback) {
                return this.rpcCall(getAIProxyConfig, $root.dcnet.pb.GetAIProxyConfigRequest, $root.dcnet.pb.GetAIProxyConfigReply, request, callback);
            }, "name", { value: "GetAIProxyConfig" });

            /**
             * Calls GetAIProxyConfig.
             * @function getAIProxyConfig
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetAIProxyConfigRequest} request GetAIProxyConfigRequest message or plain object
             * @returns {Promise<dcnet.pb.GetAIProxyConfigReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#doAIProxyCall}.
             * @memberof dcnet.pb.Service
             * @typedef DoAIProxyCallCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DoAIProxyCallReply} [response] DoAIProxyCallReply
             */

            /**
             * Calls DoAIProxyCall.
             * @function doAIProxyCall
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDoAIProxyCallRequest} request DoAIProxyCallRequest message or plain object
             * @param {dcnet.pb.Service.DoAIProxyCallCallback} callback Node-style callback called with the error, if any, and DoAIProxyCallReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.doAIProxyCall = function doAIProxyCall(request, callback) {
                return this.rpcCall(doAIProxyCall, $root.dcnet.pb.DoAIProxyCallRequest, $root.dcnet.pb.DoAIProxyCallReply, request, callback);
            }, "name", { value: "DoAIProxyCall" });

            /**
             * Calls DoAIProxyCall.
             * @function doAIProxyCall
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDoAIProxyCallRequest} request DoAIProxyCallRequest message or plain object
             * @returns {Promise<dcnet.pb.DoAIProxyCallReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#getUserOwnAIProxyAuth}.
             * @memberof dcnet.pb.Service
             * @typedef GetUserOwnAIProxyAuthCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.GetUserOwnAIProxyAuthReply} [response] GetUserOwnAIProxyAuthReply
             */

            /**
             * Calls GetUserOwnAIProxyAuth.
             * @function getUserOwnAIProxyAuth
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetUserOwnAIProxyAuthRequest} request GetUserOwnAIProxyAuthRequest message or plain object
             * @param {dcnet.pb.Service.GetUserOwnAIProxyAuthCallback} callback Node-style callback called with the error, if any, and GetUserOwnAIProxyAuthReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.getUserOwnAIProxyAuth = function getUserOwnAIProxyAuth(request, callback) {
                return this.rpcCall(getUserOwnAIProxyAuth, $root.dcnet.pb.GetUserOwnAIProxyAuthRequest, $root.dcnet.pb.GetUserOwnAIProxyAuthReply, request, callback);
            }, "name", { value: "GetUserOwnAIProxyAuth" });

            /**
             * Calls GetUserOwnAIProxyAuth.
             * @function getUserOwnAIProxyAuth
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IGetUserOwnAIProxyAuthRequest} request GetUserOwnAIProxyAuthRequest message or plain object
             * @returns {Promise<dcnet.pb.GetUserOwnAIProxyAuthReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#deductUserOffChainOpTimes}.
             * @memberof dcnet.pb.Service
             * @typedef DeductUserOffChainOpTimesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DeductUserOffChainOpTimesReply} [response] DeductUserOffChainOpTimesReply
             */

            /**
             * Calls DeductUserOffChainOpTimes.
             * @function deductUserOffChainOpTimes
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeductUserOffChainOpTimesRequest} request DeductUserOffChainOpTimesRequest message or plain object
             * @param {dcnet.pb.Service.DeductUserOffChainOpTimesCallback} callback Node-style callback called with the error, if any, and DeductUserOffChainOpTimesReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.deductUserOffChainOpTimes = function deductUserOffChainOpTimes(request, callback) {
                return this.rpcCall(deductUserOffChainOpTimes, $root.dcnet.pb.DeductUserOffChainOpTimesRequest, $root.dcnet.pb.DeductUserOffChainOpTimesReply, request, callback);
            }, "name", { value: "DeductUserOffChainOpTimes" });

            /**
             * Calls DeductUserOffChainOpTimes.
             * @function deductUserOffChainOpTimes
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeductUserOffChainOpTimesRequest} request DeductUserOffChainOpTimesRequest message or plain object
             * @returns {Promise<dcnet.pb.DeductUserOffChainOpTimesReply>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link dcnet.pb.Service#deductUserAIProxyOpTimes}.
             * @memberof dcnet.pb.Service
             * @typedef DeductUserAIProxyOpTimesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dcnet.pb.DeductUserAIProxyOpTimesReply} [response] DeductUserAIProxyOpTimesReply
             */

            /**
             * Calls DeductUserAIProxyOpTimes.
             * @function deductUserAIProxyOpTimes
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeductUserAIProxyOpTimesRequest} request DeductUserAIProxyOpTimesRequest message or plain object
             * @param {dcnet.pb.Service.DeductUserAIProxyOpTimesCallback} callback Node-style callback called with the error, if any, and DeductUserAIProxyOpTimesReply
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.deductUserAIProxyOpTimes = function deductUserAIProxyOpTimes(request, callback) {
                return this.rpcCall(deductUserAIProxyOpTimes, $root.dcnet.pb.DeductUserAIProxyOpTimesRequest, $root.dcnet.pb.DeductUserAIProxyOpTimesReply, request, callback);
            }, "name", { value: "DeductUserAIProxyOpTimes" });

            /**
             * Calls DeductUserAIProxyOpTimes.
             * @function deductUserAIProxyOpTimes
             * @memberof dcnet.pb.Service
             * @instance
             * @param {dcnet.pb.IDeductUserAIProxyOpTimesRequest} request DeductUserAIProxyOpTimesRequest message or plain object
             * @returns {Promise<dcnet.pb.DeductUserAIProxyOpTimesReply>} Promise
             * @variation 2
             */

            return Service;
        })();

        return pb;
    })();

    return dcnet;
})();

export { $root as default };

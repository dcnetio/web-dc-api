<!DOCTYPE html>
<html>
<head>
<title>接口文档_DC.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="dcapi-%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3">DCAPI 开发文档</h1>
<br>
<h2 id="%E7%9B%AE%E5%BD%95">目录</h2>
<ol>
<li>概览</li>
<li>初始化</li>
<li>认证模块 (auth)</li>
<li>文件模块 (file)</li>
<li>客户端模块 (client)</li>
<li>消息模块 (message)</li>
<li>评论模块 (comment)</li>
<li>键值存储模块 (keyvalue)</li>
<li>数据库模块 (database)</li>
<li>缓存模块 (cache)</li>
<li>AI代理模块 (aiproxy)</li>
<li>常见使用流程</li>
</ol>
<p><br><br></p>
<h2 id="%E6%A6%82%E8%A7%88">概览</h2>
<p>DCAPI 提供了一整套去中心化云服务接口。基于这些接口，开发者只需关注前端的呈现效果。一旦开发完成，应用可以直接打包并发布到 DC 去中心化云服务中，生成访问链接后即可邀请用户使用，无需任何服务器端的部署和维护。如果希望将开发完成的应用发布到自己的域名，只需进行简单的配置即可完成。DC API 提供了身份验证、文件存储、消息传递、评论系统和数据库管理等核心功能，且基于区块链技术，支持各种去中心化应用程序的开发。</p>
<p><br><br></p>
<h2 id="%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">使用流程</h2>
<p>以下是使用DC API的基本流程图，展示了从引入库到使用各个模块的步骤。</p>
<pre><code class="language-mermaid"><div class="mermaid">
flowchart TD
    subgraph "引入/注入 web-dc-api"
        A1[使用CDN引入] --> B
        A2[使用npm安装并引入] --> B
    end

    subgraph "创建DC对象"
        B[创建DC实例] --> C[配置参数]
        C --> D[调用dc.init初始化]
    end

    subgraph " 使用各模块功能"
        D --> E1[认证模块]
        D --> E2[文件模块]
        D --> E3[AI代理模块]
        D --> E4[...]
    end

    subgraph "认证模块方法"
        E1 --> F1[dc.auth.accountLoginWithWallet]
        E1 --> F2[dc.auth.accountLogin]
        E1 --> F3[dc.auth.bindNFTAccount]
        E1 --> F4[dc.auth.getUserInfoWithNft]
    end

    subgraph "文件模块方法"
        E2 --> G1[dc.file.addFile]
        E2 --> G2[dc.file.getFile]
        E2 --> G3[dc.file.createFileStream]
        E2 --> G4[dc.file.getSeekableFileStream]
    end

    subgraph "AI代理模块方法"
        E3 --> K1[dc.aiproxy.createProxyConfig]
        E3 --> K2[dc.aiproxy.configAIProxy]
        E3 --> K3[dc.aiproxy.DoAIProxyCall]
    end
</div></code></pre>
<p>DAPP最佳实践是直接使用AccountLoginWithWallet登录,这样可以省去用户注册账号的流程,直接使用DCWallet钱包登录即可。</p>
<pre><code class="language-mermaid"><div class="mermaid">flowchart TD
    subgraph "用户注册/登录"
        A1[通过DCWallet登录] --> A
    end

    subgraph "添加链下评论空间"
        B --> B1[调用dc.comment.addUserOffChainSpace]
        B1 --> B2[检查操作结果]
    end

    subgraph "添加链下操作次数"
        C --> C1[调用dc.comment.addUserOffChainOpTimes]
        C1 --> C2[指定操作次数]
    end

    subgraph "正常操作"
        D --> D1[文件上传下载]
        D --> D2[发布评论]
        D --> D3[键值存储]
        D --> D4[数据库操作]
        D --> D5[AI代理调用]
    end

    A[用户注册账号成功] --> B[为用户添加链下评论空间]
    B --> C[为用户添加链下操作次数]
    C --> D[用户可以开始正常操作]
</div></code></pre>
<h2 id="%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</h2>
<p>首先需要创建DC实例并初始化它,可以通过两种方式来引入DC API:</p>
<ol>
<li>使用CDN引入,必须同时引入web-dc-api和grpc-libp2p-client两个库。</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/web-dc-api@latest/dist/dc.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/grpc-libp2p-client@latest/dist/grpc.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">const</span> dc = <span class="hljs-keyword">new</span> DC({
    <span class="hljs-attr">wssUrl</span>: <span class="hljs-string">'wss://chain.baybird.cn'</span>, <span class="hljs-comment">// 区块链路径</span>
    <span class="hljs-attr">backWssUrl</span>: <span class="hljs-string">'wss://dc.baybird.cn'</span>,  <span class="hljs-comment">// 可选备用区块链路径</span>
    <span class="hljs-attr">appInfo</span>: {
      <span class="hljs-attr">appId</span>: <span class="hljs-string">'testHtml'</span>,  <span class="hljs-comment">// 应用ID</span>
      <span class="hljs-attr">appName</span>: <span class="hljs-string">'testHtml Name'</span>,  <span class="hljs-comment">// 应用名称</span>
      <span class="hljs-attr">appVersion</span>: <span class="hljs-string">'v0.0.1'</span>, <span class="hljs-comment">// 应用版本号</span>
    },
  });

  <span class="hljs-comment">// 初始化DC客户端，连接区块链和存储节点</span>
  dc.init().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'DC客户端已初始化'</span>);
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<ol>
<li>依赖包引入</li>
</ol>
<pre class="hljs"><code><div>npm install web-dc-api
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { DC } <span class="hljs-keyword">from</span> <span class="hljs-string">'web-dc-api'</span>;

 <span class="hljs-keyword">const</span> dc = <span class="hljs-keyword">new</span> DC({
    wssUrl: <span class="hljs-string">'wss://chain.baybird.cn'</span>, <span class="hljs-comment">// 区块链路径</span>
    backWssUrl: <span class="hljs-string">'wss://dc.baybird.cn'</span>,  <span class="hljs-comment">// 可选备用区块链路径</span>
    appInfo: {
      appId: <span class="hljs-string">'testHtml'</span>,  <span class="hljs-comment">// 应用ID</span>
      appName: <span class="hljs-string">'testHtml Name'</span>,  <span class="hljs-comment">// 应用名称</span>
      appVersion: <span class="hljs-string">'v0.0.1'</span>, <span class="hljs-comment">// 应用版本号</span>
    },
  });

<span class="hljs-comment">// 初始化DC客户端，连接区块链和存储节点</span>
<span class="hljs-keyword">await</span> dc.init();
</div></code></pre>
<p><br><br></p>
<h2 id="%E8%AE%A4%E8%AF%81%E6%A8%A1%E5%9D%97-auth">认证模块 (auth)</h2>
<p>负责用户身份验证、账户管理和访问控制。如果只是开发DAPP,只要调用accountLoginWithWallet登录即可,可以不用管这个模块的剩余功能,剩余功能大部分都在DCWallet中已经实现,开发者只要专注于认证模块以外的功能即可。(注意:为了用户能正常使用去中心云服务,用户首次注册,并登录成功后,将会消耗一部分云服务token,用来生成链下存储以及链下操作次数)。</p>
<h3 id="%E6%96%B9%E6%B3%95">方法</h3>
<h4 id="accountloginwithwallet"><code>accountLoginWithWallet()</code></h4>
<p>直接通过DCWallet钱包登录。DAPP开发者直接调用该方法即可。不需要关注账号密码生成、以及保存等细节。</p>
<p><strong>返回:</strong> Promise&lt;[boolean,AccountInfo|null]&gt; - 登录响应</p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> AccountInfo{
      nftAccount:<span class="hljs-built_in">string</span>, <span class="hljs-comment">// NFT账号</span>
      appAccount:Ed25519PubKey, <span class="hljs-comment">// 应用专用账号公钥 </span>
      ethAccount:<span class="hljs-built_in">string</span>, <span class="hljs-comment">// 以太坊兼容链上账号</span>
      chainId:<span class="hljs-built_in">string</span>, <span class="hljs-comment">// 区块链ID</span>
      chainName:<span class="hljs-built_in">string</span>, <span class="hljs-comment">// 区块链名称</span>
}
</div></code></pre>
<br>
<h4 id="accountloginnftaccount-password-safecode"><code>accountLogin(nftAccount, password, safecode)</code></h4>
<p>用NFT账户登录系统。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>nftAccount</code>: string - NFT账户名称</li>
<li><code>password</code>: string - 密码</li>
<li><code>safecode</code>: string - 安全码，默认&quot;000000&quot;,主要为了加强密码强度</li>
</ul>
<p><strong>返回:</strong> Promise<boolean> - 登录是否成功</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> success = <span class="hljs-keyword">await</span> dc.auth.accountLogin(<span class="hljs-string">'my-nft-account'</span>, <span class="hljs-string">'password'</span>, <span class="hljs-string">'000000'</span>);
<span class="hljs-keyword">if</span> (success) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'登录成功'</span>);
}
</div></code></pre>
<br>
<h4 id="bindnftaccountaccount-password-seccode-mnemonic"><code>bindNFTAccount(account, password, seccode, mnemonic)</code></h4>
<p>将私钥绑定到NFT账号。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>account</code>: string - NFT账号</li>
<li><code>password</code>: string - 密码</li>
<li><code>seccode</code>: string - 安全码</li>
<li><code>mnemonic</code>: string - 助记词</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[NFTBindStatus, Error | null]&gt; - 绑定状态码和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [status, error] = <span class="hljs-keyword">await</span> dc.auth.bindNFTAccount(<span class="hljs-string">'nft-id'</span>, <span class="hljs-string">'password'</span>, <span class="hljs-string">'seccode'</span>, <span class="hljs-string">'mnemonic phrase'</span>);
<span class="hljs-keyword">if</span> (status === NFTBindStatus.Success) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'绑定成功'</span>);
}
</div></code></pre>
<br>
<h4 id="generateappaccountappid-mnemonic"><code>generateAppAccount(appId, mnemonic)</code></h4>
<p>创建应用子账号。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>appId</code>: string - 应用ID</li>
<li><code>mnemonic</code>: string - 助记词</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[string | null, Error | null]&gt; - 私钥字符串和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [privateKey, error] = <span class="hljs-keyword">await</span> dc.auth.generateAppAccount(<span class="hljs-string">'myapp'</span>, <span class="hljs-string">'mnemonic phrase'</span>);
<span class="hljs-keyword">if</span> (privateKey) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'子账号私钥:'</span>, privateKey);
}
</div></code></pre>
<br>
<h4 id="isnftaccountbindsuccessaccount"><code>isNftAccountBindSuccess(account)</code></h4>
<p>检查NFT账号是否成功绑定到用户公钥。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>account</code>: string - NFT账号</li>
</ul>
<p><strong>返回:</strong> Promise<boolean> - 是否成功绑定</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> isBound = <span class="hljs-keyword">await</span> dc.auth.isNftAccountBindSuccess(<span class="hljs-string">'nft-account'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'NFT账号绑定状态:'</span>, isBound);
</div></code></pre>
<br>
<h4 id="isnftaccountbindedaccount"><code>isNftAccountBinded(account)</code></h4>
<p>检查NFT账号是否已被任何账号绑定。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>account</code>: string - NFT账号</li>
</ul>
<p><strong>返回:</strong> Promise<boolean> - 是否已被绑定</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> isAlreadyBinded = <span class="hljs-keyword">await</span> dc.auth.isNftAccountBinded(<span class="hljs-string">'nft-account'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'NFT账号是否已被绑定:'</span>, isAlreadyBinded);
</div></code></pre>
<br>
<h4 id="getuserinfowithnftnftaccount"><code>getUserInfoWithNft(nftAccount)</code></h4>
<p>根据NFT账户获取用户信息。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>nftAccount</code>: string - NFT账户</li>
</ul>
<p><strong>返回:</strong> Promise<any> - 用户信息对象</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> userInfo = <span class="hljs-keyword">await</span> dc.auth.getUserInfoWithNft(<span class="hljs-string">'nft-account'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户信息:'</span>, userInfo);
</div></code></pre>
<br>
<h4 id="getuserinfowithaccountpubkeyaccount-string"><code>getUserInfoWithAccount(pubkeyAccount: string)</code></h4>
<p><strong>参数:</strong></p>
<ul>
<li><code>pubkeyAccount</code>: string - 公钥账号,即pubkey</li>
</ul>
<p><strong>返回:</strong> Promise<User> - 用户信息对象</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> userInfo = <span class="hljs-keyword">await</span> dc.auth.getUserInfoWithAccount(<span class="hljs-string">'pubkeyAccount'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户信息:'</span>, userInfo);
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> User {
  callMinusNumber: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//调用手续费单位（与用户订阅的空间大小相关，空间越大这个值越小）</span>
  commentFrozenStatus: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//评论相关功能(包括keyvalue数据库、主题评论等功能)冻结状态</span>
  commentReportAmount: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//评论举报次数</span>
  commentReportNumber: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//下一次消除举报次数的区块高度</span>
  dbConfig: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//用户个体库配置信息，格式（threadid|sk|rk)加密后的值，（用户公钥加密后的字符串值，用户私钥可以解密）</span>
  dbUpdateNumber: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//用户个体库信息更新区块高度</span>
  encNftAccount: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//用户绑定的账号加密后字符串（用户公钥加密后的值，用户私钥可以解密）</span>
  expireNumber: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//订阅过期区块高度</span>
  loginNumber: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//登录次数</span>
  nftUpdateNumber: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//用户nft账号更新区块高度</span>
  offchainOptimes: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//链下允许总调用次数,当前会一直累加</span>
  offchainSpace: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//链下允许总调用空间，当前会一直累加</span>
  parentAccount: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//父账号pubkey</span>
  peers: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">//账号登录信息存储的节点ID列表</span>
  purchaseNumber: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//购买次数</span>
  requestPeers: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">//允许上传文件的节点ID列表,如果不在列表中则无法上传文件,需要先发起绑定请求</span>
  spamFrozenStatus: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//垃圾信息相关功能冻结状态</span>
  spamReportAmount: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//垃圾信息举报次数</span>
  spamReportNumber: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//下一次消除垃圾信息举报次数的区块高度</span>
  subscribePrice: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//订阅价格</span>
  subscribeSpace: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//订阅空间大小，单位KB</span>
  usedSpace: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//已使用空间大小，单位KB</span>
}
</div></code></pre>
<br>
<h4 id="ifenoughuserspaceneedsize-number"><code>ifEnoughUserSpace(needSize?: number)</code></h4>
<p><strong>参数:</strong></p>
<ul>
<li><code>needSize</code>: number (可选) - 需要检查的空间大小，单位为字节，默认不传则检查当前用户空间是否足够</li>
</ul>
<p><strong>返回:</strong> Promise<boolean> - 是否有足够的用户空间</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> flag = <span class="hljs-keyword">await</span> dc.auth.ifEnoughUserSpace(<span class="hljs-number">100</span> * <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>); <span class="hljs-comment">// 检查是否有100MB空间</span>
<span class="hljs-keyword">if</span> (flag) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户空间足够'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户空间不足'</span>);
}
</div></code></pre>
<br>
<h4 id="refreshuserinfo"><code>refreshUserInfo()</code></h4>
<p><strong>返回:</strong> Promise<User> - 刷新后的用户信息对象</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> userInfo = <span class="hljs-keyword">await</span> dc.auth.refreshUserInfo();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'刷新后的用户信息:'</span>, userInfo);
</div></code></pre>
<h4 id="signpayload-uint8array">sign(payload: Uint8Array)</h4>
<p><strong>参数:</strong></p>
<ul>
<li><code>payload</code>: Uint8Array - 需要签名的数据</li>
</ul>
<p><strong>返回:</strong> Promise<Uint8Array> - 签名结果</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> payload = <span class="hljs-keyword">new</span> TextEncoder().encode(<span class="hljs-string">'需要签名的数据'</span>);
<span class="hljs-keyword">const</span> signature = <span class="hljs-keyword">await</span> dc.auth.sign(payload);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'签名结果:'</span>, signature);
</div></code></pre>
<p><br><br></p>
<h2 id="%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97-file">文件模块 (file)</h2>
<p>提供文件上传、下载和缓存功能。</p>
<h3 id="%E6%96%B9%E6%B3%95">方法</h3>
<h4 id="addfilefile-enkey-onupdatetransmitsize"><code>addFile(file, enkey, onUpdateTransmitSize)</code></h4>
<p>上传文件到存储系统。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>file</code>: File - 要上传的文件</li>
<li><code>enkey</code>: string - 加密密钥</li>
<li><code>onUpdateTransmitSize</code>: (status: number, size: number) =&gt; void - 进度回调函数</li>
</ul>
<p><strong>返回:</strong> Promise<any> - 上传结果，包含CID等信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> file = <span class="hljs-keyword">new</span> File([<span class="hljs-string">'content'</span>], <span class="hljs-string">'test.txt'</span>);
<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> dc.file.addFile(
  file,
  <span class="hljs-string">'encryption-key'</span>,
  <span class="hljs-function">(<span class="hljs-params">status, size</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`上传进度：<span class="hljs-subst">${status}</span>%, 大小：<span class="hljs-subst">${size}</span>`</span>)
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'上传结果:'</span>, result);
</div></code></pre>
<br>
<h4 id="getfilecid-decryptkey"><code>getFile(cid, decryptKey)</code></h4>
<p>获取文件内容。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>cid</code>: string - 文件内容标识符</li>
<li><code>decryptKey</code>: string - 解密密钥</li>
</ul>
<p><strong>返回:</strong> Promise&lt;Uint8Array | undefined&gt; - 文件字节数组</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> fileContent = <span class="hljs-keyword">await</span> dc.file.getFile(<span class="hljs-string">'QmFileHash...'</span>, <span class="hljs-string">'decryption-key'</span>);
<span class="hljs-keyword">if</span> (fileContent) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'文件内容字节长度:'</span>, fileContent.length);
}
</div></code></pre>
<br>
<h4 id="createfilestreamcid-decryptkey"><code>createFileStream(cid, decryptKey)</code></h4>
<p>创建文件可读流，适用于大文件处理。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>cid</code>: string - 文件内容标识符</li>
<li><code>decryptKey</code>: string - 解密密钥</li>
</ul>
<p><strong>返回:</strong> Promise&lt;ReadableStream<Uint8Array> | null&gt; - 文件可读流</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">await</span> dc.file.createFileStream(<span class="hljs-string">'QmFileHash...'</span>, <span class="hljs-string">'decryption-key'</span>);
<span class="hljs-keyword">if</span> (stream) {
  <span class="hljs-comment">// 使用可读流处理文件</span>
  <span class="hljs-keyword">const</span> reader = stream.getReader();
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> { done, value } = <span class="hljs-keyword">await</span> reader.read();
    <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">break</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'读取数据块:'</span>, value.length);
  }
}
</div></code></pre>
<br>
<h4 id="getseekablefilestreamipfspath-decryptkey"><code>getSeekableFileStream(ipfsPath, decryptKey)</code></h4>
<p>获取支持随机访问的文件流，适用于视频播放等场景。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>ipfsPath</code>: string - IPFS路径或CID</li>
<li><code>decryptKey</code>: string - 解密密钥</li>
</ul>
<p><strong>返回:</strong> Promise<SeekableFileStream> - 可随机访问的文件流</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> seekableStream = <span class="hljs-keyword">await</span> dc.file.getSeekableFileStream(<span class="hljs-string">'/ipfs/QmFileHash...'</span>, <span class="hljs-string">'decryption-key'</span>);
<span class="hljs-comment">// 从文件的第1000字节开始读取</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> seekableStream.read(<span class="hljs-number">1000</span>, <span class="hljs-number">1024</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'读取的数据:'</span>, data);
</div></code></pre>
<br>
<h4 id="clearfilecachepathname"><code>clearFileCache(pathname)</code></h4>
<p>清理文件缓存。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>pathname</code>: string (可选) - 特定文件路径，不提供则清除所有缓存</li>
</ul>
<p><strong>返回:</strong> void</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 清理特定文件缓存</span>
dc.file.clearFileCache(<span class="hljs-string">'/ipfs/QmFileHash...'</span>);

<span class="hljs-comment">// 清理所有缓存</span>
dc.file.clearFileCache();
</div></code></pre>
<p><br><br></p>
<h2 id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%9D%97-client">客户端模块 (client)</h2>
<p>提供底层节点连接和网络通信功能。</p>
<h3 id="%E6%96%B9%E6%B3%95">方法</h3>
<h4 id="gethostid"><code>getHostID()</code></h4>
<p>获取当前连接的节点ID和客户端公网地址。</p>
<p><strong>参数:</strong> 无</p>
<p><strong>返回:</strong> Promise&lt;[{ peerID: string; reqAddr: string } | null, Error | null]&gt; - 主机信息和错误</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [hostInfo, error] = <span class="hljs-keyword">await</span> dc.client.getHostID();
<span class="hljs-keyword">if</span> (hostInfo) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'节点ID:'</span>, hostInfo.peerID);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'客户端公网地址:'</span>, hostInfo.reqAddr);
}
</div></code></pre>
<p><br><br></p>
<h2 id="%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9D%97-message">消息模块 (message)</h2>
<p>提供用户消息盒子的发送和接收功能。</p>
<h3 id="%E6%96%B9%E6%B3%95">方法</h3>
<h4 id="sendmsgtouserboxreceiver-msg"><code>sendMsgToUserBox(receiver, msg)</code></h4>
<p>向用户消息盒子发送消息。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>receiver</code>: string - 接收者的公钥</li>
<li><code>msg</code>: string - 消息内容</li>
</ul>
<p><strong>返回:</strong> Promise<any> - 发送结果，包含消息ID和时间戳</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> dc.message.sendMsgToUserBox(<span class="hljs-string">'receiver-pubkey'</span>, <span class="hljs-string">'Hello World!'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'消息发送结果:'</span>, result);
</div></code></pre>
<br>
<h4 id="getmsgfromuserboxlimit"><code>getMsgFromUserBox(limit)</code></h4>
<p>获取当前用户消息盒子中的消息。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>limit</code>: number (可选) - 返回消息的最大数量</li>
</ul>
<p><strong>返回:</strong> Promise<any> - 消息列表</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> messages = <span class="hljs-keyword">await</span> dc.message.getMsgFromUserBox(<span class="hljs-number">10</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'收到的消息:'</span>, messages);
</div></code></pre>
<p><br><br></p>
<h2 id="%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97-comment">评论模块 (comment)</h2>
<p>提供主题评论功能。</p>
<h3 id="%E6%96%B9%E6%B3%95">方法</h3>
<h4 id="adduseroffchainspace"><code>addUserOffChainSpace()</code></h4>
<p>为当前用户添加链下评论空间。当用户首次登录成功后,应该先调用此方法来完成链下空间配置。如果是集成sdk,sdk会自动完成这部操作。</p>
<p><strong>参数:</strong> 无</p>
<p><strong>返回:</strong> Promise&lt;[boolean | null, Error | null]&gt; - 操作结果</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [success, error] = <span class="hljs-keyword">await</span> dc.comment.addUserOffChainSpace();
<span class="hljs-keyword">if</span> (success) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功添加用户评论空间'</span>);
}
</div></code></pre>
<br>
<h4 id="adduseroffchainoptimestimes-vaccount"><code>addUserOffChainOpTimes(times, vaccount?)</code></h4>
<p>为用户添加链下操作次数,DC为了提升性能,用户发布评论等操作,无需上链,用于发布评论等链下操作次数,当用户首次登录成功后,应该先调用此方法来完成链下操作次数配置。如果是集成sdk,sdk会自动完成这部操作。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>times</code>: number - 操作次数</li>
<li><code>vaccount</code>: string (可选) - 用户的虚拟账号</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[boolean | null, Error | null]&gt; - 操作结果, 0:成功 1:评论空间没有配置 2:评论空间不足 3:评论数据同步中</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [result, error] = <span class="hljs-keyword">await</span> dc.comment.addUserOffChainOpTimes(<span class="hljs-number">10</span>);
<span class="hljs-keyword">if</span> (result) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功添加用户链下操作次数'</span>);
}
</div></code></pre>
<br>
<h4 id="getthemeobjthemeauthor-startheight-direction-offset-limit-seekkey"><code>getThemeObj(themeAuthor, startHeight, direction, offset, limit, seekKey)</code></h4>
<p>获取指定用户的主题对象列表。</p>
<p><strong>参数:</strong> Promise<string> - 主题对象列表</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> themes = <span class="hljs-keyword">await</span> dc.comment.getThemeObj(
  <span class="hljs-string">'author-pubkey'</span>,
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 起始高度</span>
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 从新到旧</span>
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 不偏移</span>
  <span class="hljs-number">50</span>, <span class="hljs-comment">// 最多返回50条</span>
  <span class="hljs-string">''</span> <span class="hljs-comment">// 不使用起始键</span>
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'主题对象列表:'</span>, themes);
</div></code></pre>
<br>
<h4 id="addthemeobjtheme-openflag-commentspace"><code>addThemeObj(theme, openFlag, commentSpace)</code></h4>
<p>为指定主题开通评论功能。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>theme</code>: string - 主题标识符</li>
<li><code>openFlag</code>: OpenFlag - 评论可见性标志</li>
<li><code>commentSpace</code>: number (可选) - 评论空间大小，默认50MB</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[number | null, Error | null]&gt; - 状态码和错误</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [status, error] = <span class="hljs-keyword">await</span> dc.comment.addThemeObj(
  <span class="hljs-string">'my-article-1'</span>,
  OpenFlag.PUBLIC, <span class="hljs-comment">// 评论设为公开</span>
  <span class="hljs-number">100</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> <span class="hljs-comment">// 100MB</span>
);
<span class="hljs-keyword">if</span> (status === <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'成功开通评论功能'</span>);
}
</div></code></pre>
<br>
<h4 id="addthemespacetheme-addspace"><code>addThemeSpace(theme, addSpace)</code></h4>
<p>为已开通评论的主题增加评论空间。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>theme</code>: string - 主题标识符</li>
<li><code>addSpace</code>: number - 增加的空间大小(字节)</li>
</ul>
<p><strong>返回:</strong> Promise<any> - 操作结果</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> dc.comment.addThemeSpace(<span class="hljs-string">'my-article-1'</span>, <span class="hljs-number">50</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>); <span class="hljs-comment">// 增加50MB</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'增加空间结果:'</span>, result);
</div></code></pre>
<br>
<h4 id="publishcommenttothemetheme-themeauthor-commenttype-comment-refercommentkey-openflag"><code>publishCommentToTheme(theme, themeAuthor, commentType, comment, refercommentkey, openFlag)</code></h4>
<p>发表评论到指定主题。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>theme</code>: string - 主题标识符</li>
<li><code>themeAuthor</code>: string - 主题作者的公钥</li>
<li><code>commentType</code>: number - 评论类型 (0:普通评论, 1:回复评论等)</li>
<li><code>comment</code>: string - 评论内容</li>
<li><code>refercommentkey</code>: string (可选) - 引用评论的键</li>
<li><code>openFlag</code>: number (可选) - 评论可见性</li>
</ul>
<p><strong>返回:</strong> Promise<any> - 发布结果</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> dc.comment.publishCommentToTheme(
  <span class="hljs-string">'my-article-1'</span>,
  <span class="hljs-string">'author-pubkey'</span>,
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 普通评论</span>
  <span class="hljs-string">'这是一条评论内容'</span>,
  <span class="hljs-string">''</span>, <span class="hljs-comment">// 不引用其他评论</span>
  OpenFlag.PUBLIC <span class="hljs-comment">// 公开评论</span>
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'评论发布结果:'</span>, result);
</div></code></pre>
<br>
<h4 id="deleteselfcommenttheme-themeauthor-commentkey"><code>deleteSelfComment(theme, themeAuthor, commentKey)</code></h4>
<p>删除自己发布的评论。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>theme</code>: string - 主题标识符</li>
<li><code>themeAuthor</code>: string - 主题作者的公钥</li>
<li><code>commentKey</code>: string - 评论的唯一键</li>
</ul>
<p><strong>返回:</strong> Promise<any> - 删除结果</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> dc.comment.deleteSelfComment(
  <span class="hljs-string">'my-article-1'</span>,
  <span class="hljs-string">'author-pubkey'</span>,
  <span class="hljs-string">'comment-key-123'</span>
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'删除评论结果:'</span>, result);
</div></code></pre>
<br>
<h4 id="getthemecommentstheme-themeauthor-startheight-direction-offset-limit-seekkey"><code>getThemeComments(theme, themeAuthor, startHeight, direction, offset, limit, seekKey)</code></h4>
<p>获取指定主题的评论列表,无法查询作者设置为私密的评论</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>theme</code>: string - 主题标识符</li>
<li><code>themeAuthor</code>: string - 主题作者的公钥</li>
<li><code>startHeight</code>: number (可选) - 查询起始高度，默认0</li>
<li><code>direction</code>: number (可选) - 查询方向 (0:从新到旧, 1:从旧到新)，默认0</li>
<li><code>offset</code>: number (可选) - 结果集偏移量，默认0</li>
<li><code>limit</code>: number (可选) - 最大返回数量，默认100</li>
<li><code>seekKey</code>: string (可选) - 查询的起始键，格式为&quot;blockheight/key&quot;</li>
</ul>
<p><strong>返回:</strong> Promise<any> - 评论列表</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> comments = <span class="hljs-keyword">await</span> dc.comment.getThemeComments(
  <span class="hljs-string">'my-article-1'</span>,
  <span class="hljs-string">'author-pubkey'</span>,
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 起始高度</span>
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 从新到旧</span>
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 不偏移</span>
  <span class="hljs-number">50</span> <span class="hljs-comment">// 最多返回50条</span>
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'主题评论:'</span>, comments);
</div></code></pre>
<br>
<h4 id="configauth-themeauthor-theme-authpubkey-permission-remark-vaccount"><code>configAuth( themeAuthor, theme, authPubkey, permission, remark, vaccount)</code></h4>
<p>配置主题的授权信息,即为其他用户授权评论权限。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>themeAuthor</code>: string - 主题作者的公钥</li>
<li><code>theme</code>: string - 主题名称</li>
<li><code>authPubkey</code>: string - 被授权者的公钥</li>
<li><code>permission</code>: ThemePermission - 权限级别 (1:只读, 3:读写)</li>
<li><code>remark</code>: string - 备注信息</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[number, Error | null]&gt; - 状态码和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [status, error] = <span class="hljs-keyword">await</span> dc.comment.configAuth(
  <span class="hljs-string">'theme-author-pubkey'</span>,
  <span class="hljs-string">'my-article-1'</span>,
  <span class="hljs-string">'user-to-authorize-pubkey'</span>,
  ThemePermission.READ, <span class="hljs-comment">// 只读权限 </span>
  <span class="hljs-string">'测试授权'</span>
);
<span class="hljs-keyword">if</span> (status === <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'授权配置成功'</span>);
}
</div></code></pre>
<pre class="hljs"><code><div>
<span class="hljs-comment">/**
 * 主题的操作权限
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> ThemePermission {
  <span class="hljs-comment">/** 无权限 */</span>
  NONE = <span class="hljs-number">0</span>,
  <span class="hljs-comment">/** 申请权限 */</span>
  APPLY,
  <span class="hljs-comment">/** 读权限 */</span>
  READ,
  <span class="hljs-comment">/** 写权限 */</span>
  WRITE,
  <span class="hljs-comment">/** 管理员权限 */</span>
  ADMIN,
  <span class="hljs-comment">/** 
   * 只写权限
   * 不允许用户修改remark或者物联网设备上报数据使用
   * 权限后面跟随分组列表,以逗号分隔
   */</span>
  ONLY_WRITE,
  <span class="hljs-comment">/** 物联网管理人员相关权限,具体权限后续可扩展 */</span>
  DEVICE,
  <span class="hljs-comment">/** 不存在 */</span>
  NOT_EXIST,
  <span class="hljs-comment">/** 查询权限,系统可以查询数据,用户只能查询自己的授权数据 */</span>
  QUERY
}
</div></code></pre>
<br>
<h4 id="getauthlistthemeauthor-theme-vaccount"><code>getAuthList(themeAuthor, theme, vaccount)</code></h4>
<p>获取指定主题的授权列表</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>themeAuthor</code>: string - 主题作者的公钥</li>
<li><code>theme</code>: string - 主题/对象标识符</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[ThemeAuthInfo[] | null, ThemeComment[] | null, Error | null]&gt; - 存授权列表、评论列表格式的授权列表(带原始签名)和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [authList, commentList, error] = <span class="hljs-keyword">await</span> dc.comment.getAuthList(
  <span class="hljs-string">'theme-author-pubkey'</span>,
  <span class="hljs-string">'my-article-1'</span>,
  <span class="hljs-string">'virtual-account-id'</span> <span class="hljs-comment">// 可选</span>
);
<span class="hljs-keyword">if</span> (authList) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'授权列表:'</span>, authList);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'评论格式列表:'</span>, commentList);
}
</div></code></pre>
<br>
<h4 id="getusercommentsuserpubkey-startheight-direction-offset-limit-seekkey"><code>getUserComments(userPubkey, startHeight, direction, offset, limit, seekKey)</code></h4>
<p>获取指定用户发布的评论列表,无法查询用户设置为私密的评论</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>userPubkey</code>: string - 用户公钥</li>
<li><code>startHeight</code>: number (可选) - 查询起始高度，默认0</li>
<li><code>direction</code>: number (可选) - 查询方向 (0:从新到旧, 1:从旧到新)，默认0</li>
<li><code>offset</code>: number (可选) - 结果集偏移量，默认0</li>
<li><code>limit</code>: number (可选) - 最大返回数量，默认100</li>
<li><code>seekKey</code>: string (可选) - 查询的起始键，格式为&quot;blockheight/key&quot;</li>
</ul>
<p><strong>返回:</strong> Promise<string> - 用户的评论列表</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> userComments = <span class="hljs-keyword">await</span> dc.comment.getUserComments(
  <span class="hljs-string">'user-pubkey'</span>,
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 起始高度</span>
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 从新到旧</span>
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 不偏移</span>
  <span class="hljs-number">50</span>, <span class="hljs-comment">// 最多返回50条</span>
  <span class="hljs-string">''</span> <span class="hljs-comment">// 不使用起始键</span>
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户评论列表:'</span>, userComments);
</div></code></pre>
<p><br><br></p>
<h2 id="%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9D%97-keyvalue">键值存储模块 (keyvalue)</h2>
<p>提供分布式键值存储功能。</p>
<h3 id="%E6%96%B9%E6%B3%95">方法</h3>
<h4 id="createstoreappid-theme-space-type"><code>createStore(appId, theme, space, type)</code></h4>
<p>创建一个键值存储主题。传入的空间大小如果少于100M,将会自动分配100M空间,如果传入的空间大于100M,则会分配指定大小的空间。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>appId</code>: string - 应用ID</li>
<li><code>theme</code>: string - 主题名称</li>
<li><code>space</code>: number - 分配的存储空间大小(字节)</li>
<li><code>type</code>: KeyValueStoreType - 存储类型 (1: 鉴权主题-读写都需要鉴权, 2: 公共主题-默认所有用户可读,写需要鉴权)</li>
</ul>
<p><strong>返回:</strong> Promise<KeyValueDB> - 创建的keyvalue数据库实例</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> dc.keyvalue.createStore(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'my-app-settings'</span>,
  <span class="hljs-number">100</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, <span class="hljs-comment">// 100MB</span>
  <span class="hljs-number">1</span> <span class="hljs-comment">// 认证存储</span>
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'创建存储结果:'</span>, result);
</div></code></pre>
<br>
<h4 id="getstoreappid-theme-themeauthor"><code>getStore(appId, theme, themeAuthor)</code></h4>
<p>获取指定主题的keyvalue数据库实例。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>appId</code>: string - 应用ID</li>
<li><code>theme</code>: string - 主题名称</li>
<li><code>themeAuthor</code>: string - 数据库创建者的公钥</li>
</ul>
<p><strong>返回:</strong> Promise<KeyValueDB> - keyvalue数据库实例</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">await</span> dc.keyvalue.getStore(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'my-app-settings'</span>,
  <span class="hljs-string">'theme-author-pubkey'</span>
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'获取到存储实例:'</span>, store);
</div></code></pre>
<br>
<h4 id="configauthkvdb-authpubkey-permission-remark-vaccount"><code>configAuth(kvdb, authPubkey, permission, remark, vaccount)</code></h4>
<p>配置主题的授权信息。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>kvdb</code>: KeyValueDB - keyvalue数据库实例</li>
<li><code>authPubkey</code>: string - 被授权者的公钥</li>
<li><code>permission</code>: ThemePermission - 权限级别</li>
<li><code>remark</code>: string - 备注信息</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[number, Error | null]&gt; - 状态码和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">await</span> dc.keyvalue.getStore(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'my-app-settings'</span>, 
  <span class="hljs-string">'theme-author-pubkey'</span>
);

<span class="hljs-keyword">const</span> [status, error] = <span class="hljs-keyword">await</span> dc.keyvalue.configAuth(
  store,
  <span class="hljs-string">'user-to-authorize-pubkey'</span>,
  ThemePermission.READ, <span class="hljs-comment">// 只读权限</span>
  <span class="hljs-string">'测试授权'</span>
);

<span class="hljs-keyword">if</span> (status === <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'授权配置成功'</span>);
}
</div></code></pre>
<br>
<h4 id="getauthlistkvdb-vaccount"><code>getAuthList(kvdb, vaccount)</code></h4>
<p>获取指定keyvalue的授权列表。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>kvdb</code>: KeyValueDB - keyvalue数据库实例</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[ThemeAuthInfo[] | null, ThemeComment[] | null, Error | null]&gt; - 授权列表、含签名的原始授权列表和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">await</span> dc.keyvalue.getStore(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'my-app-settings'</span>,
  <span class="hljs-string">'theme-author-pubkey'</span>
);

<span class="hljs-keyword">const</span> [authList, commentList, error] = <span class="hljs-keyword">await</span> dc.keyvalue.getAuthList(
  store,
  <span class="hljs-string">'virtual-account-id'</span> <span class="hljs-comment">// 可选</span>
);

<span class="hljs-keyword">if</span> (authList) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'授权列表:'</span>, authList);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'评论格式列表:'</span>, commentList);
}
</div></code></pre>
<br>
<h4 id="setkvdb-key-value-indexs-vaccount"><code>set(kvdb, key, value, indexs, vaccount)</code></h4>
<p>设置键值对，支持索引功能。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>kvdb</code>: KeyValueDB - keyvalue数据库实例</li>
<li><code>key</code>: string - 键名</li>
<li><code>value</code>: string - 值内容</li>
<li><code>indexs</code>: string - 索引列表，格式为&quot;key1:value1$$$key2:value2&quot;，设置索引后可通过索引快速定位</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[boolean, Error | null]&gt; - 成功状态和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">await</span> dc.keyvalue.getStore(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'my-app-settings'</span>,
  <span class="hljs-string">'theme-author-pubkey'</span>
);

<span class="hljs-keyword">const</span> [success, error] = <span class="hljs-keyword">await</span> dc.keyvalue.set(
  store,
  <span class="hljs-string">'user:prefs'</span>,
  <span class="hljs-built_in">JSON</span>.stringify({theme: <span class="hljs-string">'dark'</span>, fontSize: <span class="hljs-number">14</span>}),
  <span class="hljs-string">'type:prefs$$$user:123'</span>, <span class="hljs-comment">// 设置两个索引</span>
  <span class="hljs-string">'virtual-account-id'</span> <span class="hljs-comment">// 可选</span>
);

<span class="hljs-keyword">if</span> (success) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据保存成功'</span>);
}
</div></code></pre>
<br>
<h4 id="getkvdb-key-writerpubkey-vaccount"><code>get(kvdb, key, writerPubkey, vaccount)</code></h4>
<p>获取指定键的值。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>kvdb</code>: KeyValueDB - keyvalue数据库实例</li>
<li><code>key</code>: string - 键名</li>
<li><code>writerPubkey</code>: string (可选) - 写入者的公钥，默认为主题作者</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[string, Error | null]&gt; - 值内容和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">await</span> dc.keyvalue.getStore(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'my-app-settings'</span>,
  <span class="hljs-string">'theme-author-pubkey'</span>
);

<span class="hljs-keyword">const</span> [value, error] = <span class="hljs-keyword">await</span> dc.keyvalue.get(
  store,
  <span class="hljs-string">'user:prefs'</span>,
  <span class="hljs-string">'writer-pubkey'</span>, <span class="hljs-comment">// 可选，默认为主题作者</span>
  <span class="hljs-string">'virtual-account-id'</span> <span class="hljs-comment">// 可选</span>
);

<span class="hljs-keyword">if</span> (value) {
  <span class="hljs-keyword">const</span> prefs = <span class="hljs-built_in">JSON</span>.parse(value);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户偏好设置:'</span>, prefs);
}
</div></code></pre>
<br>
<h4 id="getbatchkvdb-keys-writerpubkey-vaccount"><code>getBatch(kvdb, keys, writerPubkey, vaccount)</code></h4>
<p>批量获取多个键的值。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>kvdb</code>: KeyValueDB - keyvalue数据库实例</li>
<li><code>keys</code>: string - 键名列表，多个键用$$$分隔</li>
<li><code>writerPubkey</code>: string (可选) - 写入者的公钥，默认为主题作者</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[string, Error | null]&gt; - JSON格式查询结果和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">await</span> dc.keyvalue.getStore(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'my-app-settings'</span>,
  <span class="hljs-string">'theme-author-pubkey'</span>
);

<span class="hljs-keyword">const</span> [results, error] = <span class="hljs-keyword">await</span> dc.keyvalue.getBatch(
  store,
  <span class="hljs-string">'user:prefs$$$user:settings'</span>, <span class="hljs-comment">// 多个键用$$$分隔</span>
  <span class="hljs-string">'writer-pubkey'</span>, <span class="hljs-comment">// 可选，默认为主题作者</span>
  <span class="hljs-string">'virtual-account-id'</span> <span class="hljs-comment">// 可选</span>
);

<span class="hljs-keyword">if</span> (results) {
  <span class="hljs-keyword">const</span> values = <span class="hljs-built_in">JSON</span>.parse(results);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'获取的键值对:'</span>, values);
}
</div></code></pre>
<br>
<h4 id="getwithindexkvdb-indexkey-indexvalue-limit-seekkey-offset-vaccount"><code>getWithIndex(kvdb, indexKey, indexValue, limit, seekKey, offset, vaccount)</code></h4>
<p>通过索引查询键值对。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>kvdb</code>: KeyValueDB - keyvalue数据库实例</li>
<li><code>indexKey</code>: string - 索引键名</li>
<li><code>indexValue</code>: string - 索引值</li>
<li><code>limit</code>: number - 返回结果数量限制</li>
<li><code>seekKey</code>: string - 查询起始键</li>
<li><code>offset</code>: number - 结果偏移量</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[string, Error | null]&gt; - JSON格式查询结果和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">await</span> dc.keyvalue.getStore(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'my-app-settings'</span>,
  <span class="hljs-string">'theme-author-pubkey'</span>
);

<span class="hljs-keyword">const</span> [results, error] = <span class="hljs-keyword">await</span> dc.keyvalue.getWithIndex(
  store,
  <span class="hljs-string">'type'</span>, <span class="hljs-comment">// 索引键</span>
  <span class="hljs-string">'prefs'</span>, <span class="hljs-comment">// 索引值</span>
  <span class="hljs-number">100</span>, <span class="hljs-comment">// 最大返回数量</span>
  <span class="hljs-string">''</span>, <span class="hljs-comment">// 查询起始键</span>
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 偏移量</span>
  <span class="hljs-string">'virtual-account-id'</span> <span class="hljs-comment">// 可选</span>
);

<span class="hljs-keyword">if</span> (results) {
  <span class="hljs-keyword">const</span> items = <span class="hljs-built_in">JSON</span>.parse(results);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'索引查询结果:'</span>, items);
}
</div></code></pre>
<br>
<h2 id="%E7%AE%80%E5%8C%96%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">简化使用示例</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// 完整的键值存储使用流程示例</span>

<span class="hljs-comment">// 1. 创建存储主题</span>
<span class="hljs-keyword">await</span> dc.keyvalue.createStore(<span class="hljs-string">'myapp'</span>, <span class="hljs-string">'app-settings'</span>, <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, <span class="hljs-number">1</span>);

<span class="hljs-comment">// 2. 获取存储实例</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">await</span> dc.keyvalue.getStore(<span class="hljs-string">'myapp'</span>, <span class="hljs-string">'app-settings'</span>, dc.auth.getPublicKey());

<span class="hljs-comment">// 3. 存储用户偏好设置</span>
<span class="hljs-keyword">await</span> dc.keyvalue.set(
  store,
  <span class="hljs-string">'user:preferences'</span>,
  <span class="hljs-built_in">JSON</span>.stringify({
    theme: <span class="hljs-string">'dark'</span>,
    fontSize: <span class="hljs-number">16</span>,
    notifications: <span class="hljs-literal">true</span>
  }),
  <span class="hljs-string">'type:preferences$$$user:current'</span> <span class="hljs-comment">// 设置两个索引</span>
);

<span class="hljs-comment">// 4. 读取用户偏好设置</span>
<span class="hljs-keyword">const</span> [prefsData, error] = <span class="hljs-keyword">await</span> dc.keyvalue.get(store, <span class="hljs-string">'user:preferences'</span>);
<span class="hljs-keyword">if</span> (prefsData) {
  <span class="hljs-keyword">const</span> preferences = <span class="hljs-built_in">JSON</span>.parse(prefsData);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户偏好设置:'</span>, preferences);
}

<span class="hljs-comment">// 5. 根据索引查询所有偏好设置类型的数据</span>
<span class="hljs-keyword">const</span> [indexed, indexError] = <span class="hljs-keyword">await</span> dc.keyvalue.getWithIndex(
  store,
  <span class="hljs-string">'type'</span>, <span class="hljs-comment">// 索引键</span>
  <span class="hljs-string">'preferences'</span>, <span class="hljs-comment">// 索引值</span>
  <span class="hljs-number">50</span>, <span class="hljs-comment">// 最多返回50条</span>
  <span class="hljs-string">''</span>, <span class="hljs-comment">// 不使用起始键</span>
  <span class="hljs-number">0</span> <span class="hljs-comment">// 不偏移</span>
);

<span class="hljs-keyword">if</span> (indexed) {
  <span class="hljs-keyword">const</span> allPreferences = <span class="hljs-built_in">JSON</span>.parse(indexed);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'所有偏好设置:'</span>, allPreferences);
}
</div></code></pre>
<p><br><br></p>
<h2 id="%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97-database">数据库模块 (database)</h2>
<p>数据库模块提供基于ThreadDB的分布式数据库管理功能，支持创建、同步、查询和修改数据。数据库主要由threadid确保唯一，结合servicekey和readkey多重加密确保数据安全，其中readkey永远不离开用户，而servicekey会在DC云端的TEE环境中参与数据备份。</p>
<h2 id="%E6%96%B9%E6%B3%95">方法</h2>
<h3 id="initdbmanager"><code>initDBManager()</code></h3>
<p>初始化数据库管理器，创建数据库操作所需的组件和服务。</p>
<p><strong>参数:</strong> 无</p>
<p><strong>返回:</strong> Promise<void></p>
<p><strong>异常:</strong> 初始化失败时抛出错误</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 初始化数据库管理器</span>
<span class="hljs-keyword">await</span> dc.database.initDBManager();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据库管理器已初始化'</span>);
</div></code></pre>
<br>
<h3 id="newdbname-b32rk-b32sk-jsoncollections"><code>newDB(name, b32Rk, b32Sk, jsonCollections)</code></h3>
<p>创建新数据库。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>name</code>: string - 数据库名称</li>
<li><code>b32Rk</code>: string - base32编码的读取密钥</li>
<li><code>b32Sk</code>: string - base32编码的服务密钥</li>
<li><code>jsonCollections</code>: ICollectionConfig[] - 集合配置数组，定义数据库中的集合结构</li>
</ul>
<p><strong>返回:</strong> Promise<string> - 创建的threadID</p>
<p><strong>异常:</strong> 创建失败时抛出错误</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 定义集合配置</span>
<span class="hljs-keyword">const</span> collections = [
  {
    name: <span class="hljs-string">'users'</span>,
    schema: {
      title: <span class="hljs-string">'User'</span>,
      <span class="hljs-keyword">type</span>: <span class="hljs-string">'object'</span>,
      properties: {
        _id: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> },
        name: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> },
        email: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> },
        age: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'integer'</span> }
      },
      required: [<span class="hljs-string">'_id'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span>]
    }
  },
  {
    name: <span class="hljs-string">'posts'</span>,
    schema: {
      title: <span class="hljs-string">'Post'</span>,
      <span class="hljs-keyword">type</span>: <span class="hljs-string">'object'</span>,
      properties: {
        _id: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> },
        title: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> },
        content: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> },
        authorId: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> }
      }
    }
  }
];

<span class="hljs-comment">// 创建数据库</span>
<span class="hljs-keyword">const</span> threadId = <span class="hljs-keyword">await</span> dc.database.newDB(
  <span class="hljs-string">'myApplication'</span>,
  <span class="hljs-string">'base32ReadKey123456789ABCDEF'</span>,
  <span class="hljs-string">'base32ServiceKey987654321FEDCBA'</span>,
  collections
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'创建数据库成功，threadID:'</span>, threadId);
</div></code></pre>
<br>
<h3 id="syncdbfromdcthreadid-dbname-dbaddr-b32rk-b32sk-block-collectioninfos"><code>syncDbFromDC(threadid, dbname, dbAddr, b32Rk, b32Sk, block, collectionInfos)</code></h3>
<p>从分布式网络同步数据库。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>threadid</code>: string - threadID</li>
<li><code>dbname</code>: string - 数据库名称</li>
<li><code>dbAddr</code>: string - 数据库地址</li>
<li><code>b32Rk</code>: string - base32编码的读取密钥</li>
<li><code>b32Sk</code>: string - base32编码的服务密钥</li>
<li><code>block</code>: boolean - 是否阻塞等待同步完成</li>
<li><code>collectionInfos</code>: ICollectionConfig[] - 集合配置数组，定义数据库中的集合结构</li>
</ul>
<p><strong>返回:</strong> Promise<void></p>
<p><strong>异常:</strong> 同步失败时抛出错误</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 同步数据库配置</span>
<span class="hljs-keyword">const</span> collections = [
  {
    name: <span class="hljs-string">'users'</span>,
    schema: {
      title: <span class="hljs-string">'User'</span>,
      <span class="hljs-keyword">type</span>: <span class="hljs-string">'object'</span>,
      properties: {
        _id: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> },
        name: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> },
        email: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> }
      }
    }
  }
];

<span class="hljs-comment">// 从分布式网络同步数据库</span>
<span class="hljs-keyword">await</span> dc.database.syncDbFromDC(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,  <span class="hljs-comment">// threadID</span>
  <span class="hljs-string">'sharedDatabase'</span>,  <span class="hljs-comment">// 数据库名称</span>
  <span class="hljs-string">'database.example.com'</span>,  <span class="hljs-comment">// 数据库地址</span>
  <span class="hljs-string">'base32ReadKey123456789ABCDEF'</span>,  <span class="hljs-comment">// 读取密钥</span>
  <span class="hljs-string">'base32ServiceKey987654321FEDCBA'</span>,  <span class="hljs-comment">// 服务密钥</span>
  <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 阻塞等待同步完成</span>
  collections  <span class="hljs-comment">// 集合配置</span>
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据库同步完成'</span>);
</div></code></pre>
<br>
<h3 id="refreshdbfromdcthreadid"><code>refreshDBFromDC(threadid)</code></h3>
<p>刷新数据库，从分布式网络获取最新数据。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>threadid</code>: string - 数据库threadID</li>
</ul>
<p><strong>返回:</strong> Promise&lt;Error | null&gt; - 错误信息或null表示成功</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 刷新数据库，获取最新数据</span>
<span class="hljs-keyword">const</span> error = <span class="hljs-keyword">await</span> dc.database.refreshDBFromDC(<span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>);

<span class="hljs-keyword">if</span> (error === <span class="hljs-literal">null</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据库刷新成功'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'刷新数据库时出错:'</span>, error.message);
}
</div></code></pre>
<br>
<h3 id="syncdbtodctid"><code>syncDBToDC(tId)</code></h3>
<p>同步数据库到分布式网络。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>tId</code>: string - threadID</li>
</ul>
<p><strong>返回:</strong> Promise&lt;Error | null&gt; - 错误信息或null表示成功</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 将本地数据库同步到分布式网络</span>
<span class="hljs-keyword">const</span> error = <span class="hljs-keyword">await</span> dc.database.syncDBToDC(<span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>);

<span class="hljs-keyword">if</span> (error === <span class="hljs-literal">null</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据库已同步到分布式网络'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'同步数据库时出错:'</span>, error.message);
}
</div></code></pre>
<br>
<h3 id="close"><code>close()</code></h3>
<p>关闭数据库管理器。</p>
<p><strong>参数:</strong> 无</p>
<p><strong>返回:</strong> Promise<void></p>
<p><strong>异常:</strong> 关闭失败时抛出错误</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 关闭数据库管理器</span>
<span class="hljs-keyword">await</span> dc.database.close();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据库管理器已关闭'</span>);
</div></code></pre>
<br>
<h3 id="createthreadid-collectionname-jsoninstance"><code>create(threadId, collectionName, jsonInstance)</code></h3>
<p>在集合中创建新对象实例。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>threadId</code>: string - threadID</li>
<li><code>collectionName</code>: string - 集合名称</li>
<li><code>jsonInstance</code>: string - JSON字符串表示的实例对象</li>
</ul>
<p><strong>返回:</strong> Promise<string> - 创建的实例ID</p>
<p><strong>异常:</strong> 创建失败时抛出错误</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 创建用户实例</span>
<span class="hljs-keyword">const</span> user = {
  name: <span class="hljs-string">'John Doe'</span>,
  email: <span class="hljs-string">'john@example.com'</span>,
  age: <span class="hljs-number">28</span>
};

<span class="hljs-comment">// 将对象序列化为JSON字符串</span>
<span class="hljs-keyword">const</span> userJson = <span class="hljs-built_in">JSON</span>.stringify(user);

<span class="hljs-comment">// 在用户集合中创建新实例</span>
<span class="hljs-keyword">const</span> instanceId = <span class="hljs-keyword">await</span> dc.database.create(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,  <span class="hljs-comment">// threadID</span>
  <span class="hljs-string">'users'</span>,  <span class="hljs-comment">// 集合名称</span>
  userJson  <span class="hljs-comment">// JSON字符串表示的实例对象</span>
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'创建的用户ID:'</span>, instanceId);

<span class="hljs-comment">// 创建文章实例</span>
<span class="hljs-keyword">const</span> post = {
  title: <span class="hljs-string">'分布式数据库入门'</span>,
  content: <span class="hljs-string">'这是一篇关于ThreadDB的介绍文章...'</span>,
  authorId: instanceId
};

<span class="hljs-keyword">const</span> postJson = <span class="hljs-built_in">JSON</span>.stringify(post);

<span class="hljs-keyword">const</span> postId = <span class="hljs-keyword">await</span> dc.database.create(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,
  <span class="hljs-string">'posts'</span>,
  postJson
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'创建的文章ID:'</span>, postId);
</div></code></pre>
<br>
<h3 id="deletethreadid-collectionname-instanceid"><code>delete(threadId, collectionName, instanceID)</code></h3>
<p>通过ID删除实例。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>threadId</code>: string - threadID</li>
<li><code>collectionName</code>: string - 集合名称</li>
<li><code>instanceID</code>: string - 要删除的实例ID</li>
</ul>
<p><strong>返回:</strong> Promise<void></p>
<p><strong>异常:</strong> 删除失败时抛出错误</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 删除指定ID的用户</span>
<span class="hljs-keyword">await</span> dc.database.delete(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,  <span class="hljs-comment">// threadID</span>
  <span class="hljs-string">'users'</span>,  <span class="hljs-comment">// 集合名称</span>
  <span class="hljs-string">'bafybeihykld5rmrxzs7odlrjil6ntnoaqbkbq2dhzhsajomnsvgcbiewvu'</span>  <span class="hljs-comment">// 要删除的实例ID</span>
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户已删除'</span>);
</div></code></pre>
<br>
<h3 id="savethreadid-collectionname-instance"><code>save(threadId, collectionName, instance)</code></h3>
<p>更新已存在的实例。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>threadId</code>: string - threadID</li>
<li><code>collectionName</code>: string - 集合名称</li>
<li><code>instance</code>: string - JSON字符串表示的实例对象</li>
</ul>
<p><strong>返回:</strong> Promise<void></p>
<p><strong>异常:</strong> 更新失败时抛出错误</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 获取要更新的用户</span>
<span class="hljs-keyword">const</span> userJson = <span class="hljs-keyword">await</span> dc.database.findByID(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,
  <span class="hljs-string">'users'</span>,
  <span class="hljs-string">'bafybeihykld5rmrxzs7odlrjil6ntnoaqbkbq2dhzhsajomnsvgcbiewvu'</span>
);

<span class="hljs-comment">// 解析JSON</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-built_in">JSON</span>.parse(userJson);

<span class="hljs-comment">// 更新用户信息</span>
user.age = <span class="hljs-number">29</span>;
user.email = <span class="hljs-string">'john.doe@example.com'</span>;

<span class="hljs-comment">// 保存更新后的用户</span>
<span class="hljs-keyword">await</span> dc.database.save(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,  <span class="hljs-comment">// threadID</span>
  <span class="hljs-string">'users'</span>,  <span class="hljs-comment">// 集合名称</span>
  <span class="hljs-built_in">JSON</span>.stringify(user)  <span class="hljs-comment">// 更新后的实例JSON</span>
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户信息已更新'</span>);
</div></code></pre>
<br>
<h3 id="deletemanythreadid-collectionname-instanceids"><code>deleteMany(threadId, collectionName, instanceIDs)</code></h3>
<p>批量删除多个实例。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>threadId</code>: string - threadID</li>
<li><code>collectionName</code>: string - 集合名称</li>
<li><code>instanceIDs</code>: string - 逗号分隔或JSON数组表示的实例ID列表</li>
</ul>
<p><strong>返回:</strong> Promise<void></p>
<p><strong>异常:</strong> 删除失败时抛出错误</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 删除多个文章实例</span>
<span class="hljs-keyword">const</span> postIds = [
  <span class="hljs-string">'bafybeihykld5rmrxzs7odlrjil6ntnoaqbkbq2dhzhsajomnsvgcbiewvu'</span>,
  <span class="hljs-string">'bafybeidagua3wl5vdbcszskuoez7gafvubobrw6kprxvptcsi3f42qeium'</span>
];

<span class="hljs-comment">// 方式1: 使用JSON数组</span>
<span class="hljs-keyword">await</span> dc.database.deleteMany(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,  <span class="hljs-comment">// threadID</span>
  <span class="hljs-string">'posts'</span>,  <span class="hljs-comment">// 集合名称</span>
  <span class="hljs-built_in">JSON</span>.stringify(postIds)  <span class="hljs-comment">// JSON数组</span>
);

<span class="hljs-comment">// 方式2: 使用逗号分隔的字符串</span>
<span class="hljs-keyword">await</span> dc.database.deleteMany(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,  <span class="hljs-comment">// threadID</span>
  <span class="hljs-string">'posts'</span>,  <span class="hljs-comment">// 集合名称</span>
  <span class="hljs-string">'bafybeihykld5rmrxzs7odlrjil6ntnoaqbkbq2dhzhsajomnsvgcbiewvu,bafybeidagua3wl5vdbcszskuoez7gafvubobrw6kprxvptcsi3f42qeium'</span>  <span class="hljs-comment">// 逗号分隔的ID</span>
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'多篇文章已删除'</span>);
</div></code></pre>
<br>
<h3 id="hasthreadid-collectionname-instanceid"><code>has(threadId, collectionName, instanceID)</code></h3>
<p>检查指定实例是否存在。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>threadId</code>: string - threadID</li>
<li><code>collectionName</code>: string - 集合名称</li>
<li><code>instanceID</code>: string - 要检查的实例ID</li>
</ul>
<p><strong>返回:</strong> Promise<boolean> - 布尔值表示实例是否存在</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 检查用户是否存在</span>
<span class="hljs-keyword">const</span> exists = <span class="hljs-keyword">await</span> dc.database.has(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,  <span class="hljs-comment">// threadID</span>
  <span class="hljs-string">'users'</span>,  <span class="hljs-comment">// 集合名称</span>
  <span class="hljs-string">'bafybeihykld5rmrxzs7odlrjil6ntnoaqbkbq2dhzhsajomnsvgcbiewvu'</span>  <span class="hljs-comment">// 实例ID</span>
);

<span class="hljs-keyword">if</span> (exists) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户存在'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户不存在'</span>);
}
</div></code></pre>
<br>
<h3 id="findthreadid-collectionname-querystring"><code>find(threadId, collectionName, queryString)</code></h3>
<p>根据查询条件查找实例。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>threadId</code>: string - threadID</li>
<li><code>collectionName</code>: string - 集合名称</li>
<li><code>queryString</code>: string - JSON字符串表示的查询条件,
格式举例:(condition表示and条件组合, ors表示或条件组合, sort表示排序, seek表示分页)
格式1: <code>{&quot;condition&quot;:&quot;age=80 and name='John'&quot;}</code>,&quot;sort&quot;:{&quot;fieldPath&quot;:&quot;age&quot;,&quot;desc&quot;:true}}<code>格式2:</code>{&quot;ors&quot;:[{&quot;condition&quot;:&quot;age = 21 and name = 'foo'&quot;}]}<code>格式3:</code>{&quot;condition&quot;:&quot;age &gt; 21 &quot;,&quot;ors&quot;:[{&quot;condition&quot;:&quot;age = 21 and name = 'foo'&quot;}],&quot;sort&quot;:{&quot;fieldPath&quot;:&quot;age&quot;,&quot;desc&quot;:true},&quot;seek&quot;:&quot;01fyc691gh671nf0s8qpt0ych8&quot;}`</li>
</ul>
<p><strong>返回:</strong> Promise<string> - JSON字符串表示的查询结果</p>
<p><strong>异常:</strong> 查询失败时抛出错误</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 示例1: 简单查询 - 查找年龄为28的用户</span>
<span class="hljs-keyword">const</span> query1 = {
  condition: <span class="hljs-string">"age = 28"</span>
};
<span class="hljs-keyword">const</span> results1 = <span class="hljs-keyword">await</span> dc.database.find(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,
  <span class="hljs-string">'users'</span>,
  <span class="hljs-built_in">JSON</span>.stringify(query1)
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'28岁的用户:'</span>, <span class="hljs-built_in">JSON</span>.parse(results1));

<span class="hljs-comment">// 示例2: 组合条件查询 - 查找年龄大于25且名字为John的用户</span>
<span class="hljs-keyword">const</span> query2 = {
  condition: <span class="hljs-string">"age &gt; 25 and name = 'John Doe'"</span>
};
<span class="hljs-keyword">const</span> results2 = <span class="hljs-keyword">await</span> dc.database.find(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,
  <span class="hljs-string">'users'</span>,
  <span class="hljs-built_in">JSON</span>.stringify(query2)
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'年龄大于25的John:'</span>, <span class="hljs-built_in">JSON</span>.parse(results2));

<span class="hljs-comment">// 示例3: 使用OR条件查询 - 查找年龄为21或名字为Jane的用户</span>
<span class="hljs-keyword">const</span> query3 = {
  ors: [
    { condition: <span class="hljs-string">"age = 21"</span> },
    { condition: <span class="hljs-string">"name = 'Jane Smith'"</span> }
  ]
};
<span class="hljs-keyword">const</span> results3 = <span class="hljs-keyword">await</span> dc.database.find(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,
  <span class="hljs-string">'users'</span>,
  <span class="hljs-built_in">JSON</span>.stringify(query3)
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'21岁或名为Jane的用户:'</span>, <span class="hljs-built_in">JSON</span>.parse(results3));

<span class="hljs-comment">// 示例4: 带排序和分页的复杂查询</span>
<span class="hljs-keyword">const</span> query4 = {
  condition: <span class="hljs-string">"age &gt; 20"</span>,
  ors: [
    { condition: <span class="hljs-string">"name = 'John Doe'"</span> }
  ],
  sort: {
    fieldPath: <span class="hljs-string">"age"</span>,
    desc: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 从大到小排序</span>
  },
  seek: <span class="hljs-string">"01fyc691gh671nf0s8qpt0ych8"</span>  <span class="hljs-comment">// 分页标记</span>
};
<span class="hljs-keyword">const</span> results4 = <span class="hljs-keyword">await</span> dc.database.find(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,
  <span class="hljs-string">'users'</span>,
  <span class="hljs-built_in">JSON</span>.stringify(query4)
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'复杂查询结果:'</span>, <span class="hljs-built_in">JSON</span>.parse(results4));
</div></code></pre>
<br>
<h3 id="findbyidthreadid-collectionname-instanceid"><code>findByID(threadId, collectionName, instanceID)</code></h3>
<p>通过ID查找实例。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>threadId</code>: string - threadID</li>
<li><code>collectionName</code>: string - 集合名称</li>
<li><code>instanceID</code>: string - 实例ID</li>
</ul>
<p><strong>返回:</strong> Promise<string> - JSON字符串表示的实例</p>
<p><strong>异常:</strong> 查询失败时抛出错误</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 通过ID查找用户</span>
<span class="hljs-keyword">const</span> userJson = <span class="hljs-keyword">await</span> dc.database.findByID(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,  <span class="hljs-comment">// threadID</span>
  <span class="hljs-string">'users'</span>,  <span class="hljs-comment">// 集合名称</span>
  <span class="hljs-string">'bafybeihykld5rmrxzs7odlrjil6ntnoaqbkbq2dhzhsajomnsvgcbiewvu'</span>  <span class="hljs-comment">// 实例ID</span>
);

<span class="hljs-keyword">if</span> (userJson) {
  <span class="hljs-keyword">const</span> user = <span class="hljs-built_in">JSON</span>.parse(userJson);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'找到的用户:'</span>, user);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'未找到用户'</span>);
}
</div></code></pre>
<br>
<h3 id="modifiedsincethreadid-collectionname-time"><code>modifiedSince(threadId, collectionName, time)</code></h3>
<p>获取在指定时间后被修改的实例ID列表。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>threadId</code>: string - threadID</li>
<li><code>collectionName</code>: string - 集合名称</li>
<li><code>time</code>: number - 时间戳（毫秒）</li>
</ul>
<p><strong>返回:</strong> Promise<string> - JSON字符串表示的实例ID列表</p>
<p><strong>异常:</strong> 查询失败时抛出错误</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 获取过去24小时内修改的所有用户ID</span>
<span class="hljs-keyword">const</span> oneDayAgo = <span class="hljs-built_in">Date</span>.now() - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>); <span class="hljs-comment">// 24小时前的时间戳(毫秒)</span>

<span class="hljs-keyword">const</span> modifiedIdsJson = <span class="hljs-keyword">await</span> dc.database.modifiedSince(
  <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,  <span class="hljs-comment">// threadID</span>
  <span class="hljs-string">'users'</span>,  <span class="hljs-comment">// 集合名称</span>
  oneDayAgo  <span class="hljs-comment">// 时间戳(毫秒)</span>
);

<span class="hljs-keyword">const</span> modifiedIds = <span class="hljs-built_in">JSON</span>.parse(modifiedIdsJson);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'最近24小时内修改的用户ID:'</span>, modifiedIds);

<span class="hljs-comment">// 如果有修改的用户，获取他们的详细信息</span>
<span class="hljs-keyword">if</span> (modifiedIds.length &gt; <span class="hljs-number">0</span>) {
  <span class="hljs-comment">// 获取第一个修改用户的详细信息</span>
  <span class="hljs-keyword">const</span> userJson = <span class="hljs-keyword">await</span> dc.database.findByID(
    <span class="hljs-string">'bafk3epa4rnnhworywhk6hsi7wafwgdt3fkgvpf62wqlriwpwqjwjuqbf4'</span>,
    <span class="hljs-string">'users'</span>,
    modifiedIds[<span class="hljs-number">0</span>]
  );
  
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'最近修改的用户信息:'</span>, <span class="hljs-built_in">JSON</span>.parse(userJson));
}
</div></code></pre>
<br>
<h2 id="%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">完整使用示例</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// 示例: 创建并使用一个任务管理数据库</span>

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">taskManagerExample</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 1. 初始化数据库管理器</span>
    <span class="hljs-keyword">await</span> dc.database.initDBManager();
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据库管理器已初始化'</span>);
    
    <span class="hljs-comment">// 2. 定义集合配置</span>
    <span class="hljs-keyword">const</span> collections = [
      {
        name: <span class="hljs-string">'tasks'</span>,
        schema: {
          title: <span class="hljs-string">'Task'</span>,
          <span class="hljs-keyword">type</span>: <span class="hljs-string">'object'</span>,
          properties: {
            _id: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> },
            title: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> },
            description: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span> },
            status: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span>, <span class="hljs-keyword">enum</span>: [<span class="hljs-string">'todo'</span>, <span class="hljs-string">'in-progress'</span>, <span class="hljs-string">'done'</span>] },
            priority: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'integer'</span>, minimum: <span class="hljs-number">1</span>, maximum: <span class="hljs-number">5</span> },
            dueDate: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span>, format: <span class="hljs-string">'date-time'</span> },
            createdAt: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span>, format: <span class="hljs-string">'date-time'</span> },
            updatedAt: { <span class="hljs-keyword">type</span>: <span class="hljs-string">'string'</span>, format: <span class="hljs-string">'date-time'</span> }
          },
          required: [<span class="hljs-string">'_id'</span>, <span class="hljs-string">'title'</span>, <span class="hljs-string">'status'</span>, <span class="hljs-string">'priority'</span>, <span class="hljs-string">'createdAt'</span>]
        }
      }
    ];
    
    <span class="hljs-comment">// 3. 创建新数据库</span>
    <span class="hljs-keyword">const</span> threadId = <span class="hljs-keyword">await</span> dc.database.newDB(
      <span class="hljs-string">'taskManager'</span>,
      <span class="hljs-string">'base32ReadKeyXXXXXXXXXXXXXXXX'</span>,
      <span class="hljs-string">'base32ServiceKeyYYYYYYYYYYYYYY'</span>,
      collections
    );
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'任务管理数据库已创建，threadID:'</span>, threadId);
    
    <span class="hljs-comment">// 4. 创建任务实例</span>
    <span class="hljs-keyword">const</span> task1 = {
      title: <span class="hljs-string">'完成数据库接口文档'</span>,
      description: <span class="hljs-string">'为ThreadDB接口编写详细文档和示例代码'</span>,
      status: <span class="hljs-string">'in-progress'</span>,
      priority: <span class="hljs-number">4</span>,
      dueDate: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.now() + <span class="hljs-number">86400000</span>).toISOString(), <span class="hljs-comment">// 明天</span>
      createdAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString(),
      updatedAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()
    };
    
    <span class="hljs-keyword">const</span> task1Id = <span class="hljs-keyword">await</span> dc.database.create(
      threadId,
      <span class="hljs-string">'tasks'</span>,
      <span class="hljs-built_in">JSON</span>.stringify(task1)
    );
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'创建的任务ID:'</span>, task1Id);
    
    <span class="hljs-keyword">const</span> task2 = {
      title: <span class="hljs-string">'修复UI显示bug'</span>,
      description: <span class="hljs-string">'解决任务列表中的显示问题'</span>,
      status: <span class="hljs-string">'todo'</span>,
      priority: <span class="hljs-number">3</span>,
      dueDate: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.now() + <span class="hljs-number">172800000</span>).toISOString(), <span class="hljs-comment">// 后天</span>
      createdAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString(),
      updatedAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()
    };
    
    <span class="hljs-keyword">const</span> task2Id = <span class="hljs-keyword">await</span> dc.database.create(
      threadId,
      <span class="hljs-string">'tasks'</span>,
      <span class="hljs-built_in">JSON</span>.stringify(task2)
    );
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'创建的任务ID:'</span>, task2Id);
    
    <span class="hljs-comment">// 5. 查询高优先级任务</span>
    <span class="hljs-keyword">const</span> highPriorityQuery = {
      condition: <span class="hljs-string">"priority &gt;= 4"</span>,
      sort: {
        fieldPath: <span class="hljs-string">"dueDate"</span>,
        desc: <span class="hljs-literal">false</span> <span class="hljs-comment">// 按截止日期升序排序</span>
      }
    };
    
    <span class="hljs-keyword">const</span> highPriorityTasks = <span class="hljs-keyword">await</span> dc.database.find(
      threadId,
      <span class="hljs-string">'tasks'</span>,
      <span class="hljs-built_in">JSON</span>.stringify(highPriorityQuery)
    );
    
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'高优先级任务:'</span>, <span class="hljs-built_in">JSON</span>.parse(highPriorityTasks));
    
    <span class="hljs-comment">// 6. 更新任务状态</span>
    <span class="hljs-keyword">const</span> taskToUpdate = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-keyword">await</span> dc.database.findByID(
      threadId,
      <span class="hljs-string">'tasks'</span>,
      task1Id
    ));
    
    taskToUpdate.status = <span class="hljs-string">'done'</span>;
    taskToUpdate.updatedAt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString();
    
    <span class="hljs-keyword">await</span> dc.database.save(
      threadId,
      <span class="hljs-string">'tasks'</span>,
      <span class="hljs-built_in">JSON</span>.stringify(taskToUpdate)
    );
    
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'任务已更新为完成状态'</span>);
    
    <span class="hljs-comment">// 7. 同步数据库到分布式网络</span>
    <span class="hljs-keyword">const</span> syncError = <span class="hljs-keyword">await</span> dc.database.syncDBToDC(threadId);
    
    <span class="hljs-keyword">if</span> (syncError === <span class="hljs-literal">null</span>) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据库已同步到分布式网络'</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'同步数据库时出错:'</span>, syncError.message);
    }
    
    <span class="hljs-comment">// 8. 关闭数据库</span>
    <span class="hljs-keyword">await</span> dc.database.close();
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据库已关闭'</span>);
    
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'数据库操作出错:'</span>, error);
  }
}

<span class="hljs-comment">// 执行示例</span>
taskManagerExample();
</div></code></pre>
<p><br><br></p>
<h2 id="%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97-cache">缓存模块 (cache)</h2>
<p>提供临时缓存功能。</p>
<h3 id="%E6%96%B9%E6%B3%95">方法</h3>
<h4 id="getcachevaluekey"><code>getCacheValue(key)</code></h4>
<p>获取缓存值。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>key</code>: string - 缓存键</li>
</ul>
<p><strong>返回:</strong> Promise&lt;string | null&gt; - 缓存值，不存在则返回null</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> value = <span class="hljs-keyword">await</span> dc.cache.getCacheValue(<span class="hljs-string">'cache-key'</span>);
<span class="hljs-keyword">if</span> (value) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'缓存值:'</span>, value);
}
</div></code></pre>
<br>
<h4 id="setcachekeyvalue-expire"><code>setCacheKey(value, expire)</code></h4>
<p>设置缓存值。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>value</code>: string - 缓存值</li>
<li><code>expire</code>: number (可选) - 过期时间(秒)，默认1天</li>
</ul>
<p><strong>返回:</strong> Promise<any> - 设置结果</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> dc.cache.setCacheKey(
  <span class="hljs-string">'cache-value'</span>,
  <span class="hljs-number">3600</span> <span class="hljs-comment">// 1小时后过期</span>
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'缓存设置结果:'</span>, result);
</div></code></pre>
<p><br><br></p>
<h2 id="ai%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9D%97-aiproxy">AI代理模块 (aiproxy)</h2>
<p>提供AI代理服务配置和调用功能。</p>
<h3 id="%E6%96%B9%E6%B3%95">方法</h3>
<h4 id="createproxyconfigappid-configtheme"><code>createProxyConfig(appId, configTheme)</code></h4>
<p>创建AI调用代理配置。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>appId</code>: string - 应用ID</li>
<li><code>configTheme</code>: string - 配置主题名称</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[number, Error | null]&gt; - 状态码和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [status, error] = <span class="hljs-keyword">await</span> dc.aiproxy.createProxyConfig(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'ai-services'</span>
);
<span class="hljs-keyword">if</span> (status === <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'创建AI代理配置成功'</span>);
}
</div></code></pre>
<br>
<h4 id="configaiproxyappid-configauthor-configtheme-servername-serverconfig-vaccount"><code>configAIProxy(appId, configAuthor, configTheme, serverName, serverConfig, vaccount)</code></h4>
<p>配置AI代理访问设置。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>appId</code>: string - 应用ID</li>
<li><code>configAuthor</code>: string - 配置作者公钥</li>
<li><code>configTheme</code>: string - 配置主题名称</li>
<li><code>serverName</code>: string - 服务器名称</li>
<li><code>serverConfig</code>: AIProxyConfig (可选) - 服务器配置，为空则表示删除该服务器的配置</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[boolean, Error | null]&gt; - 是否配置成功和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> config = {
  blockheight: <span class="hljs-number">12345</span>,
  isAIModel: <span class="hljs-number">0</span>, <span class="hljs-comment">// AI模型</span>
  apiType: <span class="hljs-number">1</span>, <span class="hljs-comment">// OpenAI API</span>
  authorization: <span class="hljs-string">'Bearer sk-xxxx'</span>,
  endpoint: <span class="hljs-string">'https://api.openai.com/v1'</span>,
  organization: <span class="hljs-string">'org-id'</span>,
  apiVersion: <span class="hljs-string">'2023-05-15'</span>,
  model: <span class="hljs-string">'gpt-4'</span>,
  remark: <span class="hljs-string">'测试配置'</span>
};

<span class="hljs-keyword">const</span> [success, error] = <span class="hljs-keyword">await</span> dc.aiproxy.configAIProxy(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'config-author-pubkey'</span>,
  <span class="hljs-string">'ai-services'</span>,
  <span class="hljs-string">'openai-gpt4'</span>,
  config
);

<span class="hljs-keyword">if</span> (success) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'AI代理配置成功'</span>);
}
</div></code></pre>
<br>
<h4 id="configauthappid-configauthor-configtheme-authpubkey-permission-authconfig-vaccount"><code>configAuth(appId, configAuthor, configTheme, authPubkey, permission, authConfig, vaccount)</code></h4>
<p>配置用户的访问权限。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>appId</code>: string - 应用ID</li>
<li><code>configAuthor</code>: string - 配置作者公钥</li>
<li><code>configTheme</code>: string - 配置主题名称</li>
<li><code>authPubkey</code>: string - 用户公钥</li>
<li><code>permission</code>: AIProxyUserPermission - 用户权限枚举</li>
<li><code>authConfig</code>: ProxyCallConfig - 用户访问配置</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[number, Error | null]&gt; - 状态码和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> AIProxyUserPermission {
  QUERY = <span class="hljs-number">8</span>, <span class="hljs-comment">//查询</span>
  ADMIN = <span class="hljs-number">4</span>, <span class="hljs-comment">//管理员</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ProxyCallConfig  {
    No: <span class="hljs-built_in">number</span>;<span class="hljs-comment">//订阅序号,每次调用都必须在上次的基础上进行加1</span>
    Tlim?: <span class="hljs-built_in">number</span>;<span class="hljs-comment">//总访问次数限制</span>
    Dlim?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//日访问次数限制</span>
    Wlim?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//周访问次数限制</span>
    Mlim?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//月访问次数限制</span>
    Ylim?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">//年访问次数限制</span>
    Exp?: <span class="hljs-built_in">number</span>;<span class="hljs-comment">//过期区块高度</span>
}   

<span class="hljs-keyword">const</span> permission = AIProxyUserPermission.ADMIN; <span class="hljs-comment">// 设置为管理员权限</span>
<span class="hljs-keyword">const</span> authConfig: ProxyCallConfig = {
    No: <span class="hljs-number">1</span>,
    Tlim: <span class="hljs-number">1000</span>, <span class="hljs-comment">// 总访问次数限制</span>
    Dlim: <span class="hljs-number">100</span>, <span class="hljs-comment">// 日访问次数限制</span>
    Wlim: <span class="hljs-number">500</span>, <span class="hljs-comment">// 周访问次数限制</span>
    Mlim: <span class="hljs-number">2000</span>, <span class="hljs-comment">// 月访问次数限制</span>
    Ylim: <span class="hljs-number">10000</span>, <span class="hljs-comment">// 年访问次数限制</span>
    Exp: <span class="hljs-number">12345678</span> <span class="hljs-comment">// 过期区块高度</span>
};
<span class="hljs-keyword">const</span> [status, error] = <span class="hljs-keyword">await</span> dc.aiproxy.configAuth(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'config-author-pubkey'</span>,
  <span class="hljs-string">'ai-services'</span>,
  <span class="hljs-string">'auth-user-pubkey'</span>,
  permission,
  authConfig
);
<span class="hljs-keyword">if</span> (status === <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户访问权限配置成功'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'配置失败:'</span>, error);
}
</div></code></pre>
<br>
<h4 id="getaiproxyconfigappid-themeauthor-configthem-vaccount"><code>GetAIProxyConfig(appId, themeAuthor, configThem, vaccount)</code></h4>
<p>获取的ai代理的所有配置,包括服务与授权列表</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>appId</code>: string - 应用ID</li>
<li><code>themeAuthor</code>: string - 主题作者公钥</li>
<li><code>configThem</code>: string - 配置主题名称</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[UserProxyCallConfig[] | null, AIProxyConfig[] | null, Error | null]&gt; - 用户代理调用配置、AI代理服务配置和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [userConfigs, aiConfigs, error] = <span class="hljs-keyword">await</span> dc.aiproxy.GetAIProxyConfig(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'config-author-pubkey'</span>,
  <span class="hljs-string">'ai-services'</span>
);
<span class="hljs-keyword">if</span> (error) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'获取AI代理配置失败:'</span>, error);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户代理调用配置:'</span>, userConfigs);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'AI代理服务配置:'</span>, aiConfigs);
}
</div></code></pre>
<br>
<h4 id="getuserownaiproxyauthappid-themeauthor-configthem"><code>GetUserOwnAIProxyAuth(appId, themeAuthor, configThem)</code></h4>
<p>获取用户自身的AI代理授权配置。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>appId</code>: string - 应用ID</li>
<li><code>themeAuthor</code>: string - 主题作者公钥</li>
<li><code>configThem</code>: string - 配置主题名称</li>
<li><code>vaccount</code>: string (可选) - 虚拟账户</li>
</ul>
<p><strong>返回:</strong> Promise&lt;[authConfig: ProxyCallConfig, error: Error | null]&gt; - 用户AI代理授权配置和错误信息</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> [authConfig, error] = <span class="hljs-keyword">await</span> dc.aiproxy.GetUserOwnAIProxyAuth(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'config-author-pubkey'</span>,
  <span class="hljs-string">'ai-services'</span>
);
<span class="hljs-keyword">if</span> (error) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'获取用户AI代理授权配置失败:'</span>, error);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'用户AI代理授权配置:'</span>, authConfig);
}
</div></code></pre>
<br>
<h4 id="doaiproxycallappid-themeauthor-configtheme-servername-reqbody-forcerefresh-onstreamresponse-headers-path-model"><code>DoAIProxyCall(appId, themeAuthor, configTheme, serverName, reqBody, forceRefresh, onStreamResponse, headers, path, model)</code></h4>
<p>执行AI代理调用。</p>
<p><strong>参数:</strong></p>
<ul>
<li><code>appId</code>: string - 应用ID</li>
<li><code>themeAuthor</code>: string - 主题作者公钥</li>
<li><code>configTheme</code>: string - 配置主题名称</li>
<li><code>serverName</code>: string - 服务器名称</li>
<li><code>reqBody</code>: string - 请求体</li>
<li><code>forceRefresh</code>: boolean - 是否强制刷新</li>
<li><code>onStreamResponse</code>: (chunk: any) =&gt; void (可选) - 流式响应回调</li>
<li><code>headers</code>: string (可选) - 请求头</li>
<li><code>path</code>: string (可选) - 请求路径</li>
<li><code>model</code>: string (可选) - 模型名称</li>
</ul>
<p><strong>返回:</strong> Promise<number> - 调用状态码</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> reqBody = <span class="hljs-built_in">JSON</span>.stringify({
  messages: [
    {role: <span class="hljs-string">'user'</span>, content: <span class="hljs-string">'请生成一个JavaScript求和函数'</span>}
  ]
});

<span class="hljs-comment">// 流式响应处理</span>
<span class="hljs-keyword">const</span> onStreamResponse = <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'收到流式响应:'</span>, chunk);
};

<span class="hljs-keyword">const</span> status = <span class="hljs-keyword">await</span> dc.aiproxy.DoAIProxyCall(
  <span class="hljs-string">'myapp'</span>,
  <span class="hljs-string">'config-author-pubkey'</span>,
  <span class="hljs-string">'ai-services'</span>,
  <span class="hljs-string">'openai-gpt4'</span>,
  reqBody,
  <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不强制刷新</span>
  onStreamResponse,
  <span class="hljs-string">'Content-Type: application/json'</span>,
  <span class="hljs-string">'/v1/chat/completions'</span>
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'API调用状态:'</span>, status);
</div></code></pre>
<p><br><br></p>
<h2 id="%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">常见使用流程</h2>
<h3 id="1-%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B">1. 用户认证流程</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// 1. 初始化DC客户端</span>
<span class="hljs-keyword">const</span> dc = <span class="hljs-keyword">new</span> DC({
  wssUrl: <span class="hljs-string">'wss://blockchain.example.com'</span>,
  appInfo: { appId: <span class="hljs-string">'myapp'</span>, appName: <span class="hljs-string">'My Application'</span> }
});
<span class="hljs-keyword">await</span> dc.init();

<span class="hljs-comment">// 2. 使用NFT账号登录</span>
<span class="hljs-keyword">const</span> loginSuccess = <span class="hljs-keyword">await</span> dc.auth.accountLogin(<span class="hljs-string">'user-nft-account'</span>, <span class="hljs-string">'password'</span>, <span class="hljs-string">'000000'</span>);
<span class="hljs-keyword">if</span> (!loginSuccess) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'登录失败'</span>);
  <span class="hljs-keyword">return</span>;
}

<span class="hljs-comment">// 3. 获取用户信息</span>
<span class="hljs-keyword">const</span> userInfo = <span class="hljs-keyword">await</span> dc.auth.getUserInfoWithNft(<span class="hljs-string">'user-nft-account'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'欢迎回来,'</span>, userInfo.name);
</div></code></pre>
<h3 id="2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B">2. 文件上传与访问流程</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// 1. 上传文件</span>
<span class="hljs-keyword">const</span> file = <span class="hljs-keyword">new</span> File([<span class="hljs-string">'file content'</span>], <span class="hljs-string">'document.txt'</span>);
<span class="hljs-keyword">const</span> uploadResult = <span class="hljs-keyword">await</span> dc.file.addFile(
  file,
  <span class="hljs-string">'encryption-key'</span>,
  <span class="hljs-function">(<span class="hljs-params">status, size</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`上传进度: <span class="hljs-subst">${status}</span>%, 已上传: <span class="hljs-subst">${size}</span> 字节`</span>)
);

<span class="hljs-keyword">const</span> fileCid = uploadResult.cid;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'文件已上传，CID:'</span>, fileCid);

<span class="hljs-comment">// 2. 下载并使用文件</span>
<span class="hljs-keyword">const</span> fileContent = <span class="hljs-keyword">await</span> dc.file.getFile(fileCid, <span class="hljs-string">'encryption-key'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'文件内容:'</span>, <span class="hljs-keyword">new</span> TextDecoder().decode(fileContent));

<span class="hljs-comment">// 3. 创建流式访问（适用于大文件）</span>
<span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">await</span> dc.file.createFileStream(fileCid, <span class="hljs-string">'encryption-key'</span>);
<span class="hljs-comment">// 处理流...</span>
</div></code></pre>
<h3 id="3-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">3. 评论系统使用流程</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// 1. 为用户开通评论空间</span>
<span class="hljs-keyword">await</span> dc.comment.addUserOffChainSpace();

<span class="hljs-comment">// 2. 为主题开通评论功能</span>
<span class="hljs-keyword">await</span> dc.comment.addThemeObj(<span class="hljs-string">'article-123'</span>, OpenFlag.PUBLIC);

<span class="hljs-comment">// 3. 发布评论</span>
<span class="hljs-keyword">const</span> commentResult = <span class="hljs-keyword">await</span> dc.comment.publishCommentToTheme(
  <span class="hljs-string">'article-123'</span>,
  <span class="hljs-string">'article-author-pubkey'</span>,
  <span class="hljs-number">0</span>, <span class="hljs-comment">// 普通评论</span>
  <span class="hljs-string">'这是一条评论'</span>
);

<span class="hljs-comment">// 4. 获取评论列表</span>
<span class="hljs-keyword">const</span> comments = <span class="hljs-keyword">await</span> dc.comment.getThemeComments(<span class="hljs-string">'article-123'</span>, <span class="hljs-string">'article-author-pubkey'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'文章评论:'</span>, comments);
</div></code></pre>
<h3 id="4-%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">4. 键值存储使用流程</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// 1. 创建存储主题</span>
<span class="hljs-keyword">await</span> dc.keyvalue.createStore(<span class="hljs-string">'app-data'</span>, <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, <span class="hljs-number">1</span>);

<span class="hljs-comment">// 2. 存储数据</span>
<span class="hljs-keyword">await</span> dc.keyvalue.setKeyValue(
  <span class="hljs-string">'myapp'</span>,
  dc.auth.getPublicKey().toString(),
  <span class="hljs-string">'app-data'</span>,
  <span class="hljs-string">'settings'</span>,
  <span class="hljs-built_in">JSON</span>.stringify({theme: <span class="hljs-string">'dark'</span>, notifications: <span class="hljs-literal">true</span>}),
  <span class="hljs-string">'type:settings'</span>
);

<span class="hljs-comment">// 3. 读取数据</span>
<span class="hljs-keyword">const</span> [value, error] = <span class="hljs-keyword">await</span> dc.keyvalue.getValueWithKey(
  <span class="hljs-string">'myapp'</span>,
  dc.auth.getPublicKey().toString(),
  <span class="hljs-string">'app-data'</span>,
  dc.auth.getPublicKey().toString(),
  <span class="hljs-string">'settings'</span>
);

<span class="hljs-keyword">if</span> (value) {
  <span class="hljs-keyword">const</span> settings = <span class="hljs-built_in">JSON</span>.parse(value);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'应用设置:'</span>, settings);
}
</div></code></pre>
<h3 id="5-ai%E4%BB%A3%E7%90%86%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B">5. AI代理调用流程</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// 1. 创建AI代理配置</span>
<span class="hljs-keyword">await</span> dc.aiproxy.createProxyConfig(<span class="hljs-string">'myapp'</span>, <span class="hljs-string">'ai-services'</span>);

<span class="hljs-comment">// 2. 配置AI服务</span>
<span class="hljs-keyword">const</span> config = {
  blockheight: <span class="hljs-number">12345</span>,
  isAIModel: <span class="hljs-number">0</span>,
  apiType: <span class="hljs-number">1</span>, <span class="hljs-comment">// OpenAI API</span>
  authorization: <span class="hljs-string">'Bearer sk-xxxx'</span>,
  endpoint: <span class="hljs-string">'https://api.openai.com/v1'</span>,
  organization: <span class="hljs-string">''</span>,
  apiVersion: <span class="hljs-string">'2023-05-15'</span>,
  model: <span class="hljs-string">'gpt-3.5-turbo'</span>,
  remark: <span class="hljs-string">'通用AI服务'</span>
};

<span class="hljs-keyword">await</span> dc.aiproxy.configAIProxy(
  <span class="hljs-string">'myapp'</span>,
  dc.auth.getPublicKey().toString(),
  <span class="hljs-string">'ai-services'</span>,
  <span class="hljs-string">'my-openai'</span>,
  config
);

<span class="hljs-comment">// 3. 调用AI服务</span>
<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> dc.aiproxy.DoAIProxyCall(
  <span class="hljs-string">'myapp'</span>,
  dc.auth.getPublicKey().toString(),
  <span class="hljs-string">'ai-services'</span>,
  <span class="hljs-string">'my-openai'</span>,
  <span class="hljs-built_in">JSON</span>.stringify({
    messages: [{role: <span class="hljs-string">'user'</span>, content: <span class="hljs-string">'Hello AI!'</span>}]
  }),
  <span class="hljs-literal">false</span>,
  <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'AI回复:'</span>, response)
);
</div></code></pre>

</body>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script>
</html>


 # DC API 接口文档

## 目录

1. 概览
2. 初始化
3. 认证模块 (auth)
4. 文件模块 (file)
5. 客户端模块 (client)
6. 消息模块 (message)
7. 评论模块 (comment)
8. 键值存储模块 (keyvalue)
9. 数据库模块 (database)
10. 缓存模块 (cache)
11. AI代理模块 (aiproxy)
12. 常见使用流程

## 概览

DC API是一个分布式存储和通信库，提供了身份验证、文件存储、消息传递、评论系统、数据库管理等核心功能。该API基于区块链技术，支持去中心化应用程序开发。

## 初始化

首先需要创建DC实例并初始化它:

```typescript
import { DC } from './dc-compat';

const dc = new DC({
  wssUrl: '区块链路径',
  backWssUrl: '区块链备用路径',
  appInfo: {
    id: 'DCAPP',  // 应用ID
    name: 'DCAPP Name',  // 应用名称
  },
});

// 初始化DC客户端，连接区块链和存储节点
await dc.init();
```

## 认证模块 (auth)

负责用户身份验证、账户管理和访问控制。

### 方法

#### `accountLogin(nftAccount, password, safecode)`

用NFT账户登录系统。

```typescript
const success = await dc.auth.accountLogin('my-nft-account', 'password', '000000');
if (success) {
  console.log('登录成功');
}
```

**参数:**
- `nftAccount`: string - NFT账户名称
- `password`: string - 密码
- `safecode`: string - 安全码，默认"000000"

**返回:** Promise<boolean> - 登录是否成功

#### `bindNFTAccount(account, password, seccode, mnemonic)`

将私钥绑定到NFT账号。

```typescript
const [status, error] = await dc.auth.bindNFTAccount('nft-id', 'password', 'seccode', 'mnemonic phrase');
if (status === NFTBindStatus.Success) {
  console.log('绑定成功');
}
```

**参数:**
- `account`: string - NFT账号
- `password`: string - 密码
- `seccode`: string - 安全码
- `mnemonic`: string - 助记词

**返回:** Promise<[NFTBindStatus, Error | null]> - 绑定状态码和错误信息

#### `generateAppAccount(appId, mnemonic)`

创建应用子账号。

```typescript
const [privateKey, error] = await dc.auth.generateAppAccount('myapp', 'mnemonic phrase');
if (privateKey) {
  console.log('子账号私钥:', privateKey);
}
```

**参数:**
- `appId`: string - 应用ID
- `mnemonic`: string - 助记词

**返回:** Promise<[string | null, Error | null]> - 私钥字符串和错误信息

#### `isNftAccountBindSuccess(account)`

检查NFT账号是否成功绑定到用户公钥。

```typescript
const isBound = await dc.auth.isNftAccountBindSuccess('nft-account');
console.log('NFT账号绑定状态:', isBound);
```

**参数:**
- `account`: string - NFT账号

**返回:** Promise<boolean> - 是否成功绑定

#### `isNftAccountBinded(account)`

检查NFT账号是否已被任何账号绑定。

```typescript
const isAlreadyBinded = await dc.auth.isNftAccountBinded('nft-account');
console.log('NFT账号是否已被绑定:', isAlreadyBinded);
```

**参数:**
- `account`: string - NFT账号

**返回:** Promise<boolean> - 是否已被绑定

#### `getUserInfoWithNft(nftAccount)`

根据NFT账户获取用户信息。

```typescript
const userInfo = await dc.auth.getUserInfoWithNft('nft-account');
console.log('用户信息:', userInfo);
```

**参数:**
- `nftAccount`: string - NFT账户

**返回:** Promise<any> - 用户信息对象

## 文件模块 (file)

提供文件上传、下载和缓存功能。

### 方法

#### `addFile(file, enkey, onUpdateTransmitSize)`

上传文件到存储系统。

```typescript
const file = new File(['content'], 'test.txt');
const result = await dc.file.addFile(
  file,
  'encryption-key',
  (status, size) => console.log(`上传进度：${status}%, 大小：${size}`)
);
console.log('上传结果:', result);
```

**参数:**
- `file`: File - 要上传的文件
- `enkey`: string - 加密密钥
- `onUpdateTransmitSize`: (status: number, size: number) => void - 进度回调函数

**返回:** Promise<any> - 上传结果，包含CID等信息

#### `getFile(cid, decryptKey)`

获取文件内容。

```typescript
const fileContent = await dc.file.getFile('QmFileHash...', 'decryption-key');
if (fileContent) {
  console.log('文件内容字节长度:', fileContent.length);
}
```

**参数:**
- `cid`: string - 文件内容标识符
- `decryptKey`: string - 解密密钥

**返回:** Promise<Uint8Array | undefined> - 文件字节数组

#### `createFileStream(cid, decryptKey)`

创建文件可读流，适用于大文件处理。

```typescript
const stream = await dc.file.createFileStream('QmFileHash...', 'decryption-key');
if (stream) {
  // 使用可读流处理文件
  const reader = stream.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    console.log('读取数据块:', value.length);
  }
}
```

**参数:**
- `cid`: string - 文件内容标识符
- `decryptKey`: string - 解密密钥

**返回:** Promise<ReadableStream<Uint8Array> | null> - 文件可读流

#### `getSeekableFileStream(ipfsPath, decryptKey)`

获取支持随机访问的文件流，适用于视频播放等场景。

```typescript
const seekableStream = await dc.file.getSeekableFileStream('/ipfs/QmFileHash...', 'decryption-key');
// 从文件的第1000字节开始读取
const data = await seekableStream.read(1000, 1024);
console.log('读取的数据:', data);
```

**参数:**
- `ipfsPath`: string - IPFS路径或CID
- `decryptKey`: string - 解密密钥

**返回:** Promise<SeekableFileStream> - 可随机访问的文件流

#### `clearFileCache(pathname)`

清理文件缓存。

```typescript
// 清理特定文件缓存
dc.file.clearFileCache('/ipfs/QmFileHash...');

// 清理所有缓存
dc.file.clearFileCache();
```

**参数:**
- `pathname`: string (可选) - 特定文件路径，不提供则清除所有缓存

**返回:** void

## 客户端模块 (client)

提供底层节点连接和网络通信功能。

### 方法

#### `getHostID()`

获取当前连接的节点ID和客户端公网地址。

```typescript
const [hostInfo, error] = await dc.client.getHostID();
if (hostInfo) {
  console.log('节点ID:', hostInfo.peerID);
  console.log('客户端公网地址:', hostInfo.reqAddr);
}
```

**参数:** 无

**返回:** Promise<[{ peerID: string; reqAddr: string } | null, Error | null]> - 主机信息和错误

## 消息模块 (message)

提供用户消息盒子的发送和接收功能。

### 方法

#### `sendMsgToUserBox(receiver, msg)`

向用户消息盒子发送消息。

```typescript
const result = await dc.message.sendMsgToUserBox('receiver-pubkey', 'Hello World!');
console.log('消息发送结果:', result);
```

**参数:**
- `receiver`: string - 接收者的公钥
- `msg`: string - 消息内容

**返回:** Promise<any> - 发送结果，包含消息ID和时间戳

#### `getMsgFromUserBox(limit)`

获取当前用户消息盒子中的消息。

```typescript
const messages = await dc.message.getMsgFromUserBox(10);
console.log('收到的消息:', messages);
```

**参数:**
- `limit`: number (可选) - 返回消息的最大数量

**返回:** Promise<any> - 消息列表

## 评论模块 (comment)

提供主题评论功能。

### 方法

#### `addUserOffChainSpace()`

为当前用户添加链下评论空间。

```typescript
const [success, error] = await dc.comment.addUserOffChainSpace();
if (success) {
  console.log('成功添加用户评论空间');
}
```

**参数:** 无

**返回:** Promise<[boolean | null, Error | null]> - 操作结果

#### `addThemeObj(theme, openFlag, commentSpace)`

为指定主题开通评论功能。

```typescript
const [status, error] = await dc.comment.addThemeObj(
  'my-article-1',
  OpenFlag.PUBLIC, // 评论设为公开
  100 * 1024 * 1024 // 100MB
);
if (status === 0) {
  console.log('成功开通评论功能');
}
```

**参数:**
- `theme`: string - 主题标识符
- `openFlag`: OpenFlag - 评论可见性标志
- `commentSpace`: number (可选) - 评论空间大小，默认50MB

**返回:** Promise<[number | null, Error | null]> - 状态码和错误

#### `addThemeSpace(theme, addSpace)`

为已开通评论的主题增加评论空间。

```typescript
const result = await dc.comment.addThemeSpace('my-article-1', 50 * 1024 * 1024); // 增加50MB
console.log('增加空间结果:', result);
```

**参数:**
- `theme`: string - 主题标识符
- `addSpace`: number - 增加的空间大小(字节)

**返回:** Promise<any> - 操作结果

#### `publishCommentToTheme(theme, themeAuthor, commentType, comment, refercommentkey, openFlag)`

发表评论到指定主题。

```typescript
const result = await dc.comment.publishCommentToTheme(
  'my-article-1',
  'author-pubkey',
  0, // 普通评论
  '这是一条评论内容',
  '', // 不引用其他评论
  OpenFlag.PUBLIC // 公开评论
);
console.log('评论发布结果:', result);
```

**参数:**
- `theme`: string - 主题标识符
- `themeAuthor`: string - 主题作者的公钥
- `commentType`: number - 评论类型 (0:普通评论, 1:回复评论等)
- `comment`: string - 评论内容
- `refercommentkey`: string (可选) - 引用评论的键
- `openFlag`: number (可选) - 评论可见性

**返回:** Promise<any> - 发布结果

#### `deleteSelfComment(theme, themeAuthor, commentKey)`

删除自己发布的评论。

```typescript
const result = await dc.comment.deleteSelfComment(
  'my-article-1',
  'author-pubkey',
  'comment-key-123'
);
console.log('删除评论结果:', result);
```

**参数:**
- `theme`: string - 主题标识符
- `themeAuthor`: string - 主题作者的公钥
- `commentKey`: string - 评论的唯一键

**返回:** Promise<any> - 删除结果

#### `getThemeComments(theme, themeAuthor, startHeight, direction, offset, limit, seekKey)`

获取主题的评论列表。

```typescript
const comments = await dc.comment.getThemeComments(
  'my-article-1',
  'author-pubkey',
  0, // 起始高度
  0, // 从新到旧
  0, // 不偏移
  50 // 最多返回50条
);
console.log('主题评论:', comments);
```

**参数:**
- `theme`: string - 主题标识符
- `themeAuthor`: string - 主题作者的公钥
- `startHeight`: number (可选) - 查询起始高度，默认0
- `direction`: number (可选) - 查询方向 (0:从新到旧, 1:从旧到新)，默认0
- `offset`: number (可选) - 结果集偏移量，默认0
- `limit`: number (可选) - 最大返回数量，默认100
- `seekKey`: string (可选) - 查询的起始键，格式为"blockheight/key"

**返回:** Promise<any> - 评论列表

## 键值存储模块 (keyvalue)

提供分布式键值存储功能。

### 方法

#### `createStore(theme, space, type)`

创建一个键值存储主题。

```typescript
const result = await dc.keyvalue.createStore(
  'my-app-settings',
  50 * 1024 * 1024, // 50MB
  1 // 认证存储
);
console.log('创建存储结果:', result);
```

**参数:**
- `theme`: string - 主题名称
- `space`: number - 分配的存储空间大小(字节)
- `type`: number - 存储类型 (0: 普通存储, 1: 加密存储)

**返回:** Promise<any> - 创建结果

#### `configAuth(appId, themeAuthor, theme, authPubkey, permission, remark, vaccount)`

配置主题的授权信息。

```typescript
const [status, error] = await dc.keyvalue.configAuth(
  'myapp',
  'theme-author-pubkey',
  'my-app-settings',
  'user-to-authorize-pubkey',
  Permission.READ, // 只读权限
  '测试授权'
);
if (status === 0) {
  console.log('授权配置成功');
}
```

**参数:**
- `appId`: string - 应用ID
- `themeAuthor`: string - 主题作者的公钥
- `theme`: string - 主题名称
- `authPubkey`: string - 被授权者的公钥
- `permission`: number - 权限级别 (1:只读, 3:读写)
- `remark`: string - 备注信息
- `vaccount`: string (可选) - 虚拟账户

**返回:** Promise<[number, Error | null]> - 状态码和错误

#### `setKeyValue(appId, themeAuthor, theme, key, value, indexs, vaccount)`

设置键值对数据。

```typescript
const [success, error] = await dc.keyvalue.setKeyValue(
  'myapp',
  'theme-author-pubkey',
  'my-app-settings',
  'user:prefs',
  JSON.stringify({theme: 'dark', fontSize: 14}),
  'type:prefs$$$user:123' // 设置两个索引
);
if (success) {
  console.log('数据保存成功');
}
```

**参数:**
- `appId`: string - 应用ID
- `themeAuthor`: string - 主题作者的公钥
- `theme`: string - 主题名称
- `key`: string - 键名
- `value`: string - 值内容
- `indexs`: string - 索引列表，格式为"key1:value1$$$key2:value2"
- `vaccount`: string (可选) - 虚拟账户

**返回:** Promise<[boolean, Error | null]> - 成功状态和错误

#### `getValueWithKey(appId, themeAuthor, theme, writerPubkey, key, vaccount)`

获取指定键的值。

```typescript
const [value, error] = await dc.keyvalue.getValueWithKey(
  'myapp',
  'theme-author-pubkey',
  'my-app-settings',
  'writer-pubkey',
  'user:prefs'
);
if (value) {
  const prefs = JSON.parse(value);
  console.log('用户偏好设置:', prefs);
}
```

**参数:**
- `appId`: string - 应用ID
- `themeAuthor`: string - 主题作者的公钥
- `theme`: string - 主题名称
- `writerPubkey`: string - 写入者的公钥
- `key`: string - 键名
- `vaccount`: string (可选) - 虚拟账户

**返回:** Promise<[string, Error | null]> - 值内容和错误

#### `getValuesWithIndex(appId, themeAuthor, theme, indexKey, indexValue, seekKey, offset, limit, vaccount)`

通过索引查询键值对。

```typescript
const [results, error] = await dc.keyvalue.getValuesWithIndex(
  'myapp',
  'theme-author-pubkey',
  'my-app-settings',
  'type', // 索引键
  'prefs', // 索引值
  '', // 查询起始键
  0, // 偏移量
  100 // 最大返回数量
);
if (results) {
  const prefsArray = JSON.parse(results);
  console.log('所有偏好设置:', prefsArray);
}
```

**参数:**
- `appId`: string - 应用ID
- `themeAuthor`: string - 主题作者的公钥
- `theme`: string - 主题名称
- `indexKey`: string - 索引键名
- `indexValue`: string - 索引值
- `seekKey`: string - 查询起始键
- `offset`: number - 结果偏移量
- `limit`: number - 返回结果数量限制
- `vaccount`: string (可选) - 虚拟账户

**返回:** Promise<[string, Error | null]> - JSON格式查询结果和错误

## 数据库模块 (database)

提供分布式数据库功能。

### 方法

#### `initDBManager()`

初始化数据库管理器。

```typescript
await dc.database.initDBManager();
console.log('数据库管理器已初始化');
```

**参数:** 无

**返回:** Promise<void>

#### `newDB(name, b32Rk, b32Sk, jsonCollections)`

创建新数据库。

```typescript
const collections = [
  {
    name: 'users',
    schema: {
      title: 'User',
      type: 'object',
      properties: {
        name: { type: 'string' },
        email: { type: 'string' }
      }
    }
  }
];

const threadId = await dc.database.newDB(
  'myapp-db',
  'base32-read-key',
  'base32-write-key',
  collections
);
console.log('创建数据库成功，线程ID:', threadId);
```

**参数:**
- `name`: string - 数据库名称
- `b32Rk`: string - base32编码的读取密钥
- `b32Sk`: string - base32编码的服务密钥
- `jsonCollections`: ICollectionConfig[] - 集合配置数组

**返回:** Promise<string> - 线程ID

#### `syncDbFromDC(threadid, dbname, dbAddr, b32Rk, b32Sk, block, collectionInfos)`

从分布式网络同步数据库。

```typescript
await dc.database.syncDbFromDC(
  'thread-id',
  'myapp-db',
  'db-address',
  'base32-read-key',
  'base32-write-key',
  true, // 阻塞等待直到同步完成
  collections
);
console.log('数据库同步完成');
```

**参数:**
- `threadid`: string - 线程ID
- `dbname`: string - 数据库名称
- `dbAddr`: string - 数据库地址
- `b32Rk`: string - base32编码的读取密钥
- `b32Sk`: string - base32编码的服务密钥
- `block`: boolean - 是否阻塞等待同步完成
- `collectionInfos`: ICollectionConfig[] - 集合配置数组

**返回:** Promise<void>

## 缓存模块 (cache)

提供临时缓存功能。

### 方法

#### `getCacheValue(key)`

获取缓存值。

```typescript
const value = await dc.cache.getCacheValue('cache-key');
if (value) {
  console.log('缓存值:', value);
}
```

**参数:**
- `key`: string - 缓存键

**返回:** Promise<string | null> - 缓存值，不存在则返回null

#### `setCacheKey(value, expire)`

设置缓存值。

```typescript
const result = await dc.cache.setCacheKey(
  'cache-value',
  3600 // 1小时后过期
);
console.log('缓存设置结果:', result);
```

**参数:**
- `value`: string - 缓存值
- `expire`: number (可选) - 过期时间(秒)，默认1天

**返回:** Promise<any> - 设置结果

## AI代理模块 (aiproxy)

提供AI代理服务配置和调用功能。

### 方法

#### `createProxyConfig(appId, configTheme)`

创建AI调用代理配置。

```typescript
const [status, error] = await dc.aiproxy.createProxyConfig(
  'myapp',
  'ai-services'
);
if (status === 0) {
  console.log('创建AI代理配置成功');
}
```

**参数:**
- `appId`: string - 应用ID
- `configTheme`: string - 配置主题名称

**返回:** Promise<[number, Error | null]> - 状态码和错误信息

#### `configAIProxy(appId, configAuthor, configTheme, serverName, serverConfig, vaccount)`

配置AI代理访问设置。

```typescript
const config = {
  blockheight: 12345,
  isAIModel: 0, // AI模型
  apiType: 1, // OpenAI API
  authorization: 'Bearer sk-xxxx',
  endpoint: 'https://api.openai.com/v1',
  organization: 'org-id',
  apiVersion: '2023-05-15',
  model: 'gpt-4',
  remark: '测试配置'
};

const [success, error] = await dc.aiproxy.configAIProxy(
  'myapp',
  'config-author-pubkey',
  'ai-services',
  'openai-gpt4',
  config
);

if (success) {
  console.log('AI代理配置成功');
}
```

**参数:**
- `appId`: string - 应用ID
- `configAuthor`: string - 配置作者公钥
- `configTheme`: string - 配置主题名称
- `serverName`: string - 服务器名称
- `serverConfig`: AIProxyConfig (可选) - 服务器配置，为空则表示删除该服务器的配置
- `vaccount`: string (可选) - 虚拟账户

**返回:** Promise<[boolean, Error | null]> - 是否配置成功和错误信息

#### `DoAIProxyCall(appId, themeAuthor, configTheme, serverName, reqBody, forceRefresh, onStreamResponse, headers, path, model)`

执行AI代理调用。

```typescript
const reqBody = JSON.stringify({
  messages: [
    {role: 'user', content: '请生成一个JavaScript求和函数'}
  ]
});

// 流式响应处理
const onStreamResponse = (chunk) => {
  console.log('收到流式响应:', chunk);
};

const status = await dc.aiproxy.DoAIProxyCall(
  'myapp',
  'config-author-pubkey',
  'ai-services',
  'openai-gpt4',
  reqBody,
  false, // 不强制刷新
  onStreamResponse,
  'Content-Type: application/json',
  '/v1/chat/completions'
);

console.log('API调用状态:', status);
```

**参数:**
- `appId`: string - 应用ID
- `themeAuthor`: string - 主题作者公钥
- `configTheme`: string - 配置主题名称
- `serverName`: string - 服务器名称
- `reqBody`: string - 请求体
- `forceRefresh`: boolean - 是否强制刷新
- `onStreamResponse`: (chunk: any) => void (可选) - 流式响应回调
- `headers`: string (可选) - 请求头
- `path`: string (可选) - 请求路径
- `model`: string (可选) - 模型名称

**返回:** Promise<number> - 调用状态码

## 常见使用流程

### 1. 用户认证流程

```typescript
// 1. 初始化DC客户端
const dc = new DC({
  wssUrl: 'wss://blockchain.example.com',
  appInfo: { id: 'myapp', name: 'My Application' }
});
await dc.init();

// 2. 使用NFT账号登录
const loginSuccess = await dc.auth.accountLogin('user-nft-account', 'password', '000000');
if (!loginSuccess) {
  console.error('登录失败');
  return;
}

// 3. 获取用户信息
const userInfo = await dc.auth.getUserInfoWithNft('user-nft-account');
console.log('欢迎回来,', userInfo.name);
```

### 2. 文件上传与访问流程

```typescript
// 1. 上传文件
const file = new File(['file content'], 'document.txt');
const uploadResult = await dc.file.addFile(
  file,
  'encryption-key',
  (status, size) => console.log(`上传进度: ${status}%, 已上传: ${size} 字节`)
);

const fileCid = uploadResult.cid;
console.log('文件已上传，CID:', fileCid);

// 2. 下载并使用文件
const fileContent = await dc.file.getFile(fileCid, 'encryption-key');
console.log('文件内容:', new TextDecoder().decode(fileContent));

// 3. 创建流式访问（适用于大文件）
const stream = await dc.file.createFileStream(fileCid, 'encryption-key');
// 处理流...
```

### 3. 评论系统使用流程

```typescript
// 1. 为用户开通评论空间
await dc.comment.addUserOffChainSpace();

// 2. 为主题开通评论功能
await dc.comment.addThemeObj('article-123', OpenFlag.PUBLIC);

// 3. 发布评论
const commentResult = await dc.comment.publishCommentToTheme(
  'article-123',
  'article-author-pubkey',
  0, // 普通评论
  '这是一条评论'
);

// 4. 获取评论列表
const comments = await dc.comment.getThemeComments('article-123', 'article-author-pubkey');
console.log('文章评论:', comments);
```

### 4. 键值存储使用流程

```typescript
// 1. 创建存储主题
await dc.keyvalue.createStore('app-data', 10 * 1024 * 1024, 1);

// 2. 存储数据
await dc.keyvalue.setKeyValue(
  'myapp',
  dc.auth.getPublicKey().toString(),
  'app-data',
  'settings',
  JSON.stringify({theme: 'dark', notifications: true}),
  'type:settings'
);

// 3. 读取数据
const [value, error] = await dc.keyvalue.getValueWithKey(
  'myapp',
  dc.auth.getPublicKey().toString(),
  'app-data',
  dc.auth.getPublicKey().toString(),
  'settings'
);

if (value) {
  const settings = JSON.parse(value);
  console.log('应用设置:', settings);
}
```

### 5. AI代理调用流程

```typescript
// 1. 创建AI代理配置
await dc.aiproxy.createProxyConfig('myapp', 'ai-services');

// 2. 配置AI服务
const config = {
  blockheight: 12345,
  isAIModel: 0,
  apiType: 1, // OpenAI API
  authorization: 'Bearer sk-xxxx',
  endpoint: 'https://api.openai.com/v1',
  organization: '',
  apiVersion: '2023-05-15',
  model: 'gpt-3.5-turbo',
  remark: '通用AI服务'
};

await dc.aiproxy.configAIProxy(
  'myapp',
  dc.auth.getPublicKey().toString(),
  'ai-services',
  'my-openai',
  config
);

// 3. 调用AI服务
const result = await dc.aiproxy.DoAIProxyCall(
  'myapp',
  dc.auth.getPublicKey().toString(),
  'ai-services',
  'my-openai',
  JSON.stringify({
    messages: [{role: 'user', content: 'Hello AI!'}]
  }),
  false,
  response => console.log('AI回复:', response)
);
```

onexie: 怎么把结果导出来,帮我用md格式编写

GitHub Copilot: # 如何导出 Markdown 文档

要将接口文档以 Markdown 格式导出，您可以按照以下步骤操作：

## 方法 1：直接复制到文件

1. 复制我之前提供的完整 Markdown 内容
2. 打开您喜欢的文本编辑器（如 VS Code、Sublime Text 等）
3. 粘贴内容
4. 保存文件，确保使用 `.md` 扩展名，例如 `DC-API-接口文档.md`

## 方法 2：在 VS Code 中使用命令行导出

如果您使用 VS Code，可以使用命令行创建并写入文件：

```bash
# 在项目目录下
cat > DC-API-接口文档.md << 'EOL'
# DC API 接口文档

## 目录

1. [概览](#概览)
2. [初始化](#初始化)
...
EOL
```

## 方法 3：使用 Node.js 脚本导出

您也可以创建一个小型 Node.js 脚本来保存文档：

```javascript
// save-doc.js
const fs = require('fs');

const docContent = `# DC API 接口文档

## 目录

1. [概览](#概览)
2. [初始化](#初始化)
...
`; // 粘贴完整文档内容

fs.writeFileSync('DC-API-接口文档.md', docContent, 'utf8');
console.log('文档已成功导出到 DC-API-接口文档.md');
```

然后运行：
```bash
node save-doc.js
```

## 方法 4：导出分享

您可以使用 Markdown 编辑器（如 Typora、Mark Text 等）打开该文件，然后使用其导出功能导出为 PDF、HTML 或其他格式进行分享。

---

无论使用哪种方法，您都将获得一个格式良好的 Markdown 文档，可以在任何支持 Markdown 的应用程序中查看，如 GitHub、GitLab、VS Code、Typora 等。